--- INICIO DEL ARCHIVO: package.json ---

{
"name": "arsel",
"private": true,
"version": "0.0.0",
"type": "module",
"scripts": {
"dev": "vite",
"build": "vite build",
"preview": "vite preview",
"tailwind:init": "tailwindcss init -p"
},
"dependencies": {
"@heroicons/vue": "^2.2.0",
"@supabase/supabase-js": "^2.53.1",
"browser-image-compression": "^2.0.2",
"chart.js": "^4.5.0",
"compressorjs": "^1.2.1",
"html2canvas": "^1.4.1",
"jspdf": "^3.0.1",
"jspdf-autotable": "^5.0.2",
"vue": "^3.5.18",
"vue-chartjs": "^5.3.2",
"vue-router": "^4.5.1",
"xlsx-js-style": "^1.2.0"
},
"devDependencies": {
"@vitejs/plugin-vue": "^5.0.5",
"autoprefixer": "^10.4.21",
"postcss": "^8.5.6",
"tailwindcss": "^3.4.17",
"vite": "^5.3.4",
"vite-plugin-pwa": "^0.20.0"
}
}
--- FIN DEL ARCHIVO: package.json ---

--- INICIO DEL ARCHIVO: vite.config.js ---
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { VitePWA } from 'vite-plugin-pwa'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'masked-icon.svg'],
      manifest: {
        name: 'Arsel Inspecciones',
        short_name: 'ArselInsp',
        description: 'Aplicación de gestión de inspecciones de estanterías.',
        theme_color: '#ffffff',
        background_color: '#ffffff',
        display: 'standalone',
        scope: '/',
        start_url: '/',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable',
          },
        ],
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/bgltxcklvjumltuktdvv\.supabase\.co\/storage\/v1\/object\/.*/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'supabase-images-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
            },
          },
          {
            urlPattern: /^https:\/\/bgltxcklvjumltuktdvv\.supabase\.co\/rest\/v1\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'supabase-api-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 60 * 24, // 1 day
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
            },
          },
        ],
      },
    }),
  ],
  server: {
    host: true,
  }
})
--- FIN DEL ARCHIVO: vite.config.js ---

--- INICIO DEL ARCHIVO: src/main.js ---
// src/main.js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router' // Importamos nuestro router

const app = createApp(App)

app.use(router) // Le decimos a la app que use el router

app.mount('#app')
--- FIN DEL ARCHIVO: src/main.js ---

--- INICIO DEL ARCHIVO: src/App.vue ---
<!-- src/App.vue -->
<script setup>
import { computed, onMounted, onUnmounted, onUpdated, provide } from 'vue';
import { useRoute } from 'vue-router';
import DefaultLayout from './layouts/DefaultLayout.vue';
import BlankLayout from './layouts/BlankLayout.vue';
import Notification from './components/Notification.vue';
import ConfirmModal from './components/ConfirmModal.vue';
import { useNotification } from './utils/notification';
import { useRegisterSW } from 'virtual:pwa-register/vue';
import ReloadPWA from './components/ReloadPWA.vue';
import { initializeQueue, processQueue } from './utils/syncQueue';
import { createLogger } from './utils/logger';

const logger = createLogger('App');

const { offlineReady, needRefresh, updateServiceWorker } = useRegisterSW();

const handleUpdateServiceWorker = async () => {
  await updateServiceWorker();
};

// --- INICIO DE LA MODIFICACIÓN: Nuevo handler para visibilidad ---
const handleVisibilityChange = () => {
  if (document.visibilityState === 'visible') {
    // Cuando la app vuelve a ser visible, intentamos sincronizar.
    logger.debug("App is visible again, attempting to sync queue.");
    processQueue();
  }
};
// --- FIN DE LA MODIFICACIÓN ---

onMounted(() => {
  logger.info('[App.vue] Componente montado en el DOM.');
  initializeQueue();
  window.addEventListener('online', processQueue);
  // --- INICIO DE LA MODIFICACIÓN: Añadimos el nuevo listener ---
  document.addEventListener('visibilitychange', handleVisibilityChange);
  // --- FIN DE LA MODIFICACIÓN ---
});

onUnmounted(() => {
  window.removeEventListener('online', processQueue);
  // --- INICIO DE LA MODIFICACIÓN: Limpiamos el nuevo listener ---
  document.removeEventListener('visibilitychange', handleVisibilityChange);
  // --- FIN DE LA MODIFICACIÓN ---
});

onUpdated(() => logger.debug('[App.vue] Componente actualizado (cambio de layout o ruta).'));

const { notificationShow, notificationMessage, notificationType, confirmShow, confirmTitle, confirmMessage, showNotification, showConfirm, confirmYes, confirmNo } = useNotification();
provide('showNotification', showNotification);
provide('showConfirm', showConfirm);
provide('confirmYes', confirmYes);
provide('confirmNo', confirmNo);

const route = useRoute();
const layout = computed(() => {
  const layoutName = route.meta.layout === 'Blank' ? 'BlankLayout' : 'DefaultLayout';
  logger.debug(`[App.vue] Layout computado es: ${layoutName}`);
  return layoutName === 'BlankLayout' ? BlankLayout : DefaultLayout;
});
</script>

<template>
  <ReloadPWA 
    :offline-ready="offlineReady" 
    :need-refresh="needRefresh" 
    @update-service-worker="handleUpdateServiceWorker" 
  />
  
  <component :is="layout" />
  
  <Notification
    :show="notificationShow"
    :message="notificationMessage"
    :type="notificationType"
  />
  <ConfirmModal
    :is-open="confirmShow"
    :title="confirmTitle"
    :message="confirmMessage"
    @confirm="confirmYes"
    @cancel="confirmNo"
  />
</template>
--- FIN DEL ARCHIVO: src/App.vue ---

--- INICIO DEL ARCHIVO: src/supabase.js ---
// src/supabase.js
import { createClient } from '@supabase/supabase-js'

// Estas líneas leen las claves que pusiste en el archivo .env.local
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

// Exportamos el cliente para poder usarlo en toda la aplicación
export const supabase = createClient(supabaseUrl, supabaseAnonKey)
--- FIN DEL ARCHIVO: src/supabase.js ---

--- INICIO DEL ARCHIVO: src/style.css ---
/* src/style.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
--- FIN DEL ARCHIVO: src/style.css ---

--- INICIO DEL ARCHIVO: src/utils/notification.js ---
// src/utils/notification.js
import { ref, readonly } from 'vue';

// Estado reactivo que compartiremos en toda la app
const show = ref(false);
const message = ref('');
const type = ref('success');

// Estado para confirm modal
const confirmShow = ref(false);
const confirmTitle = ref('');
const confirmMessage = ref('');
let confirmResolve = null;

// Temporizador para ocultar la notificación
let timeoutId = null;

// La función que llamaremos desde cualquier componente
export function useNotification() {
  const showNotification = (newMessage, newType = 'success', duration = 3000) => {
    message.value = newMessage;
    type.value = newType;
    show.value = true;

    // Limpiamos cualquier temporizador anterior para evitar solapamientos
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    // Ocultamos la notificación después de la duración especificada
    timeoutId = setTimeout(() => {
      show.value = false;
    }, duration);
  };

  const showConfirm = (title, msg) => {
    return new Promise((resolve) => {
      confirmTitle.value = title;
      confirmMessage.value = msg;
      confirmShow.value = true;
      confirmResolve = resolve;
    });
  };

  const confirmYes = () => {
    confirmShow.value = false;
    if (confirmResolve) confirmResolve(true);
  };

  const confirmNo = () => {
    confirmShow.value = false;
    if (confirmResolve) confirmResolve(false);
  };

  return {
    // Exportamos los estados como `readonly` para que no se puedan modificar directamente
    notificationShow: readonly(show),
    notificationMessage: readonly(message),
    notificationType: readonly(type),
    // Confirm modal
    confirmShow: readonly(confirmShow),
    confirmTitle: readonly(confirmTitle),
    confirmMessage: readonly(confirmMessage),
    // Exportamos la función que permite mostrar notificaciones
    showNotification,
    showConfirm,
    confirmYes,
    confirmNo,
  };
}
--- FIN DEL ARCHIVO: src/utils/notification.js ---

--- INICIO DEL ARCHIVO: src/utils/syncQueue.js ---
// src/utils/syncQueue.js

import { ref } from 'vue';
import { supabase } from '../supabase';
import { useNotification } from './notification';
import { createLogger } from './logger';

const { showNotification } = useNotification();
const logger = createLogger('SyncQueue');

export const syncQueue = ref([]);
export const isProcessing = ref(false);

const QUEUE_STORAGE_KEY = 'arsel-sync-queue';
export const FILE_STORAGE_KEY_PREFIX = 'arsel-offline-file-';

// LRU Cache para tempIdMap con límite de 500 entradas
const MAX_TEMP_ID_MAP_SIZE = 500;
const tempIdMapAccess = new Map(); // Tracking de último acceso
const tempIdMap = new Map();

const dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open("ArselOfflineFiles", 1);
    request.onerror = () => reject("Error al abrir IndexedDB");
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = event => {
        const db = event.target.result;
        db.createObjectStore("files");
    };
});

async function saveFileLocally(fileId, file) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(["files"], "readwrite");
        const store = transaction.objectStore("files");
        const request = store.put(file, fileId);
        request.onsuccess = () => resolve();
        request.onerror = () => reject("No se pudo guardar el archivo localmente.");
    });
}

export async function getFileLocally(fileId) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(["files"]);
        const store = transaction.objectStore("files");
        const request = store.get(fileId);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject("No se pudo leer el archivo local.");
    });
}

async function deleteFileLocally(fileId) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(["files"], "readwrite");
        const store = transaction.objectStore("files");
        store.delete(fileId);
        resolve();
    });
}

function saveQueueToStorage() {
  localStorage.setItem(QUEUE_STORAGE_KEY, JSON.stringify(syncQueue.value));
}

// Funciones LRU para tempIdMap
function setTempId(tempId, realId) {
  // Limpiar entrada más antigua si excedemos el límite
  if (tempIdMap.size >= MAX_TEMP_ID_MAP_SIZE) {
    let oldestKey = null;
    let oldestTime = Date.now();

    for (const [key, time] of tempIdMapAccess.entries()) {
      if (time < oldestTime) {
        oldestTime = time;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      tempIdMap.delete(oldestKey);
      tempIdMapAccess.delete(oldestKey);
      logger.debug(`LRU: Removed oldest tempId ${oldestKey} to make space`);
    }
  }

  tempIdMap.set(tempId, realId);
  tempIdMapAccess.set(tempId, Date.now());
  logger.debug(`Mapped ${tempId} → ${realId}`);
}

function getTempId(tempId) {
  if (!tempIdMap.has(tempId)) return null;

  // Actualizar tiempo de acceso (LRU)
  tempIdMapAccess.set(tempId, Date.now());
  return tempIdMap.get(tempId);
}

function hasTempId(tempId) {
  return tempIdMap.has(tempId);
}

export async function processQueue() {
  if (isProcessing.value || !navigator.onLine) {
    return Promise.resolve();
  }
  isProcessing.value = true;

  // Límite para evitar bucles infinitos
  let processedActions = 0;
  const maxActionsInCycle = syncQueue.value.length * 2;

  while (syncQueue.value.length > 0 && processedActions < maxActionsInCycle) {
    const action = syncQueue.value[0];
    let success = false;
    processedActions++;

    try {
      if (action.payload) {
        for (const key in action.payload) {
          if (typeof action.payload[key] === 'string' && action.payload[key].startsWith('temp_')) {
            const realId = getTempId(action.payload[key]);
            if (realId) {
              action.payload[key] = realId;
            } else {
              throw new Error(`Dependencia de ID temporal (${action.payload[key]}) no resuelta. Reintentando...`);
            }
          }
        }
      }

      const sanitizedPayload = action.payload ? { ...action.payload } : {};
      if(sanitizedPayload.id) delete sanitizedPayload.id;
      if(sanitizedPayload.created_at) delete sanitizedPayload.created_at;

      switch (action.type) {
        case 'insert':
          const { data: insertData, error: insertError } = await supabase.from(action.table).insert(sanitizedPayload).select().single();
          if (insertError) throw insertError;
          if (action.tempId) {
            setTempId(action.tempId, insertData.id);
          }
          success = true;
          break;

        case 'update':
          let updateId = action.id;
          if (typeof updateId === 'string' && updateId.startsWith('temp_')) {
            const realId = getTempId(updateId);
            if (!realId) {
              logger.warn(`Update de ${updateId} reordenado - esperando resolución`);
              throw new Error(`ID temporal ${updateId} no encontrado para actualizar.`);
            }
            updateId = realId;
            logger.debug(`Update resolved: ${action.id} → ${updateId}`);
          }
          const { error: updateError } = await supabase.from(action.table).update(sanitizedPayload).eq('id', updateId);
          if (updateError) throw updateError;
          success = true;
          break;
        
        case 'delete':
          if (typeof action.id === 'string' && action.id.startsWith('temp_')) {
            success = true;
          } else {
            const { error: deleteError } = await supabase.from(action.table).delete().eq('id', action.id);
            if (!deleteError || deleteError.code === 'PGRST116') {
              success = true;
            } else {
              throw deleteError;
            }
          }
          break;

        case 'deleteFile':
          try {
            const url = new URL(action.url);
            const pathParts = url.pathname.split('/');
            const bucketIndex = pathParts.findIndex(part => part === action.bucket);
            if (bucketIndex === -1) throw new Error(`Bucket '${action.bucket}' no encontrado en la URL.`);
            const filePath = pathParts.slice(bucketIndex + 1).join('/');
            const { error: fileDeleteError } = await supabase.storage.from(action.bucket).remove([filePath]);
            if (fileDeleteError && fileDeleteError.message !== 'The resource was not found') {
              logger.error('Error al borrar archivo del storage:', fileDeleteError);
            }
          } catch(e) {
              logger.error('URL de archivo inválida para borrado:', action.url, e);
          }
          success = true;
          break;

        case 'uploadAndUpdate':
          let fileData = await getFileLocally(action.fileId);
          if (!fileData) {
            logger.warn(`Archivo local ${action.fileId} no encontrado, saltando acción`);
            success = true;
            break;
          }
          const fileToUpload = new Blob([fileData], { type: fileData.type });
          const { error: uploadError } = await supabase.storage.from(action.bucket).upload(action.path, fileToUpload, { upsert: true });
          if (uploadError) throw uploadError;

          const { data: { publicUrl } } = supabase.storage.from(action.bucket).getPublicUrl(action.path);

          let recordId = action.recordId;
          if (typeof recordId === 'string' && recordId.startsWith('temp_')) {
            const realRecordId = getTempId(recordId);
            if (!realRecordId) {
              logger.error(`ID temporal ${recordId} no encontrado. Map size: ${tempIdMap.size}`);
              throw new Error(`ID temporal ${recordId} no encontrado para actualizar URL.`);
            }
            logger.debug(`Resolviendo ${recordId} → ${realRecordId}`);
            recordId = realRecordId;
          }

          const updateUrlPayload = {};
          updateUrlPayload[action.urlColumn] = publicUrl;
          const { error: urlUpdateError } = await supabase.from(action.table).update(updateUrlPayload).eq('id', recordId);
          if (urlUpdateError) throw urlUpdateError;

          await deleteFileLocally(action.fileId);
          logger.debug(`Archivo subido y URL actualizada para recordId ${recordId}`);
          success = true;
          break;

        default:
          throw new Error(`Tipo de acción desconocido: ${action.type}`);
      }
    } catch (error) {
      logger.error('Error al procesar la acción de la cola:', error);

      // === MANEJO ROBUSTO DE ERRORES ===
      if (error.message.includes('Dependencia de ID temporal') || error.message.includes('ID temporal no encontrado')) {
        // Error de dependencia: la acción depende de un ID temporal que aún no se ha resuelto
        logger.warn(`Reordenando acción por dependencia no resuelta:`, action);
        const failingAction = syncQueue.value.shift();
        syncQueue.value.push(failingAction);
        // NO marcamos success=true, el bucle continuará con el siguiente elemento
      } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
        // Error de red: detenemos el procesamiento para reintentar más tarde
        logger.info('Fallo de red. La sincronización se detiene y reintentará más tarde.');
        break;
      } else if (error.code === 'PGRST116' || error.message.includes('no rows returned')) {
        // El registro no existe en la BD (probablemente ya fue borrado)
        // Esto puede pasar si intentamos actualizar/borrar algo que ya no existe
        logger.warn(`Registro no encontrado, removiendo acción de la cola:`, action);
        success = true; // Marcamos como éxito para remover la acción
      } else {
        // Error grave e inesperado: detenemos la cola y notificamos
        showNotification(`Error de sincronización: ${error.message}`, 'error');
        logger.error('Error grave en cola de sincronización:', error, action);
        break;
      }
    }
    if (success) {
      syncQueue.value.shift();

      // NOTA: NO limpiamos el tempIdMap aquí
      // El mapa persiste durante toda la sesión para manejar updates tardíos
      // que puedan llegar después de que el insert se haya procesado
    }

    // Siempre guardamos el estado actual de la cola, especialmente si la hemos reordenado.
    saveQueueToStorage();
  }

  isProcessing.value = false;
  return Promise.resolve();
}

/**
 * Waits for the sync queue to become empty
 * @param {number} timeout - Timeout in milliseconds (default: 30000ms = 30s)
 * @returns {Promise<void>} Resolves when queue is empty or timeout is reached
 */
export async function waitForQueueToEmpty(timeout = 30000) {
  const startTime = Date.now();
  const checkInterval = 100; // Check every 100ms

  return new Promise((resolve, reject) => {
    const checkQueue = () => {
      // Check if queue is empty
      if (syncQueue.value.length === 0 && !isProcessing.value) {
        logger.debug('Queue is empty');
        resolve();
        return;
      }

      // Check if timeout exceeded
      if (Date.now() - startTime >= timeout) {
        const remainingItems = syncQueue.value.length;
        logger.warn(`Queue timeout after ${timeout}ms with ${remainingItems} items remaining`);
        reject(new Error(`Tiempo de espera agotado. Quedan ${remainingItems} elementos pendientes de sincronización.`));
        return;
      }

      // Continue checking
      setTimeout(checkQueue, checkInterval);
    };

    checkQueue();
  });
}

export async function addToQueue(action) {
  // === OPTIMIZACIÓN: Borrado de registros con ID temporal ===
  // Si intentamos borrar un registro con ID temporal (creado offline),
  // eliminamos TODAS las acciones relacionadas con ese ID temporal de la cola.
  if (action.type === 'delete' && typeof action.id === 'string' && action.id.startsWith('temp_')) {
    const tempId = action.id;
    const actionsToRemove = [];

    // Buscamos todas las acciones relacionadas con este ID temporal
    syncQueue.value.forEach((item, index) => {
      // Insert con este tempId
      if (item.type === 'insert' && item.tempId === tempId) {
        actionsToRemove.push(index);
      }
      // Update con este id
      else if (item.type === 'update' && item.id === tempId) {
        actionsToRemove.push(index);
      }
      // uploadAndUpdate con este recordId
      else if (item.type === 'uploadAndUpdate' && item.recordId === tempId) {
        actionsToRemove.push(index);
        // Si hay un archivo guardado localmente, lo borramos
        if (item.fileId) {
          deleteFileLocally(item.fileId).catch(err =>
            logger.warn(`No se pudo borrar archivo local ${item.fileId}:`, err)
          );
        }
      }
    });

    // Eliminamos las acciones en orden inverso para no afectar los índices
    if (actionsToRemove.length > 0) {
      actionsToRemove.reverse().forEach(index => {
        syncQueue.value.splice(index, 1);
      });

      // Limpiamos el tempIdMap si existe
      if (hasTempId(tempId)) {
        tempIdMap.delete(tempId);
        tempIdMapAccess.delete(tempId);
      }

      showNotification('Operaciones locales de la incidencia canceladas.', 'info', 2000);
      saveQueueToStorage();
      return; // No agregamos la acción de delete
    }
  }

  // === OPTIMIZACIÓN: Borrado de archivos asociados ===
  // Si es un deleteFile, buscamos si hay una acción uploadAndUpdate pendiente con la misma ruta
  if (action.type === 'deleteFile') {
    const filePathToDelete = extractFilePathFromUrl(action.url, action.bucket);

    // Buscamos uploadAndUpdate pendientes con la misma ruta
    const uploadIndex = syncQueue.value.findIndex(
      item => item.type === 'uploadAndUpdate' &&
              item.bucket === action.bucket &&
              item.path === filePathToDelete
    );

    if (uploadIndex > -1) {
      const uploadAction = syncQueue.value[uploadIndex];
      // Borramos el archivo local si existe
      if (uploadAction.fileId) {
        await deleteFileLocally(uploadAction.fileId).catch(err =>
          logger.warn(`No se pudo borrar archivo local ${uploadAction.fileId}:`, err)
        );
      }
      // Eliminamos la acción de upload
      syncQueue.value.splice(uploadIndex, 1);
      saveQueueToStorage();
      return; // No agregamos la acción de deleteFile
    }
  }

  // === Procesamiento normal de acciones ===
  if (action.type === 'uploadAndUpdate' && action.file) {
      const fileId = `${FILE_STORAGE_KEY_PREFIX}${Date.now()}`;
      try {
          await saveFileLocally(fileId, action.file);
          action.fileId = fileId;
          delete action.file;
      } catch(e) {
          showNotification(e.message, 'error');
          return;
      }
  }

  syncQueue.value.push(action);
  saveQueueToStorage();
  processQueue();
}

// Helper para extraer el path del archivo desde una URL
function extractFilePathFromUrl(url, bucket) {
  try {
    const urlObj = new URL(url);
    const pathParts = urlObj.pathname.split('/');
    const bucketIndex = pathParts.findIndex(part => part === bucket);
    if (bucketIndex === -1) return null;
    return pathParts.slice(bucketIndex + 1).join('/');
  } catch (e) {
    logger.error('Error extrayendo path de URL:', e);
    return null;
  }
}

export function initializeQueue() {
  const savedQueue = localStorage.getItem(QUEUE_STORAGE_KEY);
  if (savedQueue) {
    syncQueue.value = JSON.parse(savedQueue);

    // === LIMPIEZA DE ACCIONES HUÉRFANAS ===
    // Eliminamos acciones update/uploadAndUpdate de IDs temporales que no tienen insert
    const tempIdsWithInsert = new Set();

    // Primera pasada: recolectar todos los tempIds que tienen insert
    syncQueue.value.forEach(action => {
      if (action.type === 'insert' && action.tempId) {
        tempIdsWithInsert.add(action.tempId);
      }
    });

    // Segunda pasada: eliminar acciones huérfanas
    syncQueue.value = syncQueue.value.filter(action => {
      // Si es un update o uploadAndUpdate con ID temporal sin insert correspondiente
      if ((action.type === 'update' || action.type === 'uploadAndUpdate') &&
          typeof action.id === 'string' && action.id.startsWith('temp_') &&
          !tempIdsWithInsert.has(action.id)) {
        logger.warn(`Removiendo acción huérfana de ID temporal ${action.id}:`, action);

        // Si es uploadAndUpdate, borramos el archivo local
        if (action.type === 'uploadAndUpdate' && action.fileId) {
          deleteFileLocally(action.fileId).catch(err =>
            logger.warn(`No se pudo borrar archivo local ${action.fileId}:`, err)
          );
        }

        return false; // Filtrar esta acción
      }

      // Mismo chequeo para uploadAndUpdate con recordId
      if (action.type === 'uploadAndUpdate' &&
          typeof action.recordId === 'string' && action.recordId.startsWith('temp_') &&
          !tempIdsWithInsert.has(action.recordId)) {
        logger.warn(`Removiendo uploadAndUpdate huérfano de recordId ${action.recordId}:`, action);

        if (action.fileId) {
          deleteFileLocally(action.fileId).catch(err =>
            logger.warn(`No se pudo borrar archivo local ${action.fileId}:`, err)
          );
        }

        return false;
      }

      return true; // Mantener esta acción
    });

    saveQueueToStorage();
  }

  processQueue();
}
--- FIN DEL ARCHIVO: src/utils/syncQueue.js ---

--- INICIO DEL ARCHIVO: src/utils/plano-layout.js ---
// src/utils/plano-layout.js

export function calculatePlanoLayout(allPointsData, mapDimensions, badgeWidthRatio) {
    const BADGE_ASPECT_RATIO = 45 / 55;
    const badgeSize = {
        width: mapDimensions.width * badgeWidthRatio,
        height: mapDimensions.width * badgeWidthRatio * BADGE_ASPECT_RATIO
    };

    const placedObstacles = allPointsData.map(p => ({
        x: p.relativeX * mapDimensions.width, 
        y: p.relativeY * mapDimensions.height,
        width: 1, height: 1 // Los puntos son obstáculos pequeños
    }));

    const labelsToDraw = [];
    const mapCenterX = mapDimensions.width / 2;
    const mapCenterY = mapDimensions.height / 2;
    
    const sortedPoints = [...allPointsData].sort((a, b) => {
        const distA = Math.sqrt(Math.pow((a.relativeX * mapDimensions.width) - mapCenterX, 2) + Math.pow((a.relativeY * mapDimensions.height) - mapCenterY, 2));
        const distB = Math.sqrt(Math.pow((b.relativeX * mapDimensions.width) - mapCenterX, 2) + Math.pow((b.relativeY * mapDimensions.height) - mapCenterY, 2));
        return distA - distB;
    });

    for (const point of sortedPoints) {
        const needsBadge = point.estado !== 'existente' || point.detalle_modificacion !== null ||
            (point.counts.verde > 0 || point.counts.ambar > 0 || point.counts.rojo > 0);
        if (!needsBadge) continue;

        const pointAbs = {
            x: point.relativeX * mapDimensions.width,
            y: point.relativeY * mapDimensions.height
        };
        
        const finalPositionAbs = findNonOverlappingPosition(pointAbs, badgeSize, placedObstacles, mapDimensions);
        
        const badgeRect = { 
            x: finalPositionAbs.x - badgeSize.width / 2, 
            y: finalPositionAbs.y - badgeSize.height / 2, 
            ...badgeSize 
        };
        placedObstacles.push(badgeRect);
        
        labelsToDraw.push({
            pointData: point,
            position: { // Posición RELATIVA (0-1)
                x: finalPositionAbs.x / mapDimensions.width,
                y: finalPositionAbs.y / mapDimensions.height
            },
            size: { // Tamaño RELATIVO (0-1)
                width: badgeSize.width / mapDimensions.width,
                height: badgeSize.height / mapDimensions.height
            }
        });
    }
    return labelsToDraw;
}

function findNonOverlappingPosition(pointAbs, badgeSize, obstacles, pageBounds) {
    const isOverlapping = (rect1, rect2) => {
        const margin = 5; 
        return !(rect1.x > rect2.x + rect2.width + margin ||
            rect1.x + rect1.width + margin < rect2.x ||
            rect1.y > rect2.y + rect2.height + margin ||
            rect1.y + rect1.height + margin < rect2.y);
    };
    const isWithinBounds = (rect) => (
        rect.x >= 0 &&
        rect.y >= 0 &&
        rect.x + rect.width <= pageBounds.width &&
        rect.y + rect.height <= pageBounds.height
    );
    const checkPosition = (pos) => {
        const candidateRect = {
            x: pos.x - badgeSize.width / 2,
            y: pos.y - badgeSize.height / 2,
            ...badgeSize
        };
        if (isWithinBounds(candidateRect) && !obstacles.some(obs => isOverlapping(candidateRect, obs))) {
            return pos;
        }
        return null;
    };
    const preferredOffsets = [
        { x: 0, y: -(badgeSize.height / 2 + 10) }, { x: 0, y: (badgeSize.height / 2 + 10) },
        { x: (badgeSize.width / 2 + 10), y: 0 },   { x: -(badgeSize.width / 2 + 10), y: 0 }
    ];
    for (const offset of preferredOffsets) {
        const position = checkPosition({ x: pointAbs.x + offset.x, y: pointAbs.y + offset.y });
        if (position) return position;
    }

    let x = pointAbs.x, y = pointAbs.y, dx = 0, dy = -1, stepSize = 10, stepsInSegment = 1, turnCounter = 0;
    for (let i = 0; i < 1000; i++) {
        for (let j = 0; j < Math.floor(stepsInSegment); j++) {
            x += dx * stepSize;
            y += dy * stepSize;
            const position = checkPosition({ x, y });
            if (position) return position;
        }
        [dx, dy] = [-dy, dx];
        turnCounter++;
        if (turnCounter % 2 === 0) stepsInSegment += 0.5;
    }
    return { x: pointAbs.x, y: pointAbs.y - (badgeSize.height / 2 + 10) };
}
--- FIN DEL ARCHIVO: src/utils/plano-layout.js ---

--- INICIO DEL ARCHIVO: src/utils/logger.js ---
// src/utils/logger.js

/**
 * Sistema de logging condicional para desarrollo/producción
 *
 * En producción: Solo errores críticos
 * En desarrollo: Logs completos con contexto
 */

const isDevelopment = import.meta.env.DEV || import.meta.env.MODE === 'development';

const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  NONE: 4
};

// En producción solo mostramos errores, en desarrollo todo
const currentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.ERROR;

class Logger {
  constructor(context = 'App') {
    this.context = context;
  }

  _log(level, levelName, message, ...args) {
    if (level < currentLogLevel) return;

    const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
    const prefix = `[${timestamp}] [${this.context}]`;

    switch (level) {
      case LOG_LEVELS.DEBUG:
        console.log(`${prefix} 🔍`, message, ...args);
        break;
      case LOG_LEVELS.INFO:
        console.log(`${prefix} ℹ️`, message, ...args);
        break;
      case LOG_LEVELS.WARN:
        console.warn(`${prefix} ⚠️`, message, ...args);
        break;
      case LOG_LEVELS.ERROR:
        console.error(`${prefix} ❌`, message, ...args);
        break;
    }
  }

  debug(message, ...args) {
    this._log(LOG_LEVELS.DEBUG, 'DEBUG', message, ...args);
  }

  info(message, ...args) {
    this._log(LOG_LEVELS.INFO, 'INFO', message, ...args);
  }

  warn(message, ...args) {
    this._log(LOG_LEVELS.WARN, 'WARN', message, ...args);
  }

  error(message, ...args) {
    this._log(LOG_LEVELS.ERROR, 'ERROR', message, ...args);
  }

  // Helper para crear loggers con contexto específico
  static create(context) {
    return new Logger(context);
  }
}

// Logger por defecto
export const logger = new Logger('App');

// Factory para crear loggers con contexto
export const createLogger = (context) => new Logger(context);

// Export para usar en console.log existentes sin cambiar mucho código
export default logger;

--- FIN DEL ARCHIVO: src/utils/logger.js ---

--- INICIO DEL ARCHIVO: src/utils/provincias.js ---
// src/utils/provincias.js
export const provincias = [
  'Álava', 'Albacete', 'Alicante', 'Almería', 'Asturias', 'Ávila', 'Badajoz', 'Barcelona', 'Burgos', 'Cáceres', 
  'Cádiz', 'Cantabria', 'Castellón', 'Ciudad Real', 'Córdoba', 'La Coruña', 'Cuenca', 'Gerona', 'Granada', 'Guadalajara', 
  'Guipúzcoa', 'Huelva', 'Huesca', 'Islas Baleares', 'Jaén', 'León', 'Lérida', 'Lugo', 'Madrid', 'Málaga', 'Murcia', 
  'Navarra', 'Orense', 'Palencia', 'Las Palmas', 'Pontevedra', 'La Rioja', 'Salamanca', 'Segovia', 'Sevilla', 
  'Soria', 'Tarragona', 'Santa Cruz de Tenerife', 'Teruel', 'Toledo', 'Valencia', 'Valladolid', 'Vizcaya', 'Zamora', 'Zaragoza'
];
--- FIN DEL ARCHIVO: src/utils/provincias.js ---

--- INICIO DEL ARCHIVO: src/utils/checklist.js ---
// src/utils/checklist.js
export const checklistItems = [
  { id: 1, text: "Existe copia de la documentación de validación" },
  { id: 2, text: "Tiene las placas de identificación correctamente colocadas y son legibles." },
  { id: 3, text: "El número de módulos y niveles se corresponde con el establecido en el documento de validación." },
  { id: 4, text: "Los niveles de altura están dentro de los límites establecidos." },
  { id: 5, text: "El tipo de puntal se corresponde con el del documento de validación." },
  { id: 6, text: "La verticalidad de los puntales está dentro de los límites permitidos." },
  { id: 7, text: "Las placas base no presentan deterioro y tienen todos los tornillos de fijación previsto." },
  { id: 8, text: "Las placas base no presentan descalce." },
  { id: 9, text: "La estantería no está fijada a otros elementos." },
  { id: 10, text: "La estantería no sirve de soporte a otros elementos." },
  { id: 11, text: "Los puntales no presentan deterioro." },
  { id: 12, text: "Las diagonales y horizontales de bastidores no presentan deterioro." },
  { id: 13, text: "El tipo de larguero se corresponde con el del documento de validación." },
  { id: 14, text: "Los largueros no presentan deterioro." },
  { id: 15, text: "Los largueros están montados horizontales y a la misma altura que el larguero opuesto." },
  { id: 16, text: "La flecha de los largueros está dentro de los límites establecidos en el documento de validación." },
  { id: 17, text: "Los largueros tienen puesto correctamente el dispositivo de fijación (horquillas)." },
  { id: 18, text: "No se aprecia en inspección visual grietas en soldadura o material base." },
  { id: 19, text: "Los elementos del sistema no presentan degradación por pérdida de pintura de protección y/o oxidación." },
  { id: 20, text: "El estado de las protecciones en el bastidor es correcto (mantienen distancia de seguridad y están correctamente fijadas al suelo)." },
  { id: 21, text: "Las cargas se ajustan a las dimensiones estandarizadas para las paletas." },
  { id: 22, text: "Las cargas a nivel de suelo no sobresalen de la alineación, respetando los anchos de pasillo." },
  { id: 23, text: "La iluminación es adecuada." },
  { id: 24, text: "En estanterías de picking las barandillas de segundo nivel están en perfecto estado, tienen pasamanos superior, intermedio y rodapié." },
  { id: 25, text: "En estanterías de picking se mantienen todos los elementos de los niveles previstos y en caso contrario se mantiene los largueros y/o baldas superiores y se ha señalizado correctamente 'no utilizar'." },
  { id: 26, text: "La carga se distribuye uniformemente y de forma ordenada." },
  { id: 27, text: "Las cargas están dentro de los límites establecidos en las placas identificativas." },
];
--- FIN DEL ARCHIVO: src/utils/checklist.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-checklist.js ---
// src/utils/pdf/pdf-module-checklist.js

import autoTable from 'jspdf-autotable';
import { checklistItems } from '../checklist';
import { FONT_SIZES, DOC_WIDTH, drawHeader, loadImageAsBase64 } from './pdf-helpers'; // Importamos loadImageAsBase64
import { getArselLogoUrl } from './pdf-helpers';
import { supabase } from '../../supabase';

function getHighestSeverity(incidencias) {
    if (incidencias.some(inc => inc.gravedad === 'rojo')) return 'rojo';
    if (incidencias.some(inc => inc.gravedad === 'ambar')) return 'ambar';
    if (incidencias.some(inc => inc.gravedad === 'verde')) return 'verde';
    return null;
}

export async function buildChecklistAnnex(pdf, reportData) {
    const LOCAL_MARGIN = 15;
    const { inspectionData, salasData, puntosMaestrosData, puntosInspeccionadosData, incidenciasData } = reportData;

    if (!incidenciasData || incidenciasData.length === 0) {
        return;
    }

    const [customFieldsRes, arselLogoUrl] = await Promise.all([
        supabase.from('checklist_custom_fields').select('*'),
        getArselLogoUrl()
    ]);
    const customFieldsMap = new Map(customFieldsRes.data.map(f => [f.id, f]));
    const puntosInspeccionadosConIncidenciasIds = new Set(incidenciasData.map(inc => inc.punto_inspeccionado_id));
    const puntosMaestrosConIncidenciasIds = new Set(
        puntosInspeccionadosData
            .filter(pi => puntosInspeccionadosConIncidenciasIds.has(pi.id))
            .map(pi => pi.punto_maestro_id)
    );
    if (puntosMaestrosConIncidenciasIds.size === 0) {
        return;
    }

    pdf.addPage();
    autoTable(pdf, {
        body: [['ANEXO 02:\nCHECKLIST']],
        startY: 145,
        theme: 'plain',
        styles: { 
            fontSize: FONT_SIZES.annexTitle, 
            fontStyle: 'bold', 
            halign: 'center',
            font: 'helvetica',
            textColor: 0
        },
        margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
    });

    for (const sala of salasData) {
        const puntosDeLaSala = puntosMaestrosData
            .filter(pm => pm.sala_id === sala.id && puntosMaestrosConIncidenciasIds.has(pm.id))
            .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}));
        
        if (puntosDeLaSala.length === 0) {
            continue;
        }

        for (const puntoMaestro of puntosDeLaSala) {
            pdf.addPage();

            const [clientLogoBase64, arselLogoBase64] = await Promise.all([
                loadImageAsBase64(inspectionData.centros.url_logo_cliente, { optimize: false }),
                loadImageAsBase64(arselLogoUrl, { optimize: false })
            ]);

            const logoHeight = 8;
            const headerY = 12;
            const arselLogoWidth = 30;

            if (clientLogoBase64) {
                pdf.addImage(clientLogoBase64, 'JPEG', LOCAL_MARGIN, headerY, 0, logoHeight);
            }
            if (arselLogoBase64) {
                pdf.addImage(arselLogoBase64, 'JPEG', DOC_WIDTH - LOCAL_MARGIN - arselLogoWidth, headerY, arselLogoWidth, logoHeight);
            }
            
            const firstTableStartY = headerY + logoHeight + 3;

            autoTable(pdf, {
                body: [['FORMATO DE INSPECCIÓN DEL SISTEMA DE ALMACENAJE']],
                startY: firstTableStartY,
                theme: 'grid',
                styles: {
                    fontSize: 10,
                    fontStyle: 'bold',
                    halign: 'center',
                    fillColor: [255, 192, 0],
                    textColor: 0,
                    lineColor: 0,
                    lineWidth: 0.1,
                    minCellHeight: 8
                },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });

            autoTable(pdf, {
                body: [[
                    `CENTRO: ${inspectionData.centros.nombre.toUpperCase()}`,
                    `Reserva: ${sala.nombre.toUpperCase()}`,
                    `Alineación: ${puntoMaestro.nomenclatura.split('-').pop()}`
                ]],
                startY: pdf.lastAutoTable.finalY,
                theme: 'grid',
                styles: {
                    fontStyle: 'bold',
                    fontSize: 9,
                    textColor: 0,
                    lineColor: 0,
                    lineWidth: 0.1,
                    valign: 'middle',
                    minCellHeight: 8
                },
                columnStyles: {
                    0: { cellWidth: 108, halign: 'left' },
                    1: { cellWidth: 42, halign: 'center' },
                    2: { cellWidth: 30, halign: 'center' }
                },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });
            
            const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.punto_maestro_id === puntoMaestro.id);
            const puntoInspeccionadoId = puntoInspeccionado ? puntoInspeccionado.id : null;
            
            const head = [
                [
                    { content: 'Parámetro de control', rowSpan: 2, styles: { halign: 'center', valign: 'middle', fontSize: 9 } },
                    { content: 'S', rowSpan: 2, styles: { halign: 'center', valign: 'middle', fontSize: 8 } },
                    { content: 'I', rowSpan: 2, styles: { halign: 'center', valign: 'middle', fontSize: 8 } },
                    { content: 'RIESGO', colSpan: 3, styles: { halign: 'center', fontSize: 8 } }
                ],
                [{ content: 'V', styles: { fontSize: 8 } }, { content: 'A', styles: { fontSize: 8 } }, { content: 'R', styles: { fontSize: 8 } }]
            ];
            
            const body = checklistItems.map(item => {
                const itemIncidencias = incidenciasData.filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && inc.item_checklist === item.id);
                const tieneIncidencias = itemIncidencias.length > 0;
                const maxSeverity = tieneIncidencias ? getHighestSeverity(itemIncidencias) : null;
                
                return [
                    `${item.id}. ${item.text}`,
                    !tieneIncidencias ? 'X' : '',
                    tieneIncidencias ? 'X' : '',
                    maxSeverity === 'verde' ? 'X' : '',
                    maxSeverity === 'ambar' ? 'X' : '',
                    maxSeverity === 'rojo' ? 'X' : '',
                ];
            });

            autoTable(pdf, {
                head, body, 
                startY: pdf.lastAutoTable.finalY,
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }, 
                theme: 'grid',
                headStyles: { 
                    fillColor: [220, 220, 220], 
                    textColor: 0, 
                    fontStyle: 'bold', 
                    halign: 'center', 
                    lineColor: 0, 
                    lineWidth: 0.1, 
                    font: 'helvetica' 
                },
                // --- INICIO DE LA CORRECCIÓN 2: Reducir el espaciado de las celdas ---
                styles: { fontSize: 8, cellPadding: 1.0, overflow: 'linebreak', lineColor: 0, lineWidth: 0.1, font: 'helvetica', textColor: 0 }, // cellPadding reducido de 1.5 a 1.0
                // --- FIN DE LA CORRECCIÓN 2 ---
                columnStyles: {
                    0: { cellWidth: 136 },
                    1: { cellWidth: 7, halign: 'center' }, 
                    2: { cellWidth: 7, halign: 'center' }, 
                    3: { cellWidth: 10, halign: 'center' }, 
                    4: { cellWidth: 10, halign: 'center' }, 
                    5: { cellWidth: 10, halign: 'center' },
                },
            });

            let finalY = pdf.lastAutoTable.finalY;

            // --- INICIO DE LA CORRECCIÓN 1: Bajar el límite de observaciones ---
            const OBSERVACIONES_THRESHOLD_COUNT = 10; // Reducido de 12 a 10
            // --- FIN DE LA CORRECCIÓN 1 ---

            const observacionesArray = incidenciasData
                .filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && (inc.observaciones || inc.custom_fields))
                .map((obs) => {
                    let parts = [];
                    if (obs.custom_fields) {
                        const customs = Object.entries(obs.custom_fields).map(([fieldId, value]) => {
                            const field = customFieldsMap.get(parseInt(fieldId));
                            return field && value ? `${field.field_name}: ${value}` : '';
                        }).filter(s => s);
                        parts.push(...customs);
                    }
                    if (obs.observaciones && obs.observaciones.trim()) {
                        parts.push(`Observaciones: ${obs.observaciones.trim()}`);
                    }
                    if (parts.length > 0) {
                        return { text: `Parámetro ${obs.item_checklist}: ${parts.join(' / ')}` };
                    }
                    return null;
                })
                .filter(obs => obs !== null);

            if (observacionesArray.length >= OBSERVACIONES_THRESHOLD_COUNT) {
                const placeholderText = '* Las observaciones detalladas para esta alineación se encuentran en la página siguiente.';
                autoTable(pdf, {
                    body: [[{ content: placeholderText, styles: { fontStyle: 'italic', valign: 'top' } }]],
                    startY: finalY,
                    theme: 'grid',
                    styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 20, font: 'helvetica', textColor: 0 },
                    margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
                });
                finalY = pdf.lastAutoTable.finalY;

                pdf.addPage();
                await drawHeader(pdf, inspectionData, arselLogoUrl);

                autoTable(pdf, {
                    head: [[`Observaciones Detalladas de la Alineación: ${puntoMaestro.nomenclatura}`]],
                    body: observacionesArray.map(obs => [obs.text]),
                    startY: 40,
                    theme: 'grid',
                    headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold' },
                    styles: { fontSize: FONT_SIZES.small, font: 'helvetica', textColor: 0 },
                    margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
                });

            } else {
                const observacionesDelPunto = observacionesArray.map(obs => obs.text).join('\n');
                autoTable(pdf, {
                    body: [[{ content: `Observaciones:\n${observacionesDelPunto}`, styles: { fontStyle: 'bold', valign: 'top' } }]],
                    startY: finalY,
                    theme: 'grid',
                    styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 20, font: 'helvetica', textColor: 0 },
                    margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
                });
                finalY = pdf.lastAutoTable.finalY;
            }

            const fechaInspeccion = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
            autoTable(pdf, {
                body: [[
                    `Fecha revisión: ${fechaInspeccion}\n\nFirma de Arsel Ingenieria S.L.:`,
                    `Firma del PRSES:`
                ]],
                startY: finalY,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 15, valign: 'top', font: 'helvetica', textColor: 0 },
                columnStyles: { 1: { halign: 'left' } },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });

            autoTable(pdf, {
                body: [['S: Satisfactorio, I: Insatisfactorio; V: Verde, A: Ámbar, R: Rojo']],
                startY: pdf.lastAutoTable.finalY,
                theme: 'plain',
                styles: { fontSize: 7, halign: 'left', font: 'helvetica', textColor: 0 },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });
        }
    }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-checklist.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-summary.js ---
// src/utils/pdf/pdf-module-summary.js

import { MARGIN } from './pdf-helpers';

function drawInfoBadge(pdf, position, pointData, badgeSizeMM) {
    const { width: BADGE_WIDTH_MM, height: BADGE_HEIGHT_MM } = badgeSizeMM;

    const FONT_SIZE_HEADER = BADGE_HEIGHT_MM * 0.70;
    const FONT_SIZE_STATE = BADGE_HEIGHT_MM * 0.38;
    const FONT_SIZE_SEMAPHORE = BADGE_HEIGHT_MM * 0.45;

    let stateText = null;
    if (pointData.estado === 'nuevo') stateText = 'NUEVA';
    else if (pointData.estado === 'suprimido') stateText = 'SUPRIMIDA';
    else if (pointData.detalle_modificacion === 'aumentado') stateText = 'AUMENTADA';
    else if (pointData.detalle_modificacion === 'disminuido') stateText = 'DISMINUIDA';

    const startX = position.x - BADGE_WIDTH_MM / 2;
    let currentY = position.y - BADGE_HEIGHT_MM / 2;

    pdf.setFillColor(255, 255, 255);
    pdf.roundedRect(startX, currentY, BADGE_WIDTH_MM, BADGE_HEIGHT_MM, 1, 1, 'F');

    pdf.setFontSize(FONT_SIZE_HEADER).setFont(undefined, 'bold');
    pdf.setTextColor(50, 50, 50);
    const headerText = `${pointData.nomenclatura.split('-').pop() || '?'}`;
    
    const headerY = stateText ? currentY + BADGE_HEIGHT_MM * 0.22 : currentY + BADGE_HEIGHT_MM * 0.35;
    pdf.text(headerText, position.x, headerY, { align: 'center' });

    if (stateText) {
        pdf.setFontSize(FONT_SIZE_STATE).setFont(undefined, 'bold');
        pdf.setTextColor(29, 78, 216);
        pdf.text(stateText, position.x, headerY + BADGE_HEIGHT_MM * 0.2, { align: 'center' });
    }
    
    currentY += BADGE_HEIGHT_MM * 0.5;
    pdf.setDrawColor(220, 220, 220);
    pdf.line(startX + 1, currentY, startX + BADGE_WIDTH_MM - 1, currentY);
    currentY += 0.5;

    const items = [
      { color: [34, 197, 94], count: pointData.counts.verde },
      { color: [245, 158, 11], count: pointData.counts.ambar },
      { color: [239, 68, 68], count: pointData.counts.rojo },
    ];
    const circleRadius = BADGE_HEIGHT_MM * 0.15;
    const semaphoreStartX = position.x - (items.length - 1) * (circleRadius * 2 + 0.8) / 2;
    
    pdf.setFontSize(FONT_SIZE_SEMAPHORE).setFont(undefined, 'bold');
    
    items.forEach((item, index) => {
        const circleX = semaphoreStartX + index * (circleRadius * 2 + 0.8);
        const circleY = currentY + BADGE_HEIGHT_MM * 0.2;
        pdf.setFillColor(item.color[0], item.color[1], item.color[2]);
        pdf.circle(circleX, circleY, circleRadius, 'F');
        pdf.setTextColor(255, 255, 255);
        pdf.text(String(item.count), circleX, circleY, { align: 'center', baseline: 'middle' });
    });
}

function drawLeaderLine(pdf, from, to) {
    pdf.setDrawColor(150, 150, 150);
    pdf.setLineWidth(0.2);
    pdf.line(from.x, from.y, to.x, to.y);
}

export async function buildSummaryAnnex(pdf, reportData, finalLabels, originalDimensions) {
    const { planoBase64 } = reportData;

    const PAGE_WIDTH_MM = pdf.internal.pageSize.getWidth();
    const PAGE_HEIGHT_MM = pdf.internal.pageSize.getHeight();
    
    const pageBounds = { x: MARGIN, y: MARGIN, width: PAGE_WIDTH_MM - MARGIN * 2, height: PAGE_HEIGHT_MM - MARGIN * 2 };

    const pageAspectRatio = pageBounds.width / pageBounds.height;
    const imageAspectRatio = originalDimensions.width / originalDimensions.height;

    let imgWidthMM, imgHeightMM, planoStartX, planoStartY;
    if (imageAspectRatio > pageAspectRatio) {
        imgWidthMM = pageBounds.width;
        imgHeightMM = imgWidthMM / imageAspectRatio;
        planoStartX = pageBounds.x;
        planoStartY = pageBounds.y + (pageBounds.height - imgHeightMM) / 2;
    } else {
        imgHeightMM = pageBounds.height;
        imgWidthMM = imgHeightMM * imageAspectRatio;
        planoStartY = pageBounds.y;
        planoStartX = pageBounds.x + (pageBounds.width - imgWidthMM) / 2;
    }

    pdf.addImage(planoBase64, 'JPEG', planoStartX, planoStartY, imgWidthMM, imgHeightMM, undefined, 'FAST');
    
    const labelsInMM = finalLabels.map(label => {
        const pointPdfX = planoStartX + (label.pointData.relativeX * imgWidthMM);
        const pointPdfY = planoStartY + (label.pointData.relativeY * imgHeightMM);
        const labelPdfX = planoStartX + (label.position.x * imgWidthMM);
        const labelPdfY = planoStartY + (label.position.y * imgHeightMM);
        
        const badgeSizeMM = {
            width: label.size.width * imgWidthMM,
            height: label.size.height * imgHeightMM
        };

        return {
            pointData: label.pointData,
            pointPosition: { x: pointPdfX, y: pointPdfY },
            labelPosition: { x: labelPdfX, y: labelPdfY },
            badgeSizeMM: badgeSizeMM
        };
    });

    labelsInMM.forEach(label => {
        drawLeaderLine(pdf, label.pointPosition, label.labelPosition);
    });
    
    labelsInMM.forEach(label => {
        drawInfoBadge(pdf, label.labelPosition, label.pointData, label.badgeSizeMM);
    });
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-summary.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-text.js ---
// src/utils/pdf/pdf-module-text.js

import { drawHeader, loadImageAsBase64, getArselLogoUrl, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

export async function buildTextPages(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;

  // Fetch logo URL
  const arselLogoUrl = await getArselLogoUrl();

  const CONTENT_WIDTH = DOC_WIDTH - (MARGIN * 2);

  const fecha = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
  const puntoMaestroASalaMap = new Map();
  puntosMaestrosData.forEach(pm => {
    const sala = salasData.find(s => s.id === pm.sala_id);
    if (sala) puntoMaestroASalaMap.set(pm.id, sala);
  });
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const agruparPuntosPorPropiedad = (propiedad, valor) => {
    const puntosFiltrados = puntosInspeccionadosData.filter(pi => pi[propiedad] === valor);
    if (puntosFiltrados.length === 0) return '';
    const grupos = {};
    puntosFiltrados.forEach(pi => {
      const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
      if (sala) {
        if (!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
        grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
      }
    });
    return Object.keys(grupos).sort().map(nombreSala =>
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
  };

  const agruparPuntosConPlacaInvalida = () => {
    const puntosConProblemaDePlaca = puntosInspeccionadosData.filter(pi => 
        pi.tiene_placa_caracteristicas === false || pi.detalle_modificacion === 'aumentado'
    );
      
    if (puntosConProblemaDePlaca.length === 0) return '';

    const grupos = {};
    puntosConProblemaDePlaca.forEach(pi => {
        const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
        if(sala) {
            if(!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
            grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
        }
    });
    return Object.keys(grupos).sort().map(nombreSala => 
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
  };

  const lineasSuprimidas = agruparPuntosPorPropiedad('estado', 'suprimido');
  const lineasNuevas = agruparPuntosPorPropiedad('estado', 'nuevo');
  const lineasDisminuidas = agruparPuntosPorPropiedad('detalle_modificacion', 'disminuido');
  const lineasAumentadas = agruparPuntosPorPropiedad('detalle_modificacion', 'aumentado');
  const lineasConPlacaInvalida = agruparPuntosConPlacaInvalida();
  
  const getSalaYNumeroDeIncidencia = (incidencia) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(incidencia.punto_inspeccionado_id);
    if (!puntoMaestroId) return null;
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    if (!sala || !puntoMaestro) return null;
    return { nombreSala: sala.nombre, numeroPunto: puntoMaestro.nomenclatura.split('-').pop() };
  };

  const agruparIncidenciasPorSala = (incidencias) => {
    if (incidencias.length === 0) return '';
    const grupos = {};
    incidencias.forEach(inc => {
      const info = getSalaYNumeroDeIncidencia(inc);
      if (info) {
        if (!grupos[info.nombreSala]) grupos[info.nombreSala] = new Set();
        grupos[info.nombreSala].add(info.numeroPunto);
      }
    });
    const nombresDeSalasOrdenados = Object.keys(grupos).sort((a, b) => a.localeCompare(b));
    return nombresDeSalasOrdenados.map(nombreSala => {
      const numerosOrdenados = [...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ');
      return `${nombreSala.toUpperCase()}: ${numerosOrdenados}`;
    }).join('\n');
  };

  const incidenciasVerdeAmbar = incidenciasData.filter(i => i.gravedad === 'verde' || i.gravedad === 'ambar');
  const textoVerdeAmbar = agruparIncidenciasPorSala(incidenciasVerdeAmbar);
  const incidenciasRojo = incidenciasData.filter(i => i.gravedad === 'rojo');
  const textoRojo = agruparIncidenciasPorSala(incidenciasRojo);
  
  const TOP_MARGIN = 50;

  // --- PÁGINA 1 ---
  await drawHeader(pdf, inspectionData, arselLogoUrl);
  let currentY = TOP_MARGIN;
  
  pdf.setFont('helvetica', 'bold');
  const titulo = `INFORME VISITA INSPECCIÓN DEL SISTEMA DE ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES DEL CENTRO ${inspectionData.centros.nombre.toUpperCase()}`;
  pdf.setFontSize(FONT_SIZES.title);
  const tituloLines = pdf.splitTextToSize(titulo, CONTENT_WIDTH);
  pdf.text(tituloLines, DOC_WIDTH / 2, currentY, { align: 'center' });
  currentY += (tituloLines.length * 9) + 15;

  pdf.setFontSize(FONT_SIZES.h1).setFont('helvetica', 'bold'); 
  pdf.text('1. OBJETO', MARGIN, currentY); 
  currentY += 8; 
  pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); 
  pdf.text(`Con motivo de la visita programada para la inspección del sistema de almacenaje para cargas paletizadas y manuales del ${inspectionData.centros.nombre}, se redacta el presente informe que recoge de forma somera el resultado de la visita.`, MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 40;

  pdf.setFontSize(FONT_SIZES.h1).setFont('helvetica', 'bold'); 
  pdf.text('2. ANTECEDENTES', MARGIN, currentY); 
  currentY += 8; 
  pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); 
  pdf.text('Para realizar la inspección del sistema de almacenaje de cargas paletizadas y manuales ubicadas en las reservas se toma como base la memoria técnica previa de evaluación de dichos sistemas facilitada al centro para la realización de las correcciones oportunas. Este documento establece los parámetros dimensionales y de carga, así como los elementos y medidas de seguridad que deben contemplar los sistemas de almacenaje para garantizar su estabilidad y uso seguro.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 40; 
  pdf.text('La inspección consiste en la revisión visual del sistema llevada a cabo por un técnico cualificado, con la comprobación de los puntos recogidos en el checklist previsto para tal fin en la memoria de evaluación previa, con el consiguiente registro escrito de los resultados obtenidos.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  
  pdf.addPage();
  await drawHeader(pdf, inspectionData, arselLogoUrl);
  currentY = TOP_MARGIN;

  // --- PÁGINA 2 Y SIGUIENTES ---
  const PAGE_HEIGHT = pdf.internal.pageSize.getHeight();
  const FOOTER_MARGIN = 30;

  const checkPageBreak = async (heightNeeded) => {
    if (currentY + heightNeeded > PAGE_HEIGHT - FOOTER_MARGIN) {
      pdf.addPage();
      await drawHeader(pdf, inspectionData, arselLogoUrl);
      currentY = TOP_MARGIN;
    }
  };

  const addSection = async (title, content) => {
    content = content || 'Ninguna';

    const titleHeight = 8;
    const contentHeight = content.split('\n').length * 5 + 5;
    await checkPageBreak(titleHeight + contentHeight);

    pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body).text(title, MARGIN, currentY);
    currentY += titleHeight;
    pdf.setFont('helvetica', 'bold').text(content, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += contentHeight;
  };

  pdf.setFontSize(FONT_SIZES.h1).setFont('helvetica', 'bold'); 
  pdf.text('3. RESULTADO DE LA VISITA', MARGIN, currentY); 
  currentY += 8; 
  pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); 
  pdf.text('En rasgos generales los sistemas de almacenaje cumplen los parámetros establecidos en la memoria técnica de evaluación.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 15; 
  
  if (textoVerdeAmbar) {
    const introText = 'Se han detectado anomalías de riesgo verde y/o ámbar, tal y como se refleja en los listados de inspección elaborados durante la visita en:';
    pdf.text(introText, MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 });
    const introTextHeight = pdf.splitTextToSize(introText, CONTENT_WIDTH).length * 5 * 1.5;
    currentY += introTextHeight;
  }

  if (textoVerdeAmbar) {
    pdf.setFont('helvetica', 'bold').setFontSize(FONT_SIZES.body);
    pdf.text(textoVerdeAmbar, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (textoVerdeAmbar.split('\n').length * 5) + 5;
  }
  
  pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body);
  
  const textoPostVerdeAmbar = 'Estas anomalías, si bien no comprometen de forma inmediata la estabilidad ni seguridad del sistema, deben subsanarse lo antes posible para evitar que puedan derivar en un riesgo mayor. (Se adjuntan listados de chequeo y reportaje fotográfico de la visita).';
  const newMargin = MARGIN + 5;
  const newContentWidth = DOC_WIDTH - (newMargin * 2);
  await checkPageBreak((pdf.splitTextToSize(textoPostVerdeAmbar, newContentWidth).length * 5 * 1.5) + 5);
  pdf.text(textoPostVerdeAmbar, newMargin, currentY, { maxWidth: newContentWidth, align: 'justify', lineHeightFactor: 1.5 });
  currentY += (pdf.splitTextToSize(textoPostVerdeAmbar, newContentWidth).length * 5 * 1.5) + 15;

  if(textoRojo) {
    currentY += 5;
    const textoPreRojo = 'Puntualmente, se han detectado anomalías de riesgo rojo en:';
    await checkPageBreak(8 + textoRojo.split('\n').length * 5 + 5);
    pdf.text(textoPreRojo, MARGIN, currentY, { align: 'justify' }); 
    currentY += 8;
    pdf.setFont('helvetica', 'bold');
    pdf.text(textoRojo, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (textoRojo.split('\n').length * 5) + 5;
    
    pdf.setFont('helvetica', 'normal');
    const textoRiesgoRojo = 'Estas anomalías deben subsanarse inmediatamente para evitar el colapso de las estanterías en el caso de una combinación de cargas desfavorables, procediendo a la descarga de la mercancía de los módulos afectados y señalizando la zona para que no se almacene producto en los mismos hasta que puedan ser sustituidos los elementos dañados. La sustitución se llevará a cabo con nuevo material que se tiene que solicitar si no cuenta con repuesto en el centro.';
    await checkPageBreak((pdf.splitTextToSize(textoRiesgoRojo, CONTENT_WIDTH).length * 5 * 1.5) + 15);
    pdf.text(textoRiesgoRojo, MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 });
    currentY += (pdf.splitTextToSize(textoRiesgoRojo, CONTENT_WIDTH).length * 5 * 1.5) + 15;
  }

  await addSection('Alineaciones sin ficha de características o con ficha no válida:', lineasConPlacaInvalida);
  await addSection('Alineaciones con módulos DISMINUIDOS desde la inspección anterior:', lineasDisminuidas);
  await addSection('Alineaciones con módulos AUMENTADOS desde la inspección anterior:', lineasAumentadas);
  await addSection('Alineaciones desmontadas desde la inspección anterior:', lineasSuprimidas);
  await addSection('Alineaciones nuevas montadas desde la inspección anterior:', lineasNuevas);

  await checkPageBreak(80);
  pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body);
  pdf.text('Para cerrar el proceso de inspección completo, el centro subsanará las deficiencias de menor grado detectadas en los próximos días, comunicando la resolución de las mismas mediante correo electrónico a ARSEL Ingeniería y al Técnico de Prevención Regional.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 40;
  pdf.text('Informe realizado por:', MARGIN, currentY);
  
  // --- INICIO DE LA CORRECCIÓN ---
  currentY += 4; // 1. Reducir el espacio vertical
  const signatureLogoUrl = await getArselLogoUrl('signature_logo');
  const finalLogoUrl = signatureLogoUrl || arselLogoUrl;
  const arselLogoBase64 = await loadImageAsBase64(finalLogoUrl);
  if (arselLogoBase64) {
      pdf.addImage(arselLogoBase64, 'PNG', MARGIN, currentY, 55, 25, undefined, 'MEDIUM'); // 2. Aumentar el tamaño de la imagen
      currentY += 28; // Ajustar el incremento de Y para que coincida con el nuevo tamaño
  }
  // --- FIN DE LA CORRECCIÓN ---

  pdf.setFont('helvetica', 'bold').text('ARSEL INGENIERIA', MARGIN, currentY);
  currentY += 5;
  pdf.setFont('helvetica', 'normal').text(`Valencia, ${fecha}`, MARGIN, currentY);
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-text.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-data.js ---
// src/utils/pdf/pdf-data.js

import { supabase } from '../../supabase';
import { loadImageAsBase64 } from './pdf-helpers';

export async function fetchReportData(inspeccionId, options = {}) {
  const { optimizePlan = true } = options;
  console.log(`[fetchReportData] Iniciando búsqueda de datos para la inspección ID: ${inspeccionId}`);

  try {
    // ÚNICA LLAMADA A LA BASE DE DATOS
    const { data: reportJson, error } = await supabase.rpc('get_report_data', {
      inspeccion_id_param: inspeccionId
    });

    if (error) {
      console.error('[fetchReportData] ¡ERROR CRÍTICO al llamar a la función RPC!', error);
      throw new Error(`Error en la función de base de datos: ${error.message}`);
    }

    const reportData = reportJson; // El JSON ya viene con la estructura correcta

    const planoUrl = reportData.inspectionData.versiones_plano?.url_imagen_plano;
    const planoBase64 = planoUrl ? await loadImageAsBase64(planoUrl, { optimize: optimizePlan }) : null;

    // Calcular los contadores de incidencias (esto es rápido y se puede quedar en el cliente)
    const incidenceCounts = new Map();
    (reportData.puntosInspeccionadosData || []).forEach(pi => {
        incidenceCounts.set(pi.id, { verde: 0, ambar: 0, rojo: 0 });
    });
    (reportData.incidenciasData || []).forEach(inc => {
        const counts = incidenceCounts.get(inc.punto_inspeccionado_id);
        if (counts && counts[inc.gravedad] !== undefined) {
            counts[inc.gravedad]++;
        }
    });
    
    const result = {
      ...reportData,
      planoBase64,
      incidenceCounts,
    };
    
    console.log('[fetchReportData] Búsqueda de datos con RPC completada con éxito.');
    return result;

  } catch (error) {
    console.error('[fetchReportData] La función ha fallado con una excepción:', error);
    return null;
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-data.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-gestion.js ---
// src/utils/pdf/pdf-module-gestion.js

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

// Helper para obtener el texto del estado
const getEstadoText = (estado) => {
  switch (estado) {
    case 'en_progreso': return 'En Progreso';
    case 'finalizada': return 'Pend. Envío';
    case 'pendiente_subsanacion': return 'Pend. Cierre';
    case 'cerrada': return 'Cerrada';
    default: return 'Sin Inspección';
  }
};

export async function generateGestionReport(resumenData) {
  // ===== PRUEBA IRREFUTABLE: Si ves este mensaje, estás ejecutando el código nuevo =====
  console.log('✅ ✅ ✅ Ejecutando generateGestionReport v2 (SIN LOGO) ✅ ✅ ✅');
  
  try {
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const PAGE_WIDTH = pdf.internal.pageSize.getWidth();
    const MARGIN = 15;

    // --- CABECERA DEL DOCUMENTO (SIN LOGO) ---
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.text('Informe Resumen Anual de Inspecciones', PAGE_WIDTH / 2, 17, { align: 'center' });
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`Fecha de generación: ${new Date().toLocaleDateString('es-ES')}`, PAGE_WIDTH - MARGIN, 25, { align: 'right' });


    // --- TABLA DE DATOS ---
    const head = [
        [
            { content: 'Centro', rowSpan: 2, styles: { halign: 'left', valign: 'middle' } },
            { content: 'Región', rowSpan: 2, styles: { halign: 'left', valign: 'middle' } },
            { content: 'Última Inspección', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Grupo Visita', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Estado Informe', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Cambios Alineaciones', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Faltan Fichas', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Daños', colSpan: 3, styles: { halign: 'center' } },
        ],
        [
            { content: 'V' },
            { content: 'A' },
            { content: 'R' }
        ]
    ];

    const body = resumenData.map(item => [
      item.centro_nombre,
      item.region || '-',
      item.fecha_inspeccion ? new Date(item.fecha_inspeccion + 'T00:00:00').toLocaleDateString('es-ES') : '-',
      item.grupo_visita || '-',
      getEstadoText(item.estado_informe),
      item.cambios_en_alineaciones,
      item.faltan_fichas ? 'SI' : 'NO',
      item.danos_verdes,
      item.danos_ambares,
      item.danos_rojos
    ]);

    autoTable(pdf, {
      head: head,
      body: body,
      startY: 35,
      theme: 'grid',
      margin: { left: MARGIN, right: MARGIN },
      styles: {
        fontSize: 7,
        cellPadding: 1.5,
        valign: 'middle',
        overflow: 'linebreak'
      },
      headStyles: {
        fillColor: [75, 85, 99],
        textColor: 255,
        fontStyle: 'bold',
        halign: 'center',
        fontSize: 8,
        cellWidth: 'wrap'
      },
      alternateRowStyles: {
        fillColor: [243, 244, 246]
      },
      columnStyles: {
        0: { cellWidth: 45, halign: 'left' },
        1: { cellWidth: 28, halign: 'left' },
        2: { cellWidth: 17, halign: 'center' },
        3: { cellWidth: 15, halign: 'center' },
        4: { cellWidth: 17, halign: 'center' },
        5: { cellWidth: 17, halign: 'center' },
        6: { cellWidth: 15, halign: 'center' },
        7: { cellWidth: 9, halign: 'center' },
        8: { cellWidth: 9, halign: 'center' },
        9: { cellWidth: 9, halign: 'center' },
      },
      didParseCell: function (data) {
        if (data.row.section === 'head' && data.row.index === 1) {
          if (data.column.index === 0) data.cell.styles.fillColor = [34, 197, 94];
          if (data.column.index === 1) data.cell.styles.fillColor = [245, 158, 11];
          if (data.column.index === 2) data.cell.styles.fillColor = [239, 68, 68];
          data.cell.styles.textColor = 255;
          data.cell.styles.fontStyle = 'bold';
        }

        if (data.row.section === 'body') {
          if (data.column.index === 6 && data.cell.raw === 'SI') {
            data.cell.styles.textColor = [239, 68, 68];
            data.cell.styles.fontStyle = 'bold';
          }
          if (data.column.index === 7 && data.cell.raw > 0) data.cell.styles.fillColor = '#e0f2e9';
          if (data.column.index === 8 && data.cell.raw > 0) data.cell.styles.fillColor = '#fff4e0';
          if (data.column.index === 9 && data.cell.raw > 0) data.cell.styles.fillColor = '#ffe0e0';
        }
      },
      didDrawPage: function (data) {
        const pageCount = pdf.internal.getNumberOfPages();
        pdf.setFontSize(8);
        pdf.setTextColor(100);
        pdf.text(
          `Página ${data.pageNumber} de ${pageCount}`,
          PAGE_WIDTH / 2,
          pdf.internal.pageSize.getHeight() - 10,
          { align: 'center' }
        );
      }
    });

    const fileName = `Informe_Gestion_Anual_${new Date().toISOString().slice(0, 10)}.pdf`;
    pdf.save(fileName);

  } catch (error) {
    console.error("Error generando el PDF de gestión:", error);
    alert("Hubo un error al generar el PDF. Revisa la consola para más detalles.");
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-gestion.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-photos.js ---
// src/utils/pdf/pdf-module-photos.js

import { checklistItems } from '../checklist';
import { drawHeader, loadImageAsBase64, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';
import { getArselLogoUrl } from './pdf-helpers';
import { supabase } from '../../supabase';

// --- ANEXO DE FOTOS INICIAL (OPTIMIZADO) ---
export async function buildInitialPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;

  const incidenciasConFoto = incidenciasData.filter(inc =>
    inc.url_foto_antes && inc.item_checklist !== 2
  );
  if (incidenciasConFoto.length === 0) return;

  // Fetch custom fields and logo
  const [customFieldsRes, arselLogoUrl] = await Promise.all([
    supabase.from('checklist_custom_fields').select('*'),
    getArselLogoUrl()
  ]);
  const customFieldsMap = new Map(customFieldsRes.data.map(f => [f.id, f]));

  const puntoMaestroASalaMap = new Map(puntosMaestrosData.map(pm => [pm.id, salasData.find(s => s.id === pm.sala_id)]));
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const getSortInfoForIncidencia = (inc) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(inc.punto_inspeccionado_id);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    return {
      salaNombre: sala ? sala.nombre : 'ZZZ',
      puntoNumero: puntoMaestro ? parseInt(puntoMaestro.nomenclatura.split('-').pop() || 0) : 9999
    };
  };

  incidenciasConFoto.sort((a, b) => {
    const infoA = getSortInfoForIncidencia(a);
    const infoB = getSortInfoForIncidencia(b);
    const comparacionSala = infoA.salaNombre.localeCompare(infoB.salaNombre);
    if (comparacionSala !== 0) return comparacionSala;
    return infoA.puntoNumero - infoB.puntoNumero;
  });

  pdf.addPage();
  await drawHeader(pdf, inspectionData, arselLogoUrl);
  
  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont('helvetica', 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  pdf.text('REPORTAJE FOTOGRÁFICO', DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont('helvetica', 'normal');

  for (const incidencia of incidenciasConFoto) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;

    pdf.addPage();
    await drawHeader(pdf, inspectionData, arselLogoUrl);
    
    let currentY = 45;
    pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'normal');
    pdf.text(`Alineación: ${puntoMaestro.nomenclatura}`, MARGIN, currentY);
    currentY += 8;

    const checklistItem = checklistItems.find(item => item.id === incidencia.item_checklist);
    if (checklistItem) {
      pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'italic');
      pdf.setTextColor(100);
      const itemText = `Incidencia: ${checklistItem.id}. ${checklistItem.text}`;
      const splitText = pdf.splitTextToSize(itemText, DOC_WIDTH - (MARGIN * 2));
      pdf.text(splitText, MARGIN, currentY);
      currentY += (splitText.length * 5) + 5;
      pdf.setTextColor(0);
      pdf.setFont('helvetica', 'normal');
    }

    const photoWidth = DOC_WIDTH - (MARGIN * 2);
    const photoHeight = photoWidth * (100 / 180);

    const fotoAntesBase64 = await loadImageAsBase64(incidencia.url_foto_antes);
    if(fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN, currentY, photoWidth, photoHeight, undefined, 'MEDIUM');
    }

    let obsBlockY = currentY + photoHeight + 10;
    pdf.setFontSize(FONT_SIZES.body);
    let obsText = '';
    if (incidencia.custom_fields) {
      const customs = Object.entries(incidencia.custom_fields).map(([fieldId, value]) => {
        const field = customFieldsMap.get(parseInt(fieldId));
        return field ? `${field.field_name}: ${value}` : '';
      }).filter(s => s).join(' / ');
      if (customs) obsText = customs;
    }
    const obsNotes = incidencia.observaciones || '';
    if (obsNotes) obsText = obsText ? `${obsText} / ${obsNotes}` : obsNotes;
    
    // ===== CAMBIO 1: Ajustamos cómo se dibuja el bloque de observaciones =====
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight + 2); // +2 for padding

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont('helvetica', 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 12); // Aumentamos el espacio vertical
  }
}


// --- ANEXO DE FOTOS DE SUBSANACIÓN (OPTIMIZADO) ---
export async function buildRemediationPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData } = reportData;

  const incidenciasCorregidas = incidenciasData.filter(inc => inc.url_foto_antes && inc.url_foto_despues);
  if (incidenciasCorregidas.length === 0) return;

  // Fetch custom fields and logo
  const [customFieldsRes, arselLogoUrl] = await Promise.all([
    supabase.from('checklist_custom_fields').select('*'),
    getArselLogoUrl()
  ]);
  const customFieldsMap = new Map(customFieldsRes.data.map(f => [f.id, f]));

  pdf.addPage();
  await drawHeader(pdf, inspectionData, arselLogoUrl);

  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont('helvetica', 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  const remediationTitleLines = pdf.splitTextToSize('INFORME FOTOGRÁFICO DE CIERRE', 180);
  pdf.text(remediationTitleLines, DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont('helvetica', 'normal');
  
  for (const incidencia of incidenciasCorregidas) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;
    
    pdf.addPage();
    await drawHeader(pdf, inspectionData, arselLogoUrl);
    pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'normal').text(`Corrección de Incidencia: ${puntoMaestro.nomenclatura}`, MARGIN, 45);

    const [fotoAntesBase64, fotoDespuesBase64] = await Promise.all([
      loadImageAsBase64(incidencia.url_foto_antes, { maxWidth: 600, maxHeight: 600 }),
      loadImageAsBase64(incidencia.url_foto_despues, { maxWidth: 600, maxHeight: 600 })
    ]);
    
    const photoBoxY = 65;
    const photoBoxSize = (DOC_WIDTH - (MARGIN * 2) - 10) / 2;
    const photoPadding = 2;

    pdf.text('ANTES', MARGIN + (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(MARGIN, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'MEDIUM');
    }
    
    const secondPhotoX = MARGIN + photoBoxSize + 10;
    pdf.text('DESPUÉS', secondPhotoX + (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(secondPhotoX, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoDespuesBase64) {
      pdf.addImage(fotoDespuesBase64, 'JPEG', secondPhotoX + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'MEDIUM');
    }
    
    let obsBlockY = 160;
    pdf.setFontSize(FONT_SIZES.body);
    let obsText = '';
    if (incidencia.custom_fields) {
      const customs = Object.entries(incidencia.custom_fields).map(([fieldId, value]) => {
        const field = customFieldsMap.get(parseInt(fieldId));
        return field ? `${field.field_name}: ${value}` : '';
      }).filter(s => s).join(' / ');
      if (customs) obsText = customs;
    }
    const obsNotes = incidencia.observaciones || '';
    if (obsNotes) obsText = obsText ? `${obsText} / ${obsNotes}` : obsNotes;

    // ===== CAMBIO 1: Ajustamos cómo se dibuja el bloque de observaciones =====
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight + 2); // +2 for padding

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont('helvetica', 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 12); // Aumentamos el espacio vertical
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-photos.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/index.js ---
import jsPDF from 'jspdf';
import { fetchReportData } from './pdf-data';
import { buildTextPages } from './pdf-module-text';
import { buildInitialPhotoAnnex, buildRemediationPhotoAnnex } from './pdf-module-photos';
import { buildChecklistAnnex } from './pdf-module-checklist';
import { buildSummaryAnnex } from './pdf-module-summary';
// --- INICIO DE LA CORRECCIÓN: Importamos getArselLogoUrl ---
import { drawHeader, FONT_SIZES, DOC_WIDTH, getArselLogoUrl } from './pdf-helpers';

function sanitizeFileName(name) {
  let sanitized = name.replace(/\s+/g, '_');
  sanitized = sanitized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  sanitized = sanitized.replace(/[^a-zA-Z0-9_.-]/g, '');
  return sanitized;
}

export async function generateTextReport(inspeccionId, reportType = 'initial', outputType = 'download') {
  try {
    console.log(`Iniciando generación de Informe de Texto (output: ${outputType})...`);
    const reportData = await fetchReportData(inspeccionId, { optimizePlan: true }); 
    if (!reportData) throw new Error("No se pudieron cargar los datos para el informe.");
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    console.log("Construyendo páginas de texto...");
    await buildTextPages(pdf, reportData);
    
    if (reportType === 'initial') {
      console.log("Construyendo anexo de fotos inicial...");
      await buildInitialPhotoAnnex(pdf, reportData);
    } else if (reportType === 'remediation') {
      console.log("Construyendo anexo de fotos de subsanación...");
      await buildRemediationPhotoAnnex(pdf, reportData);
    }
    
    console.log("Construyendo anexo de checklist...");
    await buildChecklistAnnex(pdf, reportData);

    // --- INICIO DE LA CORRECCIÓN: Obtenemos y pasamos el logo de Arsel a la cabecera ---
    console.log("Añadiendo página de Anexo de Planos...");
    const arselLogoUrl = await getArselLogoUrl(); // Obtenemos la URL del logo
    pdf.addPage();
    await drawHeader(pdf, reportData.inspectionData, arselLogoUrl); // Pasamos la URL a la función
    pdf.setFontSize(FONT_SIZES.annexTitle);
    pdf.setFont('helvetica', 'bold');
    pdf.text('ANEXO 03:', DOC_WIDTH / 2, 145, { align: 'center' });
    pdf.text('PLANOS', DOC_WIDTH / 2, 155, { align: 'center' });
    // --- FIN DE LA CORRECCIÓN ---
    
    const { inspectionData } = reportData;
    const reportTypeName = reportType === 'initial' ? 'Informe_Inicial' : 'Informe_Cierre';
    
    const rawFileName = `${reportTypeName}_${inspectionData.centros.nombre}_${inspectionData.fecha_inspeccion}.pdf`;
    const fileName = sanitizeFileName(rawFileName);

    if (outputType === 'blob') {
      console.log('Devolviendo PDF como Blob.');
      return { blob: pdf.output('blob'), fileName: fileName };
    } else {
      console.log(`Guardando PDF como: ${fileName}`);
      pdf.save(fileName);
      return { blob: null, fileName: fileName };
    }

  } catch (err) {
    console.error("Error generando el Informe de Texto:", err);
    alert(`Hubo un error al generar el informe. Revisa la consola: ${err.message}`);
    return null;
  }
}


export async function generatePlanPdf(inspeccionId, finalLabels, originalDimensions) {
  try {
    console.log("Iniciando generación de PDF del Plano en formato A3...");
    const reportData = await fetchReportData(inspeccionId, { optimizePlan: false }); 
    
    if (!reportData.planoBase64) {
        throw new Error("No se pudo cargar la imagen del plano para esta inspección.");
    }

    const pdf = new jsPDF('l', 'mm', 'a3');
    
    console.log("Construyendo anexo de resumen visual con posiciones ajustadas...");
    await buildSummaryAnnex(pdf, reportData, finalLabels, originalDimensions);
    
    const { inspectionData } = reportData;
    
    const rawFileName = `Plano_Incidencias_${inspectionData.centros.nombre}_${inspectionData.fecha_inspeccion}.pdf`;
    const fileName = sanitizeFileName(rawFileName);

    console.log(`Guardando PDF como: ${fileName}`);
    pdf.save(fileName);

  } catch (err) {
    console.error("Error generando el PDF del Plano:", err);
    alert(`Hubo un error al generar el plano. Revisa la consola: ${err.message}`);
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/index.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-helpers.js ---
// src/utils/pdf/pdf-helpers.js

// --- CONSTANTES ---
export const MARGIN = 25;
export const DOC_WIDTH = 210;
export const DOC_WIDTH_LANDSCAPE = 297;
export const FONT_SIZES = { annexTitle: 22, title: 16, h1: 14, h2: 12, body: 11, small: 8 };

// --- FUNCIÓN PARA OBTENER LOGO DINÁMICO ---
export async function getArselLogoUrl(assetType = 'header_logo') {
  try {
    const { supabase } = await import('../../supabase');
    const { data: assets } = await supabase.from('company_assets').select('*');
    const assetsMap = new Map((assets || []).map(a => [a.asset_type, a.url]));
    return assetsMap.get(assetType) || null;
  } catch (error) {
    console.error('Error fetching ARSEL logo:', error);
    return null;
  }
}

// --- FUNCIÓN DE AYUDA PARA CARGAR IMÁGENES (CON CONTROL DE OPTIMIZACIÓN) ---
export async function loadImageAsBase64(url, options = {}) {
  // Opciones por defecto: optimizar siempre con un máximo de 1024px
  const { optimize = true, maxWidth = 1024, maxHeight = 1024 } = options;

  if (!url || !url.startsWith('http')) return null;
  try {
    const response = await fetch(url);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.startsWith("image/")) {
      console.warn(`La URL no devolvió una imagen: ${url}`);
      return null;
    }
    const blob = await response.blob();

    return new Promise((resolve, reject) => {
      if (!optimize) {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
        return;
      }

      const img = new Image();
      const objectUrl = URL.createObjectURL(blob);
      img.src = objectUrl;
      
      img.onload = () => {
        let { width, height } = img;
        
        if (width <= maxWidth && height <= maxHeight) {
            const reader = new FileReader();
            reader.onloadend = () => {
                URL.revokeObjectURL(objectUrl);
                resolve(reader.result);
            };
            reader.onerror = (err) => {
                URL.revokeObjectURL(objectUrl);
                reject(err);
            };
            reader.readAsDataURL(blob);
            return;
        }

        const ratio = Math.min(maxWidth / width, maxHeight / height);
        const newWidth = Math.floor(width * ratio);
        const newHeight = Math.floor(height * ratio);
        
        const canvas = document.createElement('canvas');
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, newWidth, newHeight);
        
        const dataUrl = canvas.toDataURL('image/jpeg', 0.80);
        
        URL.revokeObjectURL(objectUrl);
        resolve(dataUrl);
      };

      img.onerror = (err) => {
        URL.revokeObjectURL(objectUrl);
        reject(err);
      };
    });

  } catch (error) {
    console.error("Error cargando y optimizando imagen para PDF:", url, error);
    return null;
  }
}

// --- CABECERA PRINCIPAL (REUTILIZABLE EN TODO EL PDF) ---
export async function drawHeader(pdf, inspectionData, arselLogoUrl = null) {
  const [clientLogoBase64, arselLogoBase64] = await Promise.all([
    loadImageAsBase64(inspectionData.centros.url_logo_cliente, { optimize: false }),
    arselLogoUrl ? loadImageAsBase64(arselLogoUrl, { optimize: false }) : Promise.resolve(null)
  ]);

  const pageSize = pdf.internal.pageSize;
  const pageWidth = pageSize.getWidth();
  
  const HEADER_MARGIN = 15;
  const headerY = 10;
  const headerHeight = 22;
  const contentWidth = pageWidth - (HEADER_MARGIN * 2); 
  
  const cell1Width = 38;
  const cell3Width = 32;
  const cell2Width = contentWidth - cell1Width - cell3Width;
  const textCenter = HEADER_MARGIN + cell1Width + (cell2Width / 2);

  // Dibujar el contorno y las líneas
  pdf.rect(HEADER_MARGIN, headerY, contentWidth, headerHeight);
  pdf.line(HEADER_MARGIN, headerY + 8, pageWidth - HEADER_MARGIN, headerY + 8);
  pdf.line(HEADER_MARGIN + cell1Width, headerY + 8, HEADER_MARGIN + cell1Width, headerY + headerHeight);
  pdf.line(HEADER_MARGIN + cell1Width + cell2Width, headerY + 8, HEADER_MARGIN + cell1Width + cell2Width, headerY + headerHeight);

  // Título del Centro
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(FONT_SIZES.h2);
  pdf.text(`${inspectionData.centros.nombre.toUpperCase()}`, pageWidth / 2, headerY + 5.5, { align: 'center' });

  const logoY = headerY + 8 + ((headerHeight - 8) - 9) / 2;
  
  // Logo Cliente (Celda 1)
  if (clientLogoBase64) {
    pdf.addImage(clientLogoBase64, 'JPEG', HEADER_MARGIN + 2, logoY, cell1Width - 4, 9, undefined, 'MEDIUM');
  }

  // Subtítulo del Informe (Celda 2)
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(10); 

  const titleLines = [
    "INFORME VISITA INSPECCIÓN DEL SISTEMA DE",
    "ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES"
  ];
  
  const cellBottomY = headerY + headerHeight;
  const cellTopY = headerY + 8;
  const cellMiddleY = cellTopY + (cellBottomY - cellTopY) / 2;
  
  const lineSpacing = 4.5; 
  
  const startY = cellMiddleY - (lineSpacing / 2);

  pdf.text(titleLines[0], textCenter, startY, { align: 'center', baseline: 'middle' });
  pdf.text(titleLines[1], textCenter, startY + lineSpacing, { align: 'center', baseline: 'middle' });
  
  // Logo Arsel (Celda 3)
  if (arselLogoBase64) {
    pdf.addImage(arselLogoBase64, 'JPEG', HEADER_MARGIN + cell1Width + cell2Width + 2, logoY, cell3Width - 4, 9, undefined, 'MEDIUM');
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-helpers.js ---

--- INICIO DEL ARCHIVO: src/utils/excel/excel-module-gestion.js ---
// src/utils/excel/excel-module-gestion.js

import * as XLSX from 'xlsx-js-style';

const getEstadoInfo = (estado) => {
  switch (estado) {
    case 'en_progreso': return { text: 'En Progreso', style: { font: { color: { rgb: "2563EB" } } } }; // Blue
    case 'finalizada': return { text: 'Pend. Envío', style: { font: { color: { rgb: "D97706" } } } }; // Amber
    case 'pendiente_subsanacion': return { text: 'Pend. Cierre', style: { font: { color: { rgb: "F59E0B" } } } }; // Yellow
    case 'cerrada': return { text: 'Cerrada', style: { font: { color: { rgb: "10B981" } } } }; // Green
    default: return { text: 'Sin Inspección', style: { font: { color: { rgb: "6B7280" } } } }; // Gray
  }
};

export async function generateGestionExcel(resumenData) {
  try {
    // --- ESTILOS PROFESIONALES ---
    const headerStyle = { font: { sz: 12, bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "2563EB" } }, alignment: { vertical: "center", horizontal: "center" } };
    const titleStyle = { font: { sz: 18, bold: true }, alignment: { horizontal: "center" } };
    const baseCellStyle = { font: { sz: 11, name: 'Calibri' }, alignment: { vertical: "center" } };
    const centerAlignStyle = { alignment: { horizontal: "center", vertical: "center" } };
    const bandedRowStyle = { fill: { fgColor: { rgb: "F3F4F6" } } };
    const redTextStyle = { font: { bold: true, color: { rgb: "EF4444" } } };

    // --- PREPARACIÓN DE DATOS ---
    const headers = ["Centro", "Región", "Última Inspección", "Grupo Visita", "Estado Informe", "Cambios Alineaciones", "Faltan Fichas", "Daños (Verdes)", "Daños (Ámbar)", "Daños (Rojos)"];
    
    const dataRows = resumenData.map(item => ([
      item.centro_nombre,
      item.region || '-',
      item.fecha_inspeccion ? new Date(item.fecha_inspeccion + 'T00:00:00') : '-',
      item.grupo_visita || '-',
      getEstadoInfo(item.estado_informe).text,
      item.cambios_en_alineaciones,
      item.faltan_fichas ? 'SI' : 'NO',
      item.danos_verdes,
      item.danos_ambares,
      item.danos_rojos
    ]));
    
    const finalData = [
      ['Informe de Gestión Anual'],
      [`Fecha de Generación: ${new Date().toLocaleDateString('es-ES')}`],
      [],
      headers,
      ...dataRows
    ];

    // --- CREACIÓN Y ESTILIZADO DE LA HOJA ---
    const worksheet = XLSX.utils.aoa_to_sheet(finalData);

    // Unir título
    worksheet['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } }];
    worksheet['A1'].s = titleStyle;

    // Aplicar estilos a la cabecera
    for (let C = 0; C < headers.length; C++) {
      const cellAddress = XLSX.utils.encode_cell({ r: 3, c: C });
      worksheet[cellAddress].s = headerStyle;
    }

    // Aplicar estilos a las filas de datos
    for (let R = 4; R < finalData.length; R++) {
      const item = resumenData[R - 4]; // -4 to align with dataRows index
      const isBanded = (R - 4) % 2 === 1;

      for (let C = 0; C < headers.length; C++) {
        const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
        if (!worksheet[cellAddress]) continue;

        let cellStyle = { ...baseCellStyle };
        if (isBanded) cellStyle.fill = bandedRowStyle.fill;
        
        // Estilos y formatos específicos
        switch(C) {
          case 2: // Última Inspección (Fecha)
            if (worksheet[cellAddress].v instanceof Date) {
              worksheet[cellAddress].t = 'd';
              worksheet[cellAddress].z = 'dd/mm/yyyy';
            }
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 4: // Estado Informe
            cellStyle.font = { ...cellStyle.font, ...getEstadoInfo(item.estado_informe).style.font, bold: true };
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 6: // Faltan Fichas
            if (worksheet[cellAddress].v === 'SI') cellStyle.font = { ...cellStyle.font, ...redTextStyle.font };
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 7: // Daños Verdes
            if(worksheet[cellAddress].v > 0) cellStyle.fill = { fgColor: { rgb: "E0F2F1" } }; // Light green
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 8: // Daños Ámbar
            if(worksheet[cellAddress].v > 0) cellStyle.fill = { fgColor: { rgb: "FFFBEB" } }; // Light amber
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 9: // Daños Rojos
            if(worksheet[cellAddress].v > 0) cellStyle.fill = { fgColor: { rgb: "FEF2F2" } }; // Light red
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 3: case 5: // Grupo Visita, Cambios Alineaciones
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
        }
        worksheet[cellAddress].s = cellStyle;
      }
    }
    
    // Ancho de columnas
    worksheet['!cols'] = [ { wch: 45 }, { wch: 25 }, { wch: 18 }, { wch: 15 }, { wch: 18 }, { wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 } ];
    // Auto-filtro
    worksheet['!autofilter'] = { ref: `A4:${XLSX.utils.encode_col(headers.length - 1)}4` };
    // Congelar panel
    worksheet['!view'] = { state: 'frozen', ySplit: 4 };

    // --- DESCARGA ---
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Resumen de Gestión');
    const fileName = `Informe_Gestion_Anual_${new Date().toISOString().slice(0, 10)}.xlsx`;
    XLSX.writeFile(workbook, fileName);

  } catch (error) {
    console.error("Error generando el archivo XLSX de gestión:", error);
    alert("Hubo un error al generar el archivo Excel. Revisa la consola para más detalles.");
  }
}
--- FIN DEL ARCHIVO: src/utils/excel/excel-module-gestion.js ---

--- INICIO DEL ARCHIVO: src/components/PointList.vue ---
<!-- src/components/PointList.vue -->
<script setup>
import { ref } from 'vue';
import { EyeSlashIcon, ArrowUturnLeftIcon, TrashIcon, ChevronDownIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  groupedPoints: Array,
  canEdit: Boolean,
  allIncidencias: {
    type: Array,
    default: () => []
  }
});

const emit = defineEmits(['select-point', 'update-state', 'delete-new-point']);

const openSalaId = ref(null);

const toggleSala = (salaId) => {
  openSalaId.value = openSalaId.value === salaId ? null : salaId;
};

function handleUpdateState(punto, newState) {
  emit('update-state', punto, newState);
}

// Calculate incident counts for a specific point
function getIncidentCountsForPoint(puntoId) {
  const incidents = props.allIncidencias.filter(inc => inc.punto_inspeccionado_id === puntoId);
  return {
    verde: incidents.filter(inc => inc.gravedad === 'verde').length,
    ambar: incidents.filter(inc => inc.gravedad === 'ambar').length,
    rojo: incidents.filter(inc => inc.gravedad === 'rojo').length,
    total: incidents.length
  };
}
</script>

<template>
  <div class="space-y-2">
    <div v-for="grupo in groupedPoints" :key="grupo.id">
      <div class="w-full flex justify-between items-center p-3 rounded-lg" :class="openSalaId === grupo.id ? 'bg-blue-50' : 'hover:bg-slate-50'">
        <button @click="toggleSala(grupo.id)" class="flex-1 flex items-center text-left gap-2">
          <h3 class="font-bold text-slate-700">{{ grupo.nombre }}</h3>
          <span v-if="grupo.isNew" class="text-xs font-bold text-orange-600 bg-orange-100 px-2 py-0.5 rounded-full">NUEVA</span>
          <ChevronDownIcon class="h-5 w-5 text-slate-400 transition-transform" :class="{'rotate-180': openSalaId === grupo.id}" />
        </button>
        <slot name="sala-actions" :sala="grupo"></slot>
      </div>

      <ul v-if="openSalaId === grupo.id" class="space-y-1 pl-4 border-l-2 ml-3">
        <li v-for="punto in grupo.puntos" :key="punto.id">
          <div :class="['p-2 rounded-lg flex items-center justify-between group', { 'bg-slate-100': punto.estado === 'suprimido' }]">
            <!-- ===== CORRECCIÓN: El div entero ahora emite el evento para abrir el modal ===== -->
            <div @click="$emit('select-point', punto)" class="flex-1 flex items-center cursor-pointer">
              <span class="w-3 h-3 rounded-full flex-shrink-0" :style="{ backgroundColor: punto.color }"></span>

              <span
                :class="['font-semibold ml-3', { 'line-through text-slate-500': punto.estado === 'suprimido', 'text-slate-700': punto.estado !== 'suprimido' }]"
              >
                {{ punto.nomenclatura }}
              </span>

              <!-- Incident indicators (semaphore badges) -->
              <div v-if="getIncidentCountsForPoint(punto.id).total > 0" class="flex items-center gap-1 ml-2">
                <!-- Green dot + count -->
                <div v-if="getIncidentCountsForPoint(punto.id).verde > 0" class="flex items-center gap-0.5">
                  <span class="h-1.5 w-1.5 rounded-full bg-green-500"></span>
                  <span class="text-[10px] font-semibold text-slate-600">{{ getIncidentCountsForPoint(punto.id).verde }}</span>
                </div>
                <!-- Amber dot + count -->
                <div v-if="getIncidentCountsForPoint(punto.id).ambar > 0" class="flex items-center gap-0.5">
                  <span class="h-1.5 w-1.5 rounded-full bg-amber-500"></span>
                  <span class="text-[10px] font-semibold text-slate-600">{{ getIncidentCountsForPoint(punto.id).ambar }}</span>
                </div>
                <!-- Red dot + count -->
                <div v-if="getIncidentCountsForPoint(punto.id).rojo > 0" class="flex items-center gap-0.5">
                  <span class="h-1.5 w-1.5 rounded-full bg-red-500"></span>
                  <span class="text-[10px] font-semibold text-slate-600">{{ getIncidentCountsForPoint(punto.id).rojo }}</span>
                </div>
              </div>

              <span v-if="punto.estado === 'nuevo'" class="ml-2 text-xs font-bold text-green-600 bg-green-100 px-2 py-0.5 rounded-full">NUEVO</span>
            </div>

            <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
              <button v-if="punto.estado === 'nuevo'" @click.stop="$emit('delete-new-point', punto)" class="p-1 text-slate-400 hover:text-red-500" title="Borrar punto nuevo">
                <TrashIcon class="h-5 w-5" />
              </button>
              
              <button v-if="punto.estado !== 'suprimido'" @click.stop="handleUpdateState(punto, 'suprimido')" class="p-1 text-slate-400 hover:text-red-500" title="Marcar como suprimido">
                <EyeSlashIcon class="h-5 w-5" />
              </button>
              <button v-else @click.stop="handleUpdateState(punto, 'existente')" class="p-1 text-slate-500 hover:text-blue-500" title="Reactivar punto">
                <ArrowUturnLeftIcon class="h-5 w-5" />
              </button>
            </div>
          </div>
        </li>
      </ul>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/PointList.vue ---

--- INICIO DEL ARCHIVO: src/components/ChecklistModal.vue ---
<!-- src/components/ChecklistModal.vue -->
<script setup>
import { ref, watch, computed, nextTick, inject } from 'vue';
import { supabase } from '../supabase';
// --- INICIO DE LA MODIFICACIÓN: Importamos addToQueue ---
import { addToQueue, getFileLocally } from '../utils/syncQueue';
// --- FIN DE LA MODIFICACIÓN ---
import { checklistItems } from '../utils/checklist';
import { useFileUpload } from '../composables/useFileUpload';
import {
  ArrowUpTrayIcon, CheckCircleIcon, XCircleIcon, PlusCircleIcon, TrashIcon,
  ChevronUpIcon, ChevronDownIcon, PencilIcon, CheckIcon
} from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  punto: Object,
  inspeccionId: Number,
  initialIncidencias: { type: Array, required: true },
  availableCustomFields: { type: Array, required: true },
  existingIdentifiersInSala: { type: Array, default: () => [] }
});

const emit = defineEmits(['close', 'save', 'update-nomenclatura', 'update:incidencias']);
const showNotification = inject('showNotification');

const incidencias = ref([]);
const puntoInspeccionado = computed(() => props.punto);
const customFields = ref([]);
const customValues = ref({});
const collapsedItems = ref(new Set());
const isEditingName = ref(false);
const tempPointIdentifier = ref('');
const nameInputRef = ref(null);
const { isUploading, handleFileUpload: processAndUploadFile } = useFileUpload(props.inspeccionId, props.punto.id);
const dragOverIncidenceId = ref(null);


const hydrateOfflineImages = async () => {
  for (const inc of incidencias.value) {
    if (inc.offlinePhotoKey_antes && !inc.url_foto_antes?.startsWith('blob:')) {
      try {
        const fileData = await getFileLocally(inc.offlinePhotoKey_antes);
        if (fileData) {
          inc.url_foto_antes = URL.createObjectURL(fileData);
        }
      } catch (error) {
        console.error(`No se pudo reconstruir la vista previa para ${inc.offlinePhotoKey_antes}:`, error);
      }
    }
  }
};

watch(() => props.isOpen, async (newVal) => {
  if (newVal) {
    incidencias.value = JSON.parse(JSON.stringify(props.initialIncidencias));
    customFields.value = props.availableCustomFields;
    customValues.value = {};
    incidencias.value.forEach(inc => {
        customValues.value[inc.id] = inc.custom_fields || {};
    });
    
    await hydrateOfflineImages();

    isEditingName.value = false;
    collapsedItems.value.clear();
  }
}, { immediate: true });


const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;

  // --- INICIO DE LA MODIFICACIÓN: Borrado de foto antigua ---
  // Si ya hay una foto online, la marcamos para borrar.
  if (incidencia.url_foto_antes && incidencia.url_foto_antes.startsWith('http')) {
    addToQueue({
      type: 'deleteFile',
      bucket: 'incidencias',
      url: incidencia.url_foto_antes
    });
  }
  // --- FIN DE LA MODIFICACIÓN ---

  const result = await processAndUploadFile(file, incidencia);
  if (result) {
    incidencia.url_foto_antes = result.previewUrl;
    incidencia.offlinePhotoKey_antes = result.offlinePhotoKey;
    emit('update:incidencias', incidencias.value);
  }
};

const onDrop = async (event, incidencia) => {
  event.preventDefault();
  dragOverIncidenceId.value = null;
  const files = event.dataTransfer.files;
  if (files.length === 0) return;
  const file = files[0];
  
  // --- INICIO DE LA MODIFICACIÓN: Borrado de foto antigua ---
  if (incidencia.url_foto_antes && incidencia.url_foto_antes.startsWith('http')) {
    addToQueue({
      type: 'deleteFile',
      bucket: 'incidencias',
      url: incidencia.url_foto_antes
    });
  }
  // --- FIN DE LA MODIFICACIÓN ---

  const result = await processAndUploadFile(file, incidencia);
  if (result) {
    incidencia.url_foto_antes = result.previewUrl;
    incidencia.offlinePhotoKey_antes = result.offlinePhotoKey;
    emit('update:incidencias', incidencias.value);
  }
};

const saveIncidencia = (incidencia) => {
  const { id, ...dataToUpdate } = incidencia;
  dataToUpdate.custom_fields = customValues.value[id] || {};

  // CRITICAL FIX: Update the incidencia object's custom_fields so it persists in the local state
  // This ensures that when the parent component receives the updated incidencias array,
  // the custom_fields are included and will be sent in the sync queue payload
  incidencia.custom_fields = dataToUpdate.custom_fields;

  emit('update:incidencias', incidencias.value);

  const payload = { ...dataToUpdate };
  delete payload.url_foto_antes;
  delete payload.offlinePhotoKey_antes;

  addToQueue({ table: 'incidencias', type: 'update', id: id, payload });
};

const addIncidencia = async (itemId, defaults = {}) => {
  if (!puntoInspeccionado.value) return;
  let defaultSeverity = defaults.gravedad || 'verde';
  if (!navigator.onLine && !defaults.gravedad) {
      defaultSeverity = 'ambar';
  } else if (!defaults.gravedad) {
    const { data: def } = await supabase.from('checklist_defaults').select('default_severity').eq('point_id', itemId).single();
    if (def) defaultSeverity = def.default_severity;
  }
  const tempId = `temp_${Date.now()}`;
  const newIncidencia = {
    id: tempId,
    punto_inspeccionado_id: puntoInspeccionado.value.id,
    inspeccion_id: props.inspeccionId,
    item_checklist: itemId,
    gravedad: defaultSeverity,
    observaciones: defaults.observaciones || null,
    custom_fields: {},
    url_foto_antes: null,
    url_foto_despues: null,
  };
  incidencias.value.push(newIncidencia);
  customValues.value[newIncidencia.id] = {};
  
  emit('update:incidencias', incidencias.value);

  const { id, ...payload } = newIncidencia;
  addToQueue({ table: 'incidencias', type: 'insert', tempId: tempId, payload: payload });
};

// --- INICIO DE LA MODIFICACIÓN: Función de borrado offline ---
const deleteIncidencia = (incidenciaId) => {
  const incidencia = incidencias.value.find(inc => inc.id === incidenciaId);
  if (!incidencia) return;

  // 1. Si hay una foto online, la encolamos para su borrado.
  if (incidencia.url_foto_antes && incidencia.url_foto_antes.startsWith('http')) {
    addToQueue({
      type: 'deleteFile',
      bucket: 'incidencias',
      url: incidencia.url_foto_antes
    });
  }

  // 2. Encolamos el borrado del registro de la incidencia.
  addToQueue({
    type: 'delete',
    table: 'incidencias',
    id: incidenciaId
  });

  // 3. Actualizamos la interfaz de usuario inmediatamente.
  incidencias.value = incidencias.value.filter(inc => inc.id !== incidenciaId);
  delete customValues.value[incidenciaId];
  emit('update:incidencias', incidencias.value);
  showNotification('Incidencia eliminada. Se sincronizará en segundo plano.', 'success');
};
// --- FIN DE LA MODIFICACIÓN ---

const toggleItemStatus = async (itemId) => {
  const itemIncidencias = getIncidenciasForItem(itemId).value;
  if (itemIncidencias.length > 0) {
    if (confirm(`¿Marcar este punto como "Satisfactorio"? Se borrarán las ${itemIncidencias.length} incidencias registradas.`)) {
      // Borramos cada incidencia usando la nueva función offline-first
      for (const incidencia of itemIncidencias) {
        deleteIncidencia(incidencia.id);
      }
    }
  } else {
    await addIncidencia(itemId);
  }
};
const pointPrefix = computed(() => {
  if (!props.punto?.nomenclatura) return '';
  const parts = props.punto.nomenclatura.split('-');
  if (parts.length > 1) {
    parts.pop(); return `${parts.join('-')}-`;
  }
  return '';
});
const startNameEditing = () => {
  isEditingName.value = true;
  const parts = props.punto.nomenclatura.split('-');
  tempPointIdentifier.value = parts.length > 1 ? parts.pop() : props.punto.nomenclatura;
  nextTick(() => nameInputRef.value?.focus());
};

const saveName = () => {
  const newIdentifier = tempPointIdentifier.value.trim();
  const newNomenclature = `${pointPrefix.value}${newIdentifier}`;
  
  if (newIdentifier && newNomenclature !== props.punto.nomenclatura) {
    if (props.existingIdentifiersInSala.includes(newIdentifier)) {
      showNotification(`El identificador "${newIdentifier}" ya existe en esta sala. Por favor, elige otro.`, 'error');
      return;
    }
    
    findPuntoMaestroAndEmitUpdate(newNomenclature);
  }
  
  isEditingName.value = false;
};

const findPuntoMaestroAndEmitUpdate = async (newNomenclature) => {
  const { data: puntoMaestro, error } = await supabase.from('puntos_maestros').select('*').eq('id', props.punto.punto_maestro_id).single();
  if (puntoMaestro && !error) {
    emit('update-nomenclatura', puntoMaestro, newNomenclature);
  } else {
    alert('Error: No se pudo encontrar el punto maestro para actualizar.');
  }
};
const gravedadOptions = [{ label: 'Verde', value: 'verde' }, { label: 'Ambar', value: 'ambar' }, { label: 'Rojo', value: 'rojo' }];
const tienePlaca = computed({
  get: () => puntoInspeccionado.value?.tiene_placa_caracteristicas,
  set: (newValue) => { if (puntoInspeccionado.value) { puntoInspeccionado.value.tiene_placa_caracteristicas = newValue; handlePlacaStatusChange(newValue); } }
});
const handlePlacaStatusChange = async (status) => {
  if (!puntoInspeccionado.value) return;
  addToQueue({ table: 'puntos_inspeccionados', type: 'update', id: puntoInspeccionado.value.id, payload: { tiene_placa_caracteristicas: status } });

  const incidenciasPlaca = getIncidenciasForItem(2).value;
  if (status === true) {
    if (incidenciasPlaca.length > 0) {
      for (const inc of incidenciasPlaca) {
        deleteIncidencia(inc.id);
      }
    }
  } else {
    if (incidenciasPlaca.length === 0) { await addIncidencia(2, { gravedad: 'verde', observaciones: 'Falta ficha' }); }
  }
};
const getIncidenciasForItem = (itemId) => computed(() => incidencias.value.filter(inc => inc.item_checklist === itemId));
const getCustomFieldsForItem = (itemId) => customFields.value.filter(field => field.point_id === itemId);
const isCollapsed = (itemId) => collapsedItems.value.has(itemId);
const toggleCollapse = (itemId) => { if (isCollapsed(itemId)) { collapsedItems.value.delete(itemId); } else { collapsedItems.value.add(itemId); } };
const onDragOver = (event, incidenceId) => { event.preventDefault(); dragOverIncidenceId.value = incidenceId; };
const onDragLeave = (event) => { event.preventDefault(); dragOverIncidenceId.value = null; };
const handleClose = () => {
  for (const item of checklistItems) {
    const itemFields = getCustomFieldsForItem(item.id);
    const itemIncidencias = getIncidenciasForItem(item.id).value;
    if (itemIncidencias.length > 0) {
      for (const field of itemFields) {
        if (field.required) {
          const hasFilledField = itemIncidencias.some(inc => customValues.value[inc.id]?.[field.id]);
          if (!hasFilledField) {
            showNotification(`No se puede guardar sin completar los campos obligatorios. El campo "${field.field_name}" es obligatorio.`, 'error');
            return;
          }
        }
      }
    }
  }
  emit('save'); 
  emit('close');
};
</script>

<template>
<div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
<div class="bg-slate-50 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
<header class="p-4 border-b bg-white rounded-t-lg flex justify-between items-center">
<div class="flex items-center gap-2">
<h2 class="text-xl font-bold text-slate-800">Checklist para Punto:</h2>
<div v-if="isEditingName" class="flex items-center gap-1 bg-white border border-blue-400 rounded-md p-1">
<span class="text-slate-500 pl-1">{{ pointPrefix }}</span>
<input
ref="nameInputRef"
v-model="tempPointIdentifier"
@keyup.enter="saveName"
@keyup.esc="isEditingName = false"
type="text"
class="text-xl font-bold text-slate-800 p-0 border-none focus:ring-0 w-24"
/>
<button @click="saveName" class="p-1 text-green-600 hover:bg-green-100 rounded">
<CheckIcon class="h-5 w-5"/>
</button>
</div>
<h2 v-else class="text-xl font-bold text-slate-800">{{ punto?.nomenclatura }}</h2>
<button v-if="!isEditingName" @click="startNameEditing" class="p-1 text-slate-400 hover:text-blue-600">
<PencilIcon class="h-5 w-5"/>
</button>
</div>
<button @click="handleClose" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
</header>
<main class="flex-1 overflow-y-auto p-6 space-y-3">
    <div v-if="!punto" class="text-center p-10">Cargando datos del punto...</div>
    <div v-else>
      <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-6">
        <h3 class="font-bold text-blue-800 mb-3">¿Dispone de placa de características?</h3>
        <div class="flex flex-col sm:flex-row gap-4">
          <button @click="tienePlaca = true" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === true ? 'bg-green-600 text-white shadow-md ring-2 ring-offset-2 ring-green-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><CheckCircleIcon class="h-5 w-5" />Sí, dispone de placa</button>
          <button @click="tienePlaca = false" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === false ? 'bg-red-600 text-white shadow-md ring-2 ring-offset-2 ring-red-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><XCircleIcon class="h-5 w-5" />No, no dispone de placa</button>
        </div>
        <p v-if="tienePlaca !== null" class="text-xs text-slate-500 mt-3 text-center">El estado del punto "2. Tiene las placas de identificación..." se ha actualizado automáticamente.</p>
      </div>

      <div v-for="item in checklistItems" :key="item.id" class="bg-white rounded-lg shadow-sm border transition-all duration-300">
        <div class="p-3 flex items-center justify-between">
          <p class="text-slate-700">{{ item.id }}. {{ item.text }}</p>
          <button
            @click="toggleItemStatus(item.id)"
            :class="['px-3 py-1 text-xs font-bold rounded-full',
                     getIncidenciasForItem(item.id).value.length > 0 ? 'bg-red-100 text-red-800 hover:bg-red-200' : 'bg-green-100 text-green-800 hover:bg-green-200']"
          >
            {{ getIncidenciasForItem(item.id).value.length > 0 ? 'INSATISFACTORIO' : 'SATISFACTORIO' }}
          </button>
        </div>

        <div v-if="getIncidenciasForItem(item.id).value.length > 0" class="border-t">
          <div 
            @click="toggleCollapse(item.id)" 
            class="bg-slate-100/50 p-2 flex justify-between items-center cursor-pointer hover:bg-slate-100"
          >
            <span class="text-sm font-semibold text-slate-600">
              {{ getIncidenciasForItem(item.id).value.length }} Incidencia(s)
            </span>
            <component :is="isCollapsed(item.id) ? ChevronDownIcon : ChevronUpIcon" class="h-5 w-5 text-slate-500" />
          </div>

          <div v-show="!isCollapsed(item.id)" class="bg-slate-50 p-4 space-y-4">
            <div v-for="(incidencia, index) in getIncidenciasForItem(item.id).value" :key="incidencia.id" class="bg-white border rounded-lg p-4 shadow-sm relative">
              <div class="flex justify-between items-center mb-3">
                <h4 class="font-bold text-slate-700">Incidencia #{{ index + 1 }}</h4>
                <button @click="deleteIncidencia(incidencia.id)" title="Borrar esta incidencia" class="p-1 text-slate-400 hover:text-red-500"><TrashIcon class="h-5 w-5"/></button>
              </div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="space-y-4">
                  <div>
                    <label class="block text-xs font-medium text-slate-600">Gravedad</label>
                    <select v-model="incidencia.gravedad" @change="saveIncidencia(incidencia)" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"><option v-for="opt in gravedadOptions" :key="opt.value" :value="opt.value">{{ opt.label }}</option></select>
                  </div>

                  <div v-if="getCustomFieldsForItem(item.id).length > 0" class="space-y-3">
                    <div v-for="field in getCustomFieldsForItem(item.id)" :key="field.id">
                      <label class="block text-xs font-medium text-slate-600">
                        {{ field.field_name }}
                        <span v-if="field.required" class="text-red-500">*</span>
                      </label>
                      <input
                        v-if="field.field_type === 'text'"
                        v-model="customValues[incidencia.id][field.id]"
                        @blur="saveIncidencia(incidencia)"
                        type="text"
                        :required="field.required"
                        class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"
                        :placeholder="`Ingrese ${field.field_name.toLowerCase()}`"
                      >
                      <input
                        v-else-if="field.field_type === 'number'"
                        v-model.number="customValues[incidencia.id][field.id]"
                        @blur="saveIncidencia(incidencia)"
                        type="number"
                        :required="field.required"
                        class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"
                        :placeholder="`Ingrese ${field.field_name.toLowerCase()}`"
                      >
                      <select
                        v-else-if="field.field_type === 'select'"
                        v-model="customValues[incidencia.id][field.id]"
                        @change="saveIncidencia(incidencia)"
                        :required="field.required"
                        class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"
                      >
                        <option value="">Seleccionar...</option>
                        <option v-for="option in field.options" :key="option" :value="option">{{ option }}</option>
                      </select>
                    </div>
                  </div>

                  <div>
                    <label class="block text-xs font-medium text-slate-600">Observaciones</label>
                    <textarea v-model="incidencia.observaciones" @blur="saveIncidencia(incidencia)" rows="3" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"></textarea>
                  </div>
                </div>
                <div>
                  <label class="block text-xs font-medium text-slate-600 mb-1">Foto de la Incidencia</label>
                  <div
                    class="aspect-video bg-slate-200 rounded-md flex items-center justify-center overflow-hidden relative group transition-colors"
                    :class="{ 'bg-blue-200 border-2 border-blue-400 border-dashed': dragOverIncidenceId === incidencia.id }"
                    @dragover="onDragOver($event, incidencia.id)"
                    @dragleave="onDragLeave"
                    @drop="onDrop($event, incidencia)"
                  >
                    <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="object-cover w-full h-full">
                    <div v-else class="text-center p-4">
                      <p v-if="isUploading === incidencia.id" class="text-sm text-slate-600">Procesando...</p>
                      <p v-else-if="dragOverIncidenceId === incidencia.id" class="text-sm text-slate-600">Suelta la foto aquí</p>
                      
                      <div v-else class="flex flex-col gap-2">
                        <label :for="'cameraInput-' + incidencia.id" class="cursor-pointer flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                          <ArrowUpTrayIcon class="h-4 w-4" /> Hacer Foto
                        </label>
                        <label :for="'fileInput-' + incidencia.id" class="cursor-pointer text-xs text-slate-600 hover:underline">
                          o seleccionar de la galería
                        </label>
                      </div>

                      <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'cameraInput-' + incidencia.id" accept="image/*" capture="environment">
                      <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id" accept="image/*">
                    </div>
                    <div v-if="incidencia.url_foto_antes" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                       <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-change-' + incidencia.id" accept="image/*">
                       <label :for="'fileInput-change-' + incidencia.id" class="cursor-pointer text-white text-sm font-semibold">Cambiar Foto</label>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div>
              <button @click="addIncidencia(item.id)" class="w-full flex items-center justify-center gap-2 py-2 text-sm font-semibold text-blue-700 bg-blue-50 rounded-md hover:bg-blue-100 border border-dashed border-blue-300"><PlusCircleIcon class="h-5 w-5"/>Añadir otra incidencia</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="p-4 bg-white border-t rounded-b-lg flex justify-end">
    <button @click="handleClose" class="px-5 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Cerrar</button>
  </footer>
</div>
</div>
</template>
--- FIN DEL ARCHIVO: src/components/ChecklistModal.vue ---

--- INICIO DEL ARCHIVO: src/components/InspectionSidebar.vue ---
<!-- src/components/InspectionSidebar.vue -->
<script setup>
import { ref } from 'vue';
import PointList from './PointList.vue';
import AddPointForm from './AddPointForm.vue';
import { PlusIcon, XCircleIcon, CheckCircleIcon, PencilSquareIcon, MapIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  canEdit: Boolean,
  salas: Array,
  puntosAgrupados: Array,
  allIncidencias: {
    type: Array,
    default: () => []
  },
  isPlanoEditingMode: {
    type: Boolean,
    default: false
  },
  isMobileAddPointOpen: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits([
  'toggle-plano-editing',
  'add-sala',
  'start-area-drawing',
  'start-placement-mode',
  'cancel-placement-mode',
  'select-point',
  'update-point-state',
  'delete-new-point',
  'update-point-nomenclatura',
  'update:is-mobile-add-point-open'
]);

// Estado local para desktop
const isPlanoEditingModeLocal = ref(false);
const showAddSalaForm = ref(false);
const newSalaName = ref('');
const showAddPointForm = ref(false);
const isPlacementMode = ref(false);

const handleTogglePlanoEditing = () => {
  isPlanoEditingModeLocal.value = !isPlanoEditingModeLocal.value;
  emit('toggle-plano-editing', isPlanoEditingModeLocal.value);
  if (!isPlanoEditingModeLocal.value) {
    showAddSalaForm.value = false;
  }
};

const handleAddSala = () => {
  if (newSalaName.value.trim()) {
    emit('add-sala', newSalaName.value.trim());
    newSalaName.value = '';
    showAddSalaForm.value = false;
  }
};

const handleStartPlacement = (salaId) => {
  isPlacementMode.value = true;
  showAddPointForm.value = false;
  emit('update:is-mobile-add-point-open', false);
  emit('start-placement-mode', salaId);
};

const handleCancelPlacement = () => {
  isPlacementMode.value = false;
  emit('cancel-placement-mode');
};
</script>

<template>
  <aside class="w-full lg:w-80 xl:w-96 flex-shrink-0 bg-white border-r border-slate-200 flex flex-col overflow-hidden">
    <!-- Botón Editar Plano - SOLO VISIBLE EN DESKTOP -->
    <div class="hidden lg:block p-4 flex-shrink-0 border-b">
      <button v-if="canEdit" @click="handleTogglePlanoEditing"
              :class="[
                'w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold rounded-md shadow-sm transition-colors',
                isPlanoEditingModeLocal ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-white text-slate-700 border border-slate-300 hover:bg-slate-50'
              ]">
        <PencilSquareIcon class="h-5 w-5" />
        {{ isPlanoEditingModeLocal ? 'Finalizar Edición Plano' : 'Editar Plano' }}
      </button>
    </div>

    <!-- Formularios de Edición - SOLO VISIBLE EN DESKTOP -->
    <div class="hidden lg:block p-4 flex-shrink-0 space-y-2">
       <div v-if="canEdit && isPlanoEditingModeLocal" class="p-3 bg-orange-50 border border-orange-200 rounded-lg space-y-3">
          <h3 class="font-bold text-orange-800">Modo Edición de Plano</h3>
          <form v-if="showAddSalaForm" @submit.prevent="handleAddSala" class="flex gap-2">
              <input v-model="newSalaName" type="text" placeholder="Nombre nueva sala..." class="flex-1 block w-full rounded-md border-slate-300 shadow-sm text-sm">
              <button type="submit" class="p-2 bg-green-600 text-white rounded-md hover:bg-green-700"><CheckCircleIcon class="h-5 w-5"/></button>
              <button @click="showAddSalaForm = false" type="button" class="p-2 bg-red-600 text-white rounded-md hover:bg-red-700"><XCircleIcon class="h-5 w-5"/></button>
          </form>
          <button v-else @click="showAddSalaForm = true" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-600 bg-white rounded-md hover:bg-slate-50 border">
             <PlusIcon class="h-5 w-5" /> Añadir Sala
          </button>
       </div>

       <div v-if="canEdit && !isPlanoEditingModeLocal">
          <AddPointForm
             v-if="showAddPointForm"
             :salas="salas"
             @save="handleStartPlacement"
             @cancel="showAddPointForm = false"
          />
          <button v-else-if="!isPlacementMode" @click="showAddPointForm = true" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-600 bg-slate-100 rounded-md hover:bg-slate-200">
             <PlusIcon class="h-5 w-5" />
             Agregar Punto Nuevo
          </button>
          <button v-if="isPlacementMode" @click="handleCancelPlacement" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
             <XCircleIcon class="h-5 w-5" />
             Cancelar Colocación
          </button>
       </div>
    </div>

    <!-- Formulario móvil de Agregar Punto - SOLO VISIBLE EN MÓVIL -->
    <div v-if="canEdit && !isPlanoEditingMode && isMobileAddPointOpen" class="lg:hidden p-4 flex-shrink-0 border-b bg-blue-50">
       <AddPointForm
          :salas="salas"
          @save="handleStartPlacement"
          @cancel="emit('update:is-mobile-add-point-open', false)"
       />
    </div>

    <!-- Mensaje de modo edición en móvil -->
    <div v-if="canEdit && isPlanoEditingMode" class="lg:hidden p-3 bg-orange-50 border-b border-orange-200">
       <p class="text-sm font-medium text-orange-800 text-center">Modo Edición de Plano activo</p>
    </div>

    <div class="flex-1 overflow-y-auto px-4 pb-4">
      <PointList
        :grouped-points="puntosAgrupados"
        :can-edit="canEdit"
        :all-incidencias="allIncidencias"
        @select-point="$emit('select-point', $event)"
        @update-state="(point, newState) => $emit('update-point-state', point, newState)"
        @delete-new-point="$emit('delete-new-point', $event)"
        @update-point-nomenclatura="(point, newName) => $emit('update-point-nomenclatura', point, newName)"
        :class="{ 'pointer-events-none opacity-50': isPlacementMode || isPlanoEditingMode || isPlanoEditingModeLocal }"
      >
        <template #sala-actions="{ sala }">
          <button v-if="isPlanoEditingMode || isPlanoEditingModeLocal" @click="$emit('start-area-drawing', sala)" class="p-1 text-slate-400 hover:text-blue-600" title="Definir área de la sala">
            <MapIcon class="h-5 w-5" />
          </button>
        </template>
      </PointList>
    </div>
  </aside>
</template>
--- FIN DEL ARCHIVO: src/components/InspectionSidebar.vue ---

--- INICIO DEL ARCHIVO: src/components/AddPointForm.vue ---
<!-- src/components/AddPointForm.vue -->
<script setup>
import { ref } from 'vue';

defineProps({
  salas: {
    type: Array,
    required: true
  }
});

const emit = defineEmits(['save', 'cancel']);

const selectedSalaId = ref(null);

const handleSave = () => {
  if (!selectedSalaId.value) {
    alert("Por favor, selecciona una sala.");
    return;
  }
  emit('save', selectedSalaId.value);
};
</script>

<template>
  <div class="p-2 bg-slate-50 rounded-lg">
    <h4 class="font-bold text-sm mb-2">Añadir Nuevo Punto</h4>
    <select v-model="selectedSalaId" class="block w-full rounded-md border-slate-300 shadow-sm text-sm mb-2">
      <option :value="null" disabled>Selecciona una sala...</option>
      <option v-for="sala in salas" :key="sala.id" :value="sala.id">{{ sala.nombre }}</option>
    </select>
    <div class="flex gap-2">
      <button @click="$emit('cancel')" class="w-full text-sm py-1 px-2 rounded bg-white border hover:bg-slate-50">Cancelar</button>
      <button @click="handleSave" class="w-full text-sm py-1 px-2 rounded bg-blue-600 text-white hover:bg-blue-700">Guardar</button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/AddPointForm.vue ---

--- INICIO DEL ARCHIVO: src/components/ConfirmModal.vue ---
<!-- src/components/ConfirmModal.vue -->
<script setup>
import { XMarkIcon } from '@heroicons/vue/24/solid';

defineProps({
  isOpen: Boolean,
  title: String,
  message: String,
});

const emit = defineEmits(['confirm', 'cancel']);

const handleConfirm = () => {
  emit('confirm');
};

const handleCancel = () => {
  emit('cancel');
};
</script>

<template>
  <div v-if="isOpen" @click.self="handleCancel" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
      <div class="p-4 border-b flex justify-between items-center">
        <h2 class="text-lg font-bold text-slate-800">{{ title || 'Confirmar' }}</h2>
        <button @click="handleCancel" class="text-slate-400 hover:text-slate-600 text-xl">&times;</button>
      </div>
      <div class="p-4">
        <p class="text-slate-600">{{ message }}</p>
      </div>
      <div class="p-4 border-t flex justify-end gap-2">
        <button @click="handleCancel" class="px-4 py-2 font-semibold text-slate-700 bg-slate-100 rounded-md hover:bg-slate-200">Cancelar</button>
        <button @click="handleConfirm" class="px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">Confirmar</button>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/ConfirmModal.vue ---

--- INICIO DEL ARCHIVO: src/components/Login.vue ---
<!-- src/components/Login.vue -->
<script setup>
import { ref } from 'vue'
import { supabase } from '../supabase'
import { useRouter } from 'vue-router'

const router = useRouter()
const loading = ref(false)
const email = ref('')
const password = ref('')

const handleLogin = async () => {
  try {
    loading.value = true
    const { error } = await supabase.auth.signInWithPassword({
      email: email.value,
      password: password.value,
    })
    if (error) throw error
    router.push('/dashboard')
  } catch (error) {
    alert(error.error_description || error.message)
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <!-- Cambiamos los colores de fondo y texto principales -->
  <div class="flex items-center justify-center min-h-screen bg-gray-100 text-gray-800">
    <!-- El contenedor del formulario ahora es blanco con una sombra sutil -->
    <div class="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
      <h1 class="text-3xl font-bold text-center text-gray-900">Inspección de Estanterías</h1>
      <p class="text-center text-gray-600">Inicia sesión para continuar</p>
      <form @submit.prevent="handleLogin" class="space-y-6">
        <div>
          <label for="email" class="block text-sm font-medium text-gray-700">Email</label>
          <!-- Los inputs ahora tienen un fondo más claro -->
          <input 
            id="email" 
            type="email" 
            v-model="email" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="email"
            required
          />
        </div>
        <div>
          <label for="password" class="block text-sm font-medium text-gray-700">Contraseña</label>
          <input 
            id="password" 
            type="password" 
            v-model="password" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="current-password"
            required
          />
        </div>
        <div>
          <button 
            type="submit" 
            :disabled="loading" 
            class="w-full py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            {{ loading ? 'Cargando...' : 'Acceder' }}
          </button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/Login.vue ---

--- INICIO DEL ARCHIVO: src/components/ReloadPWA.vue ---
<!-- src/components/ReloadPWA.vue -->
<script setup>
defineProps({
  offlineReady: Boolean,
  needRefresh: Boolean,
});

const emit = defineEmits(['update-service-worker']);

const updateSW = () => {
  emit('update-service-worker');
};
</script>

<template>
  <div v-if="needRefresh" role="alert" class="fixed right-0 bottom-0 m-4 p-4 border rounded-lg shadow-lg bg-white z-[100]">
    <div class="flex items-start gap-4">
      <div class="flex-1">
        <p class="font-bold">Nueva versión disponible</p>
        <p class="text-sm">Hay una actualización pendiente. Por favor, recarga la página.</p>
      </div>
      <button @click="updateSW" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
        Recargar
      </button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/ReloadPWA.vue ---

--- INICIO DEL ARCHIVO: src/components/NomenclatureModal.vue ---
--- INICIO DEL ARCHIVO: src\components\NomenclatureModal.vue ---
<!-- src/components/NomenclatureModal.vue -->
<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
isOpen: Boolean,
salaNombre: String,
suggestedNumber: Number,
existingIdentifiers: { // Renombrado de existingNumbers a existingIdentifiers
type: Array,
default: () => []
}
});

const emit = defineEmits(['save', 'close']);
const pointIdentifier = ref(''); // Renombrado de pointNumber a pointIdentifier
const error = ref('');

watch(() => props.isOpen, (newVal) => {
if (newVal) {
pointIdentifier.value = props.suggestedNumber;
error.value = '';
}
});

const handleSave = () => {
error.value = '';
const identifier = String(pointIdentifier.value).trim();

if (!identifier) {
error.value = 'Por favor, introduce un identificador válido.';
return;
}

// --- INICIO DE LA CORRECCIÓN: Lógica de validación flexible ---
// Comprobamos si el identificador exacto (sensible a mayúsculas/minúsculas) ya existe.
if (props.existingIdentifiers.includes(identifier)) {
error.value = `El punto con el identificador "${identifier}" ya existe en esta sala.`;
return;
}
// --- FIN DE LA CORRECCIÓN ---

emit('save', identifier); // Enviamos el identificador como string
};
</script>
<template>
<div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
<div class="bg-white rounded-lg shadow-xl w-full max-w-sm">
<div class="p-6">
<h2 class="text-lg font-bold text-slate-800">Añadir Nuevo Punto</h2>
<p class="text-sm text-slate-500 mt-1">
Introduce el identificador para el nuevo punto en la sala <span class="font-semibold">{{ salaNombre }}</span>.
</p>
<div class="mt-4">
<label for="pointIdentifier" class="block text-sm font-medium text-slate-700">Identificador del Punto</label>
<!-- --- INICIO DE LA CORRECCIÓN: Input de tipo texto --- -->
<input
v-model="pointIdentifier"
type="text"
id="pointIdentifier"
@keyup.enter="handleSave"
class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
>
<!-- --- FIN DE LA CORRECCIÓN --- -->
<p v-if="error" class="mt-2 text-sm text-red-600">{{ error }}</p>
</div>
</div>
<div class="p-4 bg-slate-50 border-t flex justify-end space-x-3">
<button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
Cancelar
</button>
<button type="button" @click="handleSave" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
Guardar Punto
</button>
</div>
</div>
</div>
</template>
--- FIN DEL ARCHIVO: src/components/NomenclatureModal.vue ---

--- INICIO DEL ARCHIVO: src/components/GlobalStatusIndicator.vue ---
<!-- src/components/GlobalStatusIndicator.vue -->
<script setup>
import { syncQueue, isProcessing } from '../utils/syncQueue';
import { useOnlineStatus } from '../composables/useOnlineStatus';
import { SignalSlashIcon, CloudArrowUpIcon, WifiIcon } from '@heroicons/vue/24/solid';

defineProps({
  mode: {
    type: String,
    default: 'desktop', // 'desktop' or 'mobile'
  }
});

const { isOnline } = useOnlineStatus();
</script>

<template>
  <!-- ======================== MODO MÓVIL (ICONO COMPACTO) ======================== -->
  <!-- INICIO DE LA CORRECCIÓN: Añadido un div contenedor -->
  <div v-if="mode === 'mobile'">
  <!-- FIN DE LA CORRECCIÓN -->
    <div class="relative flex items-center justify-center w-8 h-8">
      <!-- Offline (Máxima Prioridad) -->
      <div v-if="!isOnline" title="Estás sin conexión">
        <SignalSlashIcon class="h-6 w-6 text-red-500" />
      </div>
      <!-- Sincronizando -->
      <div v-else-if="isProcessing" title="Sincronizando cambios...">
        <CloudArrowUpIcon class="h-6 w-6 text-blue-500 animate-pulse" />
      </div>
      <!-- Cambios Pendientes -->
      <div v-else-if="syncQueue.length > 0" title="Cambios pendientes de sincronizar">
        <CloudArrowUpIcon class="h-6 w-6 text-amber-500" />
        <span class="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-amber-500 text-white text-[10px] font-bold">
          {{ syncQueue.length }}
        </span>
      </div>
      <!-- Online y Sincronizado -->
      <div v-else title="Conectado y sincronizado">
        <WifiIcon class="h-6 w-6 text-green-500" />
      </div>
    </div>
  </div>

  <!-- ======================== MODO ESCRITORIO (TEXTO DESCRIPTIVO) ======================== -->
  <div v-if="mode === 'desktop'">
    <!-- Indicador de Conexión -->
    <div 
      :class="['flex items-center justify-center gap-2 p-2 rounded-md text-xs font-bold mb-2', isOnline ? 'bg-green-500/20 text-green-300' : 'bg-red-500/20 text-red-300']">
      <component :is="isOnline ? WifiIcon : SignalSlashIcon" class="h-4 w-4" />
      <span>{{ isOnline ? 'Conectado' : 'Sin Conexión' }}</span>
    </div>
    <!-- Indicador de Sincronización (solo si hay algo que mostrar) -->
    <div v-if="syncQueue.length > 0 || isProcessing"
         class="flex items-center gap-2 p-2 rounded-md text-xs font-bold bg-blue-500/20 text-blue-300">
      <CloudArrowUpIcon class="h-4 w-4" :class="{ 'animate-pulse': isProcessing }" />
      <span v-if="isProcessing">Sincronizando...</span>
      <span v-else>{{ syncQueue.length }} cambio(s) en cola</span>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/GlobalStatusIndicator.vue ---

--- INICIO DEL ARCHIVO: src/components/MarkAsSentModal.vue ---
<!-- src/components/MarkAsSentModal.vue -->
<script setup>
import { ref, watch } from 'vue';
import { PaperAirplaneIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  inspeccionId: Number,
});

const emit = defineEmits(['close', 'save']);

const formData = ref({
  fecha_envio: '',
  responsable_envio: '',
});

// Cuando el modal se abre, pre-rellenamos la fecha con el día de hoy
watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    formData.value = {
      fecha_envio: new Date().toISOString().slice(0, 10), // Formato YYYY-MM-DD
      responsable_envio: '',
    };
  }
});

const handleSubmit = () => {
  if (!formData.value.fecha_envio || !formData.value.responsable_envio) {
    alert('Por favor, completa todos los campos.');
    return;
  }
  emit('save', formData.value);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md transform transition-all">
      <div class="p-6 border-b border-slate-200 text-center">
        <div class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
            <PaperAirplaneIcon class="h-6 w-6 text-blue-600" aria-hidden="true" />
        </div>
        <h2 class="mt-4 text-xl font-bold text-slate-800">Confirmar Envío a Cliente</h2>
        <p class="text-sm text-slate-500 mt-1">Registra la fecha y el responsable del envío.</p>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 space-y-4">
          <div>
            <label for="fecha_envio" class="block text-sm font-medium text-slate-600">Fecha de Envío</label>
            <input 
              v-model="formData.fecha_envio" 
              type="date" 
              id="fecha_envio" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
          <div>
            <label for="responsable_envio" class="block text-sm font-medium text-slate-600">Enviado por</label>
            <input 
              v-model="formData.responsable_envio" 
              type="text" 
              id="responsable_envio" 
              placeholder="Nombre del responsable" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
        </div>
        <div class="p-4 bg-slate-50 border-t border-slate-200 flex justify-end space-x-3">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar y Marcar</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/MarkAsSentModal.vue ---

--- INICIO DEL ARCHIVO: src/components/CentroFormModal.vue ---
<!-- src/components/CentroFormModal.vue -->
<script setup>
import { ref, watch, onMounted } from 'vue';
import { supabase } from '../supabase';
import { ArrowUpTrayIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  isOpen: Boolean,
  centro: Object,
});

const emit = defineEmits(['close', 'save']);

const form = ref({});
const isUploadingLogo = ref(false);
const logoInput = ref(null);
const zonas = ref([]);
const provincias = ref([]); // <-- Ahora es reactivo
const selectedLogoFile = ref(null); // Archivo seleccionado antes de guardar
const previewLogoUrl = ref(null); // URL de preview temporal

onMounted(async () => {
  // Cargar las listas desde Supabase cuando el componente se monta
  const { data: zonasData } = await supabase.from('zonas').select('nombre').order('nombre');
  if (zonasData) zonas.value = zonasData.map(z => z.nombre);
  
  // Asumimos que tienes una tabla `provincias` similar, si no, la creamos.
  // Por ahora, lo mantenemos simple. Si no hay tabla, podemos volver a la lista local.
  // const { data: provinciasData } = await supabase.from('provincias').select('nombre').order('nombre');
  // if (provinciasData) provincias.value = provinciasData.map(p => p.nombre);
});

watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    form.value = props.centro ? { ...props.centro } : { nombre: '', direccion: '', responsable_nombre: '', responsable_email: '', provincia: '', zona: '', url_logo_cliente: null };
    // Limpiar archivo y preview al abrir el modal
    selectedLogoFile.value = null;
    if (previewLogoUrl.value) {
      URL.revokeObjectURL(previewLogoUrl.value);
      previewLogoUrl.value = null;
    }
  }
});

const handleLogoSelected = async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  // Si el centro ya existe (modo edición), subir directamente
  if (form.value.id) {
    isUploadingLogo.value = true;
    const fileName = `cliente_${form.value.id}/${Date.now()}_${file.name}`;
    const { error: uploadError } = await supabase.storage.from('logos-clientes').upload(fileName, file);
    if (uploadError) {
      alert("Error al subir el logo: " + uploadError.message);
      isUploadingLogo.value = false;
      return;
    }
    const { data: { publicUrl } } = supabase.storage.from('logos-clientes').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('centros').update({ url_logo_cliente: publicUrl }).eq('id', form.value.id);
    if (updateError) {
      alert("Error al guardar la URL del logo: " + updateError.message);
    } else {
      form.value.url_logo_cliente = publicUrl;
    }
    isUploadingLogo.value = false;
  } else {
    // Si es un centro nuevo, guardar el archivo para subirlo después
    selectedLogoFile.value = file;
    // Limpiar preview anterior si existe
    if (previewLogoUrl.value) {
      URL.revokeObjectURL(previewLogoUrl.value);
    }
    // Crear preview temporal
    previewLogoUrl.value = URL.createObjectURL(file);
  }
};

const handleSubmit = () => {
  // Incluir el archivo del logo si fue seleccionado
  const dataToSave = { ...form.value };
  if (selectedLogoFile.value) {
    dataToSave._logoFile = selectedLogoFile.value;
  }
  emit('save', dataToSave);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
      <div class="p-6 border-b">
        <h2 class="text-2xl font-bold text-slate-800">{{ centro ? 'Editar Centro' : 'Agregar Nuevo Centro' }}</h2>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
          <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="md:col-span-2">
              <label for="nombre" class="block text-sm font-medium text-slate-600">Nombre del Centro</label>
              <input v-model="form.nombre" type="text" id="nombre" required class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div class="md:col-span-2">
              <label for="direccion" class="block text-sm font-medium text-slate-600">Dirección</label>
              <input v-model="form.direccion" type="text" id="direccion" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_nombre" class="block text-sm font-medium text-slate-600">Nombre del Responsable</label>
              <input v-model="form.responsable_nombre" type="text" id="responsable_nombre" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_email" class="block text-sm font-medium text-slate-600">Email del Responsable</label>
              <input v-model="form.responsable_email" type="email" id="responsable_email" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="provincia" class="block text-sm font-medium text-slate-600">Provincia</label>
              <input v-model="form.provincia" type="text" id="provincia" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="zona" class="block text-sm font-medium text-slate-600">Zona</label>
              <select v-model="form.zona" id="zona" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <option disabled value="">Selecciona una zona</option>
                <option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
              </select>
            </div>
          </div>
          
          <div class="md:col-span-1">
             <input type="file" ref="logoInput" @change="handleLogoSelected" accept="image/*" class="hidden">
             <label class="block text-sm font-medium text-slate-600 mb-1">Logo del Cliente</label>
             <div class="aspect-video bg-slate-100 rounded-md flex items-center justify-center border-2 border-dashed">
                <img v-if="previewLogoUrl || form.url_logo_cliente" :src="previewLogoUrl || form.url_logo_cliente" class="object-contain w-full h-full p-2">
                <div v-else class="text-center text-slate-500 p-4">Sin logo</div>
             </div>
             <button
                type="button"
                @click="logoInput.click()"
                :disabled="isUploadingLogo"
                class="mt-2 w-full flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold rounded-md transition-colors
                       disabled:bg-slate-200 disabled:text-slate-500 disabled:cursor-not-allowed
                       text-slate-700 bg-white border border-slate-300 hover:bg-slate-50"
              >
               <ArrowUpTrayIcon class="h-4 w-4" />
               {{ isUploadingLogo ? 'Subiendo...' : ((previewLogoUrl || form.url_logo_cliente) ? 'Cambiar Logo' : 'Subir Logo') }}
             </button>
             <p v-if="!form.id && selectedLogoFile" class="text-xs text-green-600 mt-1 text-center">Logo seleccionado. Se subirá al guardar.</p>
          </div>
        </div>
        <div class="p-6 bg-slate-50 border-t flex justify-end space-x-4">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar Cambios</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/CentroFormModal.vue ---

--- INICIO DEL ARCHIVO: src/components/GrupoVisitaEditable.vue ---
<!-- src/components/GrupoVisitaEditable.vue -->
<script setup>
import { ref, nextTick } from 'vue';
import { PencilIcon, CheckIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  value: [String, Number],
  inspeccionId: Number
});

const emit = defineEmits(['save']);

const isEditing = ref(false);
const localValue = ref(props.value);
const inputRef = ref(null);

const startEditing = () => {
  if (!props.inspeccionId) return; // No se puede editar si no hay inspección
  localValue.value = props.value;
  isEditing.value = true;
  nextTick(() => {
    inputRef.value?.focus();
  });
};

const saveEdit = () => {
  if (localValue.value !== props.value) {
    emit('save', {
      inspeccionId: props.inspeccionId,
      newValue: localValue.value
    });
  }
  isEditing.value = false;
};
</script>

<template>
  <div class="flex items-center justify-center group">
    <div v-if="!isEditing" @click="startEditing" class="cursor-pointer min-h-[2rem] flex items-center justify-center px-2">
      <span v-if="value">{{ value }}</span>
      <span v-else class="text-slate-400 italic text-xs">N/A</span>
      <PencilIcon v-if="inspeccionId" class="h-3 w-3 ml-2 text-slate-400 opacity-0 group-hover:opacity-100 transition-opacity" />
    </div>
    <div v-else class="flex items-center gap-1">
      <input
        ref="inputRef"
        v-model="localValue"
        type="text"
        @keyup.enter="saveEdit"
        @keyup.esc="isEditing = false"
        @blur="saveEdit"
        class="w-20 text-center text-sm p-1 border-blue-400 ring-1 ring-blue-400 rounded-md"
      />
      <button @click="saveEdit" class="p-1 text-green-600 hover:bg-green-100 rounded">
        <CheckIcon class="h-4 w-4" />
      </button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/GrupoVisitaEditable.vue ---

--- INICIO DEL ARCHIVO: src/components/SkeletonLoader.vue ---
<!-- src/components/SkeletonLoader.vue -->
<template>
  <div class="w-full h-full bg-slate-200 rounded-md animate-pulse"></div>
</template>
--- FIN DEL ARCHIVO: src/components/SkeletonLoader.vue ---

--- INICIO DEL ARCHIVO: src/components/PlanoBadge.vue ---
<!-- src/components/PlanoBadge.vue -->
<template>
  <div
    class="w-full h-full p-1 flex flex-col items-center rounded-lg shadow-lg cursor-move font-sans"
  >
    <!-- Cabecera con Punto y Estado -->
    <div class="text-center">
      <div class="font-bold text-sm text-gray-800 leading-tight">{{ pointNumber }}</div>
      <div v-if="stateText" class="font-bold text-[10px] leading-tight text-blue-600 uppercase break-words">
        {{ stateText }}
      </div>
    </div>
    
    <hr class="w-11/12 my-1 border-t border-gray-200">
    
    <!-- Contenedor del semáforo -->
    <div class="flex-1 w-full flex justify-center items-center">
      <!-- Fila de círculos con espaciado explícito -->
      <div class="flex items-center">
        <!-- ===== INICIO DE LA SOLUCIÓN FINAL ===== -->
        <div 
          v-for="(item, index) in semaphoreItems" 
          :key="item.label"
          :class="['w-5 h-5 rounded-full flex-shrink-0 flex items-center justify-center', { 'mx-1': index === 1 }]"
          :style="{ backgroundColor: item.color }"
          :title="`${item.count} incidencias de tipo ${item.label}`"
        >
          <span class="text-white font-bold text-[10px] leading-none">
            {{ item.count }}
          </span>
        </div>
        <!-- ===== FIN DE LA SOLUCIÓN FINAL ===== -->
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, watch } from 'vue';

const props = defineProps({
  pointData: Object
});

const pointNumber = computed(() => props.pointData.nomenclatura.split('-').pop() || '?');

const stateText = computed(() => {
  if (props.pointData.estado === 'nuevo') return 'NUEVA';
  if (props.pointData.estado === 'suprimido') return 'SUPRIMIDA';
  if (props.pointData.detalle_modificacion === 'aumentado') return 'AUMENTADA';
  if (props.pointData.detalle_modificacion === 'disminuido') return 'DISMINUIDA';
  return null;
});

const semaphoreItems = computed(() => {
  const counts = props.pointData?.counts || { verde: 0, ambar: 0, rojo: 0 };
  console.log('PlanoBadge semaphore data for point', props.pointData?.nomenclatura, ':', counts);
  return [
    { label: 'verde', color: '#22C55E', count: counts.verde || 0 },
    { label: 'ambar', color: '#F59E0B', count: counts.ambar || 0 },
    { label: 'rojo', color: '#EF4444', count: counts.rojo || 0 },
  ];
});

// Watch for changes in pointData to debug reactivity
watch(() => props.pointData, (newData, oldData) => {
  console.log('PlanoBadge pointData changed:', {
    point: newData?.nomenclatura,
    oldCounts: oldData?.counts,
    newCounts: newData?.counts
  });
}, { deep: true, immediate: true });
</script>
--- FIN DEL ARCHIVO: src/components/PlanoBadge.vue ---

--- INICIO DEL ARCHIVO: src/components/Notification.vue ---
<!-- src/components/Notification.vue -->
<script setup>
import { CheckCircleIcon, XCircleIcon, ExclamationTriangleIcon, InformationCircleIcon } from '@heroicons/vue/24/solid';

defineProps({
  show: Boolean,
  message: String,
  type: {
    type: String,
    default: 'success', // 'success', 'error', 'warning', 'info'
  },
});
</script>

<template>
  <div
    aria-live="assertive"
    class="pointer-events-none fixed inset-0 flex items-end px-4 py-6 sm:items-start sm:p-6 z-[100]"
  >
    <div class="flex w-full flex-col items-center space-y-4 sm:items-end">
      <transition
        enter-active-class="transform ease-out duration-300 transition"
        enter-from-class="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
        enter-to-class="translate-y-0 opacity-100 sm:translate-x-0"
        leave-active-class="transition ease-in duration-100"
        leave-from-class="opacity-100"
        leave-to-class="opacity-0"
      >
        <div
          v-if="show"
          class="pointer-events-auto w-full max-w-sm overflow-hidden rounded-lg bg-white shadow-lg ring-1 ring-black ring-opacity-5"
        >
          <div class="p-4">
            <div class="flex items-start">
              <div class="flex-shrink-0">
                <CheckCircleIcon v-if="type === 'success'" class="h-6 w-6 text-green-400" aria-hidden="true" />
                <XCircleIcon v-if="type === 'error'" class="h-6 w-6 text-red-400" aria-hidden="true" />
                <ExclamationTriangleIcon v-if="type === 'warning'" class="h-6 w-6 text-yellow-400" aria-hidden="true" />
                <InformationCircleIcon v-if="type === 'info'" class="h-6 w-6 text-blue-400" aria-hidden="true" />
              </div>
              <div class="ml-3 w-0 flex-1 pt-0.5">
                <p class="text-sm font-medium text-gray-900">
                  {{ type === 'success' ? 'Éxito' : type === 'error' ? 'Error' : type === 'warning' ? 'Advertencia' : 'Información' }}
                </p>
                <p class="mt-1 text-sm text-gray-500">
                  {{ message }}
                </p>
              </div>
            </div>
          </div>
        </div>
      </transition>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/Notification.vue ---

--- INICIO DEL ARCHIVO: src/components/InspectionListItem.vue ---
<!-- src/components/InspectionListItem.vue -->
<script setup>
import { ref, computed } from 'vue';
import { supabase } from '../supabase';
import {
EyeIcon,
TrashIcon,
PaperAirplaneIcon,
ArchiveBoxIcon,
MapIcon,
ArrowDownCircleIcon,
ArrowUturnLeftIcon,
UserIcon,
ChevronDownIcon
} from '@heroicons/vue/24/outline';
import { useRouter } from 'vue-router';

const props = defineProps({
inspeccion: {
type: Object,
required: true
},
isProcessing: Boolean,
});

const emit = defineEmits(['mark-as-sent', 'reopen', 'delete', 'date-updated']);

const router = useRouter();
const isExpanded = ref(false);
const isEditingDate = ref(false);
const newDate = ref(props.inspeccion.fecha_inspeccion);

const estadoInfo = computed(() => {
const estado = props.inspeccion.estado;
switch (estado) {
case 'en_progreso': return { text: 'En Progreso', class: 'bg-blue-100 text-blue-800' };
case 'finalizada': return { text: 'Pendiente de Envío', class: 'bg-orange-100 text-orange-800' };
case 'pendiente_subsanacion': return { text: 'Pendiente de Cierre', class: 'bg-yellow-100 text-yellow-800' };
case 'cerrada': return { text: 'Cerrada', class: 'bg-green-100 text-green-800' };
default: return { text: estado, class: 'bg-slate-100 text-slate-800' };
}
});

const toggleDetails = () => {
isExpanded.value = !isExpanded.value;
if (isExpanded.value) {
// La carga de detalles se dispara desde el padre
}
};

// --- INICIO DE LA SOLUCIÓN PROFESIONAL: Cache Busting ---
// Esta función ahora se encarga de añadir un parámetro único a la URL
// para forzar al navegador y al Service Worker a descargar la versión más reciente del archivo.
const openArchivedPdf = (url) => {
  if (!url) {
    console.warn('El informe PDF para esta inspección aún no ha sido generado o archivado.');
    return;
  }
  
  try {
    // 1. Creamos un objeto URL para manipularla fácilmente.
    const urlObject = new URL(url);
    
    // 2. Añadimos un parámetro de búsqueda 't' con el timestamp actual.
    // Esto hace que la URL sea única en cada clic, "rompiendo" la caché.
    urlObject.searchParams.set('t', Date.now());
    
    // 3. Abrimos la nueva URL cache-busted en una nueva pestaña.
    window.open(urlObject.toString(), '_blank');

  } catch (error) {
    console.error("URL del PDF inválida, abriendo directamente:", error);
    // Como fallback, si la URL es inválida, intentamos abrirla tal cual.
    window.open(url, '_blank');
  }
};
// --- FIN DE LA SOLUCIÓN PROFESIONAL ---

const startEditingDate = () => {
newDate.value = props.inspeccion.fecha_inspeccion;
isEditingDate.value = true;
};

const saveDate = async () => {
if (newDate.value === props.inspeccion.fecha_inspeccion) {
isEditingDate.value = false;
return;
}

const { error } = await supabase
.from('inspecciones')
.update({ fecha_inspeccion: newDate.value })
.eq('id', props.inspeccion.id);

if (error) {
alert('Error al actualizar la fecha: ' + error.message);
} else {
emit('date-updated', { id: props.inspeccion.id, newDate: newDate.value });
}
isEditingDate.value = false;
};
</script>
<template>
<div class="bg-white rounded-xl shadow-sm border border-slate-200 transition-all">
<div class="p-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 items-center">
  <div class="space-y-2 group cursor-pointer" @click="startEditingDate">
    <div>
      <p class="text-xs font-semibold text-slate-500">Fecha Inspección</p>
      <div v-if="!isEditingDate" class="font-semibold text-slate-800">
        {{ new Date(inspeccion.fecha_inspeccion + 'T00:00:00').toLocaleDateString() }}
      </div>
      <input 
        v-else
        type="date"
        v-model="newDate"
        @blur="saveDate"
        @keyup.enter="saveDate"
        @click.stop
        class="p-1 rounded-md border-slate-300 shadow-sm text-sm"
      />
    </div>
    <div class="flex items-center gap-2">
      <UserIcon class="h-4 w-4 text-slate-400" />
      <span class="text-sm text-slate-600">{{ inspeccion.tecnico_nombre }}</span>
    </div>
  </div>
  
  <div class="space-y-2">
     <div>
       <p class="text-xs font-semibold text-slate-500">Estado</p>
       <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium capitalize" :class="estadoInfo.class">
          {{ estadoInfo.text }}
       </span>
     </div>
     <div class="flex items-center gap-x-3" title="Incidencias: Leves / Moderadas / Graves">
        <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-green-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.totalCounts.verde }}</span></div>
        <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-amber-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.totalCounts.ambar }}</span></div>
        <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-red-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.totalCounts.rojo }}</span></div>
    </div>
  </div>

  <div class="lg:col-span-2 flex justify-start lg:justify-end items-center flex-wrap gap-2">
    <button v-if="inspeccion.estado === 'finalizada'" @click="$emit('mark-as-sent', inspeccion)" :disabled="isProcessing" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-blue-700 bg-blue-50 hover:bg-blue-100 border border-blue-200 disabled:opacity-50">
      <PaperAirplaneIcon class="h-4 w-4" /> Marcar Envío
    </button>
    
    <router-link v-if="inspeccion.estado === 'pendiente_subsanacion'" :to="`/inspecciones/${inspeccion.id}/cierre`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-purple-700 bg-purple-50 hover:bg-purple-100 border border-purple-200">
      <ArchiveBoxIcon class="h-4 w-4" /> Cierre
    </router-link>
    
    <router-link :to="`/inspecciones/${inspeccion.id}/plano-preview`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-teal-700 bg-teal-50 hover:bg-teal-100 border border-teal-200">
        <MapIcon class="h-4 w-4"/>Plano
    </router-link>

    <button @click="openArchivedPdf(inspeccion.url_pdf_informe_inicial)" :disabled="!inspeccion.url_pdf_informe_inicial" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-slate-600 bg-slate-100 hover:bg-slate-200 border border-slate-200 disabled:opacity-50 disabled:cursor-not-allowed">
      <ArrowDownCircleIcon class="h-4 w-4" /> Inf. Inicial
    </button>

    <button v-if="inspeccion.estado === 'cerrada'" @click="openArchivedPdf(inspeccion.url_pdf_informe_final)" :disabled="!inspeccion.url_pdf_informe_final" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-green-700 bg-green-100 hover:bg-green-200 border border-green-200 disabled:opacity-50 disabled:cursor-not-allowed">
      <ArrowDownCircleIcon class="h-4 w-4" /> Inf. Cierre
    </button>

    <div class="flex items-center gap-1 border-l pl-2 ml-1">
      <router-link :to="`/inspecciones/${inspeccion.id}`" class="p-2 text-slate-500 hover:text-blue-600" title="Ver/Editar Inspección"><EyeIcon class="h-5 w-5" /></router-link>
      <button v-if="inspeccion.estado !== 'en_progreso'" @click="$emit('reopen', inspeccion)" :disabled="isProcessing" class="p-2 text-slate-500 hover:text-orange-600 disabled:opacity-50" title="Reabrir Inspección">
          <ArrowUturnLeftIcon class="h-5 w-5" />
      </button>
      <button @click="$emit('delete', inspeccion.id)" class="p-2 text-slate-500 hover:text-red-600" title="Borrar Inspección"><TrashIcon class="h-5 w-5" /></button>
    </div>
  </div>
</div>

<div class="px-4 pb-2 text-center">
  <button @click="toggleDetails" class="w-full text-xs font-semibold text-slate-500 hover:text-blue-600 flex items-center justify-center gap-1 py-1 border-t border-slate-200">
    <span>{{ isExpanded ? 'Ocultar Detalles' : 'Mostrar Detalles' }}</span>
    <ChevronDownIcon class="h-4 w-4 transition-transform" :class="{'rotate-180': isExpanded}" />
  </button>
</div>

<div v-if="isExpanded" class="border-t border-slate-200 p-4 bg-slate-50/50">
  <div class="space-y-3">
    <div v-if="inspeccion.details.length === 0" class="text-center text-sm text-slate-500 py-4">
        No hay puntos con incidencias en esta inspección.
    </div>
    <div v-for="sala in inspeccion.details" :key="sala.id" class="bg-white p-3 rounded-md border">
      <div class="flex justify-between items-center mb-2">
        <h4 class="font-bold text-slate-800">{{ sala.nombre }}</h4>
        <div class="flex items-center gap-x-3" title="Incidencias: Leves / Moderadas / Graves">
          <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-green-500"></span><span class="font-bold text-sm text-slate-700">{{ sala.counts.verde }}</span></div>
          <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-amber-500"></span><span class="font-bold text-sm text-slate-700">{{ sala.counts.ambar }}</span></div>
          <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-red-500"></span><span class="font-bold text-sm text-slate-700">{{ sala.counts.rojo }}</span></div>
        </div>
      </div>
      <ul class="divide-y divide-slate-100">
        <li v-for="punto in sala.puntos" :key="punto.id" class="py-1.5 flex justify-between items-center text-sm">
          <span class="text-slate-600">{{ punto.nomenclatura }}</span>
           <div class="flex items-center gap-x-3">
            <div class="flex items-center gap-1.5 w-8 justify-end"><span class="h-2 w-2 rounded-full bg-green-500"></span><span class="font-medium text-xs text-slate-700">{{ punto.counts.verde }}</span></div>
            <div class="flex items-center gap-1.5 w-8 justify-end"><span class="h-2 w-2 rounded-full bg-amber-500"></span><span class="font-medium text-xs text-slate-700">{{ punto.counts.ambar }}</span></div>
            <div class="flex items-center gap-1.5 w-8 justify-end"><span class="h-2 w-2 rounded-full bg-red-500"></span><span class="font-medium text-xs text-slate-700">{{ punto.counts.rojo }}</span></div>
          </div>
        </li>
      </ul>
    </div>
  </div>
</div>
</div>
</template>
--- FIN DEL ARCHIVO: src/components/InspectionListItem.vue ---

--- INICIO DEL ARCHIVO: src/components/InteractiveMap.vue ---
<!-- src/components/InteractiveMap.vue -->
<script setup>
import { ref, watch, onMounted, onUnmounted, nextTick } from 'vue';

const props = defineProps({
  imageUrl: { type: String, required: true },
  points: { type: Array, default: () => [] },
  salas: { type: Array, default: () => [] },
  isReadOnly: { type: Boolean, default: false },
  isPlacementMode: { type: Boolean, default: false },
  isAreaDrawingMode: { type: Boolean, default: false },
  allIncidencias: { type: Array, default: () => [] }
});

const emit = defineEmits(['add-point', 'delete-point', 'update-point-position', 'point-click', 'area-drawn', 'drawing-cancelled', 'image-error']);

const overlayRef = ref(null);
const draggedPointId = ref(null);
const drawingPoints = ref([]);
const mousePosition = ref({ x: 0, y: 0 });
const imageRect = ref({ left: 0, top: 0, width: 0, height: 0 });
const resizeObserver = ref(null);

// ===== INICIO DE LA CORRECCIÓN: Lógica de carga de imagen robusta =====
const imageLoaded = ref(false);

const updateDimensions = () => {
  if (!overlayRef.value || !imageLoaded.value) {
    return;
  }
  const containerEl = overlayRef.value;
  // Buscamos la imagen por su clase dentro del componente
  const imgEl = containerEl.querySelector('img.plano-image');

  if (!imgEl || !imgEl.naturalWidth) return;

  const containerRatio = containerEl.clientWidth / containerEl.clientHeight;
  const imageRatio = imgEl.naturalWidth / imgEl.naturalHeight;
  let imgW, imgH, imgX, imgY;

  if (imageRatio > containerRatio) {
    imgW = containerEl.clientWidth;
    imgH = imgW / imageRatio;
    imgX = 0;
    imgY = (containerEl.clientHeight - imgH) / 2;
  } else {
    imgH = containerEl.clientHeight;
    imgW = imgH * imageRatio;
    imgY = 0;
    imgX = (containerEl.clientWidth - imgW) / 2;
  }

  imageRect.value = {
    left: imgX,
    top: imgY,
    width: imgW,
    height: imgH
  };
  console.log('Image dimensions updated:', imageRect.value);
};

// Esta función se llamará cuando la imagen termine de cargar
const onImageLoad = () => {
  imageLoaded.value = true;
  // Usamos nextTick para asegurar que el DOM está actualizado antes de medir
  nextTick(() => {
    updateDimensions();
  });
};

const handleImageError = () => {
  console.error('Error loading image from Supabase:', props.imageUrl);
  emit('image-error');
};

// Si la URL de la imagen cambia, reseteamos el estado de carga
watch(() => props.imageUrl, () => {
  imageLoaded.value = false;
});
// ===== FIN DE LA CORRECCIÓN =====


const toSvgPoints = (pointsArray) => {
  if (!pointsArray || pointsArray.length === 0 || !imageRect.value.width || !imageRect.value.height) return "";
  return pointsArray.map(p => `${p.x * imageRect.value.width + imageRect.value.left},${p.y * imageRect.value.height + imageRect.value.top}`).join(' ');
};

const handleMapClick = (event) => {
  if (props.isReadOnly || !overlayRef.value || !imageRect.value.width || !imageRect.value.height) {
    return;
  }

  const overlayRect = overlayRef.value.getBoundingClientRect();
  const x = (event.clientX - overlayRect.left - imageRect.value.left) / imageRect.value.width;
  const y = (event.clientY - overlayRect.top - imageRect.value.top) / imageRect.value.height;

  if (props.isAreaDrawingMode) {
    if (drawingPoints.value.length > 2) {
      const firstPoint = drawingPoints.value[0];
      const distance = Math.sqrt(Math.pow((x - firstPoint.x), 2) + Math.pow((y - firstPoint.y), 2));
      if (distance < 0.02) {
        emit('area-drawn', drawingPoints.value);
        drawingPoints.value = [];
        return;
      }
    }
    drawingPoints.value.push({ x, y });
  } else if (props.isPlacementMode) {
    emit('add-point', { x, y });
  }
};

const handleMouseMove = (event) => {
    if (!props.isAreaDrawingMode || !overlayRef.value) return;
    const overlayRect = overlayRef.value.getBoundingClientRect();
    mousePosition.value.x = event.clientX - overlayRect.left;
    mousePosition.value.y = event.clientY - overlayRect.top;
};

const handleKeydown = (e) => {
    if (e.key === 'Escape' && props.isAreaDrawingMode) {
        drawingPoints.value = [];
        emit('drawing-cancelled');
    }
};

onMounted(() => {
  window.addEventListener('keydown', handleKeydown);
  if (overlayRef.value) {
    resizeObserver.value = new ResizeObserver(() => {
      updateDimensions();
    });
    resizeObserver.value.observe(overlayRef.value);
  }
});
onUnmounted(() => {
  window.removeEventListener('keydown', handleKeydown);
  if (resizeObserver.value && overlayRef.value) {
    resizeObserver.value.unobserve(overlayRef.value);
  }
});

const getSalaColor = (salaId) => {
  const sala = props.salas.find(s => s.id === salaId);
  return sala ? sala.color : '#9CA3AF';
};

const startDrag = (point, event) => {
  if (props.isReadOnly) return;
  event.preventDefault();
  draggedPointId.value = point.id;
};

const onDrag = (event) => {
  if (props.isReadOnly || draggedPointId.value === null || !overlayRef.value || !imageRect.value.width || !imageRect.value.height) return;
  event.preventDefault();
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (!point) return;
  const overlayRect = overlayRef.value.getBoundingClientRect();
  point.coordenada_x = (event.clientX - overlayRect.left - imageRect.value.left) / imageRect.value.width;
  point.coordenada_y = (event.clientY - overlayRect.top - imageRect.value.top) / imageRect.value.height;
};

const stopDrag = () => {
  if (draggedPointId.value === null) return;
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (point) {
    emit('update-point-position', point);
  }
  draggedPointId.value = null;
};

const handleDeleteClick = (point) => {
  emit('delete-point', point);
};

const handlePointClick = (point) => {
  if (props.isPlacementMode || props.isAreaDrawingMode) return;
  emit('point-click', point);
};

// Get incident badge data for a point (highest severity and count)
function getPointIncidentBadge(puntoId) {
  const incidents = props.allIncidencias.filter(inc => inc.punto_inspeccionado_id === puntoId);
  if (incidents.length === 0) return null;

  const hasRojo = incidents.some(inc => inc.gravedad === 'rojo');
  const hasAmbar = incidents.some(inc => inc.gravedad === 'ambar');

  return {
    count: incidents.length,
    color: hasRojo ? '#EF4444' : hasAmbar ? '#F59E0B' : '#22C55E',
    severity: hasRojo ? 'rojo' : hasAmbar ? 'ambar' : 'verde',
    shouldPulse: hasRojo // Pulse effect for critical incidents
  };
}
</script>

<template>
  <div
    class="relative w-full h-full"
    @mousemove="onDrag"
    @mouseup="stopDrag"
    @mouseleave="stopDrag"
  >
    <!-- ===== CORRECCIÓN: El overlay ahora contiene la imagen para controlar su carga ===== -->
    <div
      ref="overlayRef"
      class="absolute inset-0"
      :class="{ 'cursor-crosshair': isPlacementMode || isAreaDrawingMode }"
      style="z-index: 20;"
      @click="handleMapClick"
      @mousemove="handleMouseMove"
    >
      <img 
        :src="imageUrl" 
        @load="onImageLoad" 
        @error="handleImageError" 
        class="plano-image w-full h-full object-contain pointer-events-none" 
        alt="Plano del centro"
      >
      
      <!-- Mostramos el contenido SVG y los puntos solo cuando la imagen se ha cargado -->
      <template v-if="imageLoaded">
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none">
          <template v-for="sala in salas" :key="`sala-area-${sala.id}`">
            <polygon
              v-if="sala.area_puntos"
              :points="toSvgPoints(sala.area_puntos)"
              :style="{ fill: `${getSalaColor(sala.id)}33`, stroke: getSalaColor(sala.id), strokeWidth: '2px' }"
            />
          </template>

          <g v-if="isAreaDrawingMode && overlayRef">
            <polyline
              :points="toSvgPoints(drawingPoints)"
              style="fill: none; stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <line
              v-if="drawingPoints.length > 0"
              :x1="drawingPoints[drawingPoints.length - 1].x * imageRect.width + imageRect.left"
              :y1="drawingPoints[drawingPoints.length - 1].y * imageRect.height + imageRect.top"
              :x2="mousePosition.x"
              :y2="mousePosition.y"
              style="stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <circle
              v-for="(point, index) in drawingPoints"
              :key="`drawing-point-${index}`"
              :cx="point.x * imageRect.width + imageRect.left"
              :cy="point.y * imageRect.height + imageRect.top"
              r="5"
              :class="index === 0 ? 'fill-green-500 stroke-white' : 'fill-blue-500 stroke-white'"
              style="stroke-width: 2px;"
            />
          </g>
        </svg>

        <div
           v-for="point in points"
           :key="point.id"
           class="absolute w-8 h-8 -translate-x-1/2 -translate-y-1/2 border-2 border-white rounded-full flex items-center justify-center text-white text-xs font-bold group shadow-lg pointer-events-auto"
           :class="{
             'cursor-grab active:cursor-grabbing': !isReadOnly,
             'cursor-pointer hover:scale-110 transition-transform': isReadOnly
           }"
           :style="{
             left: (point.coordenada_x * imageRect.width + imageRect.left) + 'px',
             top: (point.coordenada_y * imageRect.height + imageRect.top) + 'px',
             backgroundColor: point.color || getSalaColor(point.sala_id)
           }"
           @mousedown.stop="startDrag(point, $event)"
           @click.stop="handlePointClick(point)"
         >
          {{ point.nomenclatura.split('-').pop() || '?' }}

          <!-- Incident count badge -->
          <div
            v-if="getPointIncidentBadge(point.id)"
            class="absolute -top-1 -right-1 w-4 h-4 rounded-full flex items-center justify-center text-[9px] font-bold text-white shadow-lg"
            :class="{ 'animate-pulse': getPointIncidentBadge(point.id).shouldPulse }"
            :style="{ backgroundColor: getPointIncidentBadge(point.id).color }"
          >
            {{ getPointIncidentBadge(point.id).count }}
          </div>

          <button
            v-if="!isReadOnly && (point.estado === 'nuevo' || point.estado === undefined)"
            @click.stop="handleDeleteClick(point)"
            class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 text-white rounded-full text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
            title="Borrar punto"
          >X</button>
        </div>
      </template>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/InteractiveMap.vue ---

--- INICIO DEL ARCHIVO: src/assets/vue.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
--- FIN DEL ARCHIVO: src/assets/vue.svg ---

--- INICIO DEL ARCHIVO: src/views/CentrosListView.vue ---
<!-- src/views/CentrosListView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import {
PlusIcon,
PencilIcon,
ArchiveBoxIcon,
DocumentDuplicateIcon,
MagnifyingGlassIcon,
CalendarDaysIcon,
DocumentChartBarIcon
} from '@heroicons/vue/24/solid';
import CentroFormModal from '../components/CentroFormModal.vue';
import SkeletonLoader from '../components/SkeletonLoader.vue';

const centros = ref([]);
const loading = ref(true);
const isModalOpen = ref(false);
const selectedCentro = ref(null);
const filterZona = ref('');
const searchTerm = ref('');
const zonas = ref([]); // <-- Ahora es reactivo

const getZonaColor = (zona) => {
const colors = {
'Norte': 'bg-sky-100 text-sky-800', 'Levante Norte': 'bg-sky-100 text-sky-800', 'Noroeste': 'bg-sky-100 text-sky-800',
'Sur': 'bg-amber-100 text-amber-800', 'Levante Sur': 'bg-amber-100 text-amber-800', 'Suroeste': 'bg-amber-100 text-amber-800',
'Sureste': 'bg-orange-100 text-orange-800',
'Extremadura-Cord': 'bg-rose-100 text-rose-800',
'Madrid Oeste': 'bg-indigo-100 text-indigo-800', 'Madrid Este y Aragón': 'bg-indigo-100 text-indigo-800',
'Centro': 'bg-slate-100 text-slate-800',
'Cataluña Norte': 'bg-teal-100 text-teal-800', 'Cataluña Sur': 'bg-teal-100 text-teal-800',
'Castilla León': 'bg-lime-100 text-lime-800',
'Baleares-Canarias': 'bg-cyan-100 text-cyan-800',
};
return colors[zona] || 'bg-gray-100 text-gray-800';
};

const filteredCentros = computed(() => {
let results = centros.value;
if (filterZona.value) {
results = results.filter(c => c.zona === filterZona.value);
}
if (searchTerm.value.trim()) {
const searchLower = searchTerm.value.toLowerCase();
results = results.filter(c => c.nombre.toLowerCase().includes(searchLower));
}
return results;
});

const openCreateModal = () => {
selectedCentro.value = null;
isModalOpen.value = true;
};

const openEditModal = (centro) => {
selectedCentro.value = centro;
isModalOpen.value = true;
};

// ===== CAMBIO REALIZADO: Lógica de guardado simplificada y corregida =====
const handleSaveCentro = async (centroData) => {
// Copiamos los datos para no modificar el objeto original
const dataToSave = { ...centroData };

// --- INICIO DE LA CORRECCIÓN ---
// Estas propiedades son calculadas en el cliente y no existen en la tabla 'centros'.
// Debemos eliminarlas antes de intentar guardar los datos en Supabase para evitar el error.
delete dataToSave.numero_informes;
delete dataToSave.ultima_revision;

// Extraer el archivo del logo si existe (propiedad especial)
const logoFile = dataToSave._logoFile;
delete dataToSave._logoFile;
// --- FIN DE LA CORRECCIÓN ---

let error;
let centroId = dataToSave.id;

if (dataToSave.id) {
// --- LÓGICA DE ACTUALIZACIÓN ---
const { id, ...updateData } = dataToSave; // Separamos el id del resto de los datos
const { error: updateError } = await supabase
.from('centros')
.update(updateData)
.eq('id', id);
error = updateError;
} else {
// --- LÓGICA DE CREACIÓN ---
delete dataToSave.id; // Nos aseguramos de que no haya un id (aunque sea null)
const { data: insertData, error: insertError } = await supabase
.from('centros')
.insert(dataToSave)
.select()
.single();
error = insertError;

if (!error && insertData) {
centroId = insertData.id;

// Si hay un logo seleccionado, subirlo ahora que tenemos el ID
if (logoFile) {
const fileName = `cliente_${centroId}/${Date.now()}_${logoFile.name}`;
const { error: uploadError } = await supabase.storage
.from('logos-clientes')
.upload(fileName, logoFile);

if (!uploadError) {
const { data: { publicUrl } } = supabase.storage
.from('logos-clientes')
.getPublicUrl(fileName);

// Actualizar el centro con la URL del logo
await supabase.from('centros')
.update({ url_logo_cliente: publicUrl })
.eq('id', centroId);
}
}
}
}

if (error) {
alert(error.message);
} else {
isModalOpen.value = false;
await fetchCentros(); // Recargamos la lista para ver los cambios
}
};

const fetchCentros = async () => {
loading.value = true;
const { data, error } = await supabase
.from('centros')
.select('*, url_logo_cliente')
.order('nombre');

if (error) {
centros.value = [];
} else if(data) {
const centrosConInspecciones = await Promise.all(data.map(async (centro) => {
const { data: inspecciones, error: inspError } = await supabase
.from('inspecciones')
.select('fecha_inspeccion')
.eq('centro_id', centro.id);

let numero_informes = 0;
let ultima_revision = null;

if (!inspError && inspecciones && inspecciones.length > 0) {
numero_informes = inspecciones.length;
const fechas = inspecciones.map(i => new Date(i.fecha_inspeccion)).sort((a, b) => b - a);
ultima_revision = fechas[0].toLocaleDateString('es-ES');
}

return {
...centro,
numero_informes,
ultima_revision,
};
}));
centros.value = centrosConInspecciones;
}

const { data: zonasData } = await supabase.from('zonas').select('nombre').order('nombre');
if (zonasData) zonas.value = zonasData.map(z => z.nombre);

loading.value = false;
};

onMounted(fetchCentros);
</script>
<template>
<div class="p-4 md:p-8">
<div class="flex flex-col md:flex-row justify-between md:items-center mb-6 gap-4">
<h1 class="text-3xl md:text-4xl font-bold text-slate-800">Maestro de Centros</h1>
<div class="flex items-center gap-x-2 w-full md:w-auto">
<div class="relative flex-grow">
<div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
<MagnifyingGlassIcon class="h-5 w-5 text-slate-400" />
</div>
<input
v-model="searchTerm"
type="search"
placeholder="Buscar..."
class="block w-full rounded-md border-slate-300 py-2 pl-10 text-sm shadow-sm focus:border-blue-500 focus:ring-blue-500"
>
</div>
<select v-model="filterZona" class="rounded-md border-slate-300 shadow-sm text-sm py-2">
<option value="">Todas las Zonas</option>
<option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
</select>
<button @click="openCreateModal" class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm flex-shrink-0">
<PlusIcon class="h-5 w-5" />
<span class="hidden sm:inline">Agregar Centro</span>
</button>
</div>
</div>
<div v-if="loading" class="space-y-4">
  <div v-for="i in 5" :key="i" class="bg-white rounded-xl shadow-sm border border-slate-200 p-4 h-24">
    <SkeletonLoader />
  </div>
</div>

<div v-else class="space-y-4">
  <div v-if="filteredCentros.length === 0" class="p-8 text-center text-slate-500 bg-white rounded-xl shadow-sm border">
    No se han encontrado centros que coincidan con los filtros.
  </div>
  
  <div v-for="centro in filteredCentros" :key="centro.id" class="bg-white rounded-xl shadow-sm border border-slate-200 p-4 transition-all hover:border-blue-400 hover:shadow-md">
    <div class="grid grid-cols-6 md:grid-cols-12 gap-y-4 md:gap-x-6 items-center">
      <div class="col-span-6 md:col-span-4 flex items-center gap-4">
        <div class="flex-shrink-0 w-12 h-12 bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden border">
          <img v-if="centro.url_logo_cliente" :src="centro.url_logo_cliente" class="object-contain h-full w-full" loading="lazy">
          <span v-else class="text-slate-400 text-xs font-semibold">Logo</span>
        </div>
        <div>
          <p class="text-lg font-bold text-slate-900">{{ centro.nombre }}</p>
          <p class="text-sm text-slate-500">{{ centro.direccion }}</p>
        </div>
      </div>
      
      <div class="col-span-3 md:col-span-3 text-sm text-slate-600 space-y-1">
         <div class="flex items-center gap-2">
            <DocumentChartBarIcon class="h-5 w-5 text-slate-400"/>
            <span>Informes: <span class="font-bold text-slate-800">{{ centro.numero_informes }}</span></span>
          </div>
          <div v-if="centro.ultima_revision" class="flex items-center gap-2">
            <CalendarDaysIcon class="h-5 w-5 text-slate-400" />
            <span>Última: <span class="font-semibold text-slate-800">{{ centro.ultima_revision }}</span></span>
          </div>
      </div>

      <div class="col-span-3 md:col-span-2">
        <span :class="['inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium', getZonaColor(centro.zona)]">
          {{ centro.zona }}
        </span>
      </div>
      
      <div class="col-span-6 md:col-span-3 flex items-center justify-start md:justify-end flex-wrap gap-2">
        <button @click="openEditModal(centro)" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <PencilIcon class="h-4 w-4" /> Editar
        </button>
        <router-link :to="`/centros/${centro.id}/historial`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <ArchiveBoxIcon class="h-4 w-4" /> Historial
        </router-link>
        <router-link :to="`/centros/${centro.id}/versiones`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
          <DocumentDuplicateIcon class="h-4 w-4" /> Planos
        </router-link>
      </div>
    </div>
  </div>
</div>

<CentroFormModal :is-open="isModalOpen" :centro="selectedCentro" @close="isModalOpen = false" @save="handleSaveCentro" />
</div>
</template>
--- FIN DEL ARCHIVO: src/views/CentrosListView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroHistorialView.vue ---
<!-- src/views/CentroHistorialView.vue -->
<script setup>
import { ref, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { useInspections } from '../composables/useInspections';
import InspectionListItem from '../components/InspectionListItem.vue';
import MarkAsSentModal from '../components/MarkAsSentModal.vue';

const showNotification = inject('showNotification');
const showConfirm = inject('showConfirm');
const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const {
  loading,
  loadingMore,
  centro,
  inspecciones,
  availableYears,
  hasMorePages,
  loadMore,
  loadInspectionDetails,
  updateInspectionInList,
  removeInspectionFromList
} = useInspections(centroId);

const isProcessing = ref(null);
const isSentModalOpen = ref(false);
const selectedInspeccion = ref(null);
const selectedYear = ref(null);

const filteredInspecciones = computed(() => {
  if (selectedYear.value === null) {
    return inspecciones.value;
  }
  return inspecciones.value.filter(inspeccion => {
    return new Date(inspeccion.fecha_inspeccion).getFullYear() === selectedYear.value;
  });
});

const deleteB2Files = async (urls) => {
  const fileUrls = urls.filter(url => url && url.includes('backblazeb2.com'));
  if (fileUrls.length === 0) {
    return true; // No hay nada que borrar
  }

  showNotification(`Borrando ${fileUrls.length} informe(s) de B2...`, 'info');

  const deletePromises = fileUrls.map(fileUrl => 
    supabase.functions.invoke('delete-b2-file', {
      body: { fileUrl },
    })
  );

  const results = await Promise.all(deletePromises);
  const failedDeletes = results.filter(res => res.error);

  if (failedDeletes.length > 0) {
    console.error('Errores al borrar archivos de B2:', failedDeletes);
    showNotification(`Error al borrar ${failedDeletes.length} archivo(s) de B2. Revisa la consola.`, 'error');
  } else {
    showNotification('Informe(s) borrado(s) de B2 con éxito.', 'success');
  }
  
  return true;
};

const openSentModal = (inspeccion) => {
  selectedInspeccion.value = inspeccion;
  isSentModalOpen.value = true;
};

const handleMarkAsSent = async (formData) => {
  if (!selectedInspeccion.value) return;
  
  isProcessing.value = selectedInspeccion.value.id;
  isSentModalOpen.value = false;

  try {
    const { data, error } = await supabase
      .from('inspecciones')
      .update({ 
        fecha_envio_cliente: formData.fecha_envio, 
        responsable_envio_cliente: formData.responsable_envio,
        estado: 'pendiente_subsanacion'
      })
      .eq('id', selectedInspeccion.value.id)
      .select()
      .single();

    if (error) throw error;
    
    // Invalidamos la caché de localStorage para forzar la recarga de datos frescos.
    localStorage.removeItem(`inspections_${centroId}`);

    updateInspectionInList(data);
    showNotification('Registro de envío guardado con éxito.', 'success');
  } catch (error) {
    showNotification('Error al registrar el envío: ' + error.message, 'error');
  } finally {
    isProcessing.value = null;
  }
};

const reabrirInspeccion = async (inspeccion) => {
  const confirmed = await showConfirm('Reabrir Inspección', `¿Estás seguro de que quieres reabrir la inspección del ${new Date(inspeccion.fecha_inspeccion).toLocaleDateString()}? El PDF archivado será invalidado y eliminado de B2.`);
  if (!confirmed) return;
  
  isProcessing.value = inspeccion.id;
  
  try {
    await deleteB2Files([inspeccion.url_pdf_informe_inicial, inspeccion.url_pdf_informe_final]);

    const { data, error } = await supabase
      .from('inspecciones')
      .update({
        estado: 'en_progreso',
        url_pdf_informe_inicial: null,
        url_pdf_informe_final: null
      })
      .eq('id', inspeccion.id)
      .select()
      .single();

    if (error) throw error;
    
    // Invalidamos la caché de localStorage para forzar la recarga de datos frescos.
    localStorage.removeItem(`inspections_${centroId}`);

    updateInspectionInList(data);
    showNotification('Inspección reabierta. Ahora puedes editarla de nuevo.', 'success');
  } catch (error) {
    showNotification('Error al reabrir la inspección: ' + error.message, 'error');
  } finally {
    isProcessing.value = null;
  }
}

const handleDelete = async (inspeccionId) => {
  const confirmed = await showConfirm('Borrar Inspección', '¿Estás seguro? Esta acción es permanente y eliminará todos los datos y archivos asociados.');
  if (!confirmed) return;

  isProcessing.value = inspeccionId;
  
  try {
    const inspeccion = inspecciones.value.find(i => i.id === inspeccionId);
    if (!inspeccion) throw new Error("No se encontró la inspección para borrar sus archivos.");

    await deleteB2Files([inspeccion.url_pdf_informe_inicial, inspeccion.url_pdf_informe_final]);

    showNotification('Borrando fotos, por favor espera...', 'info');
    const { error: functionError } = await supabase.functions.invoke('delete-inspection-files', {
      body: { inspeccion_id: inspeccionId },
    });
    if (functionError) {
      const continueDelete = await showConfirm('Error', `No se pudieron borrar las fotos: ${functionError.message}. ¿Continuar borrando los datos?`);
      if (!continueDelete) { isProcessing.value = null; return; }
    }
    
    showNotification('Borrando datos de la base de datos...', 'info');
    const { error: rpcError } = await supabase.rpc('delete_inspection_data', {
      inspeccion_id_param: inspeccionId
    });
    if (rpcError) throw rpcError;

    // Invalidamos la caché de localStorage para forzar la recarga de datos frescos.
    localStorage.removeItem(`inspections_${centroId}`);

    removeInspectionFromList(inspeccionId);
    showNotification('Inspección borrada con éxito.', 'success');

  } catch (error) {
    showNotification('Ocurrió un error al borrar la inspección: ' + error.message, 'error');
  } finally {
    isProcessing.value = null;
  }
};


const handleDateUpdated = ({ id, newDate }) => {
  const inspeccion = inspecciones.value.find(i => i.id === id);
  if (inspeccion) {
    inspeccion.fecha_inspeccion = newDate;
  }
};
</script>

<template>
  <div class="p-4 md:p-8">
    <div v-if="loading" class="text-center p-10">Cargando historial...</div>
    <div v-else-if="centro">
      <div class="flex flex-col md:flex-row justify-between md:items-center mb-4 gap-4">
        <div>
          <h1 class="text-3xl md:text-4xl font-bold text-slate-800">Historial de Inspecciones</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <button @click="router.push('/centros')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50 self-start md:self-center">Volver</button>
      </div>

      <div v-if="availableYears.length > 0" class="mb-6 pb-4 border-b border-slate-200">
        <h3 class="text-sm font-semibold text-slate-500 mb-2">Filtrar por año:</h3>
        <div class="flex flex-wrap gap-2">
          <button 
            @click="selectedYear = null"
            :class="['px-3 py-1 text-sm font-semibold rounded-full transition-colors', selectedYear === null ? 'bg-blue-600 text-white shadow' : 'bg-slate-200 text-slate-700 hover:bg-slate-300']">
            Todos
          </button>
          <button 
            v-for="year in availableYears" 
            :key="year"
            @click="selectedYear = year"
            :class="['px-3 py-1 text-sm font-semibold rounded-full transition-colors', selectedYear === year ? 'bg-blue-600 text-white shadow' : 'bg-slate-200 text-slate-700 hover:bg-slate-300']">
            {{ year }}
          </button>
        </div>
      </div>

      <div class="space-y-4">
        <div v-if="filteredInspecciones.length === 0" class="p-8 text-center text-slate-500 bg-white rounded-xl shadow-sm border">
          No hay inspecciones para el año seleccionado.
        </div>
        
        <InspectionListItem
          v-for="inspeccion in filteredInspecciones"
          :key="inspeccion.id"
          :inspeccion="inspeccion"
          :is-processing="isProcessing === inspeccion.id"
          @mouseenter="loadInspectionDetails(inspeccion.id)"
          @mark-as-sent="openSentModal"
          @reopen="reabrirInspeccion"
          @delete="handleDelete"
          @date-updated="handleDateUpdated"
        />

        <div v-if="hasMorePages && !loadingMore" class="text-center py-4">
          <button @click="loadMore" class="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 font-semibold">
            Cargar más inspecciones
          </button>
        </div>
        <div v-if="loadingMore" class="text-center py-4">
          <div class="inline-flex items-center gap-2 text-slate-600">
            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            Cargando más inspecciones...
          </div>
        </div>
      </div>
    </div>
    <MarkAsSentModal :is-open="isSentModalOpen" :inspeccion-id="selectedInspeccion?.id" @close="isSentModalOpen = false" @save="handleMarkAsSent" />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroHistorialView.vue ---

--- INICIO DEL ARCHIVO: src/views/CierreInformeView.vue ---
<!-- src/views/CierreInformeView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';
import { generateTextReport } from '../utils/pdf';
import { ArrowUpTrayIcon, CheckCircleIcon, TrashIcon } from '@heroicons/vue/24/solid';

const showNotification = inject('showNotification');
const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const isFinalizing = ref(false);
const inspeccion = ref(null);
const incidencias = ref([]);
const isUploading = ref(null);
const dragOverIncidenceId = ref(null);

onMounted(async () => {
  loading.value = true;
  const { data: inspectionData } = await supabase.from('inspecciones').select('*, centros(nombre, id)').eq('id', inspeccionId).single();
  inspeccion.value = inspectionData;
  const { data: incidenciasData } = await supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId).neq('item_checklist', 2).order('item_checklist', { ascending: true });
  incidencias.value = incidenciasData || [];
  loading.value = false;
});

const getItemText = (itemId) => {
  const item = checklistItems.find(i => i.id === itemId);
  return item ? `${item.id}. ${item.text}` : 'Item desconocido';
};

const onDragOver = (event, incidenceId) => {
  event.preventDefault();
  dragOverIncidenceId.value = incidenceId;
};

const onDragLeave = (event) => {
  event.preventDefault();
  dragOverIncidenceId.value = null;
};

const onDrop = (event, incidencia) => {
  event.preventDefault();
  dragOverIncidenceId.value = null;
  const files = event.dataTransfer.files;
  if (files.length === 0) return;
  if (files.length > 1) {
    showNotification('Solo se permite subir una foto a la vez.', 'error');
    return;
  }
  const file = files[0];
  handleFileUpload(file, incidencia);
};
const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;
  handleFileUpload(file, incidencia);
};

const handleFileUpload = async (file, incidencia) => {
  // Validations
  if (!file.type.startsWith('image/')) {
    showNotification('Solo se permiten archivos de imagen.', 'error');
    return;
  }
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    showNotification('El archivo es demasiado grande. Máximo 10MB.', 'error');
    return;
  }

  isUploading.value = incidencia.id;

  try {
    // Compress image if it's large
    let fileToUpload = file;
    const originalSize = file.size;

    if (file.size > 500 * 1024) { // Compress if larger than 500KB
      showNotification('Comprimiendo imagen...', 'info');

      // Use canvas API for compression
      const compressedFile = await compressImage(file);
      fileToUpload = compressedFile;

      const compressionRatio = ((originalSize - compressedFile.size) / originalSize * 100).toFixed(1);
      if (compressionRatio > 5) {
        showNotification(`Imagen comprimida: ${compressionRatio}% de reducción`, 'success');
      }
    }

    // Cambiamos el nombre de la carpeta para mantener consistencia
    const fileName = `cierre_informe_${inspeccionId}/incidencia_${incidencia.id}/${Date.now()}_${file.name}`;
    const { error: uploadError } = await supabase.storage.from('incidencias').upload(fileName, fileToUpload, { upsert: true });
    if (uploadError) {
      showNotification("Error al subir la foto: " + uploadError.message, 'error');
      isUploading.value = null;
      return;
    }
    const { data: { publicUrl } } = supabase.storage.from('incidencias').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('incidencias').update({ url_foto_despues: publicUrl }).eq('id', incidencia.id);
    if (updateError) {
      showNotification("Error al guardar la URL: " + updateError.message, 'error');
    } else {
      incidencia.url_foto_despues = publicUrl;
      showNotification('Foto subida correctamente.', 'success');
    }
    isUploading.value = null;
  } catch (error) {
    console.error('Error processing image:', error);
    showNotification('Error al procesar la imagen: ' + error.message, 'error');
    isUploading.value = null;
  }
};

// Compress image using Canvas API
const compressImage = (file) => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    img.onload = () => {
      // Calculate new dimensions (max 1024px on longest side for smaller files)
      let { width, height } = img;
      const maxDimension = 1024;

      if (width > height) {
        if (width > maxDimension) {
          height = (height * maxDimension) / width;
          width = maxDimension;
        }
      } else {
        if (height > maxDimension) {
          width = (width * maxDimension) / height;
          height = maxDimension;
        }
      }

      canvas.width = width;
      canvas.height = height;

      // Draw and compress with lower quality for much smaller files
      ctx.drawImage(img, 0, 0, width, height);

      canvas.toBlob((blob) => {
        if (blob) {
          // Create a new file with the compressed blob
          const compressedFile = new File([blob], file.name, {
            type: 'image/jpeg',
            lastModified: Date.now()
          });
          resolve(compressedFile);
        } else {
          reject(new Error('Failed to compress image'));
        }
      }, 'image/jpeg', 0.6); // 60% quality for smaller file sizes
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
};

const deletePhoto = async (incidencia) => {
  if (!incidencia.url_foto_despues) return;

  if (!confirm('¿Estás seguro de que quieres eliminar esta foto de corrección?')) {
    return;
  }

  try {
    // Extract file path from URL
    const url = new URL(incidencia.url_foto_despues);
    const pathParts = url.pathname.split('/');
    // Find the index after 'incidencias' bucket
    const bucketIndex = pathParts.findIndex(part => part === 'incidencias');
    const filePath = pathParts.slice(bucketIndex + 1).join('/');

    // Delete from storage
    const { error: storageError } = await supabase.storage.from('incidencias').remove([filePath]);
    if (storageError) {
      console.error('Storage deletion error:', storageError);
      showNotification('Advertencia: Error al eliminar del almacenamiento, pero se actualizó la base de datos.', 'warning');
      // Continue with DB update even if storage deletion fails
    }

    // Update database
    const { error: dbError } = await supabase.from('incidencias').update({ url_foto_despues: null }).eq('id', incidencia.id);
    if (dbError) {
      showNotification('Error al actualizar la base de datos: ' + dbError.message, 'error');
      return;
    }

    // Update local state
    incidencia.url_foto_despues = null;
    showNotification('Foto eliminada correctamente.', 'success');
  } catch (error) {
    console.error('Error deleting photo:', error);
    showNotification('Error al eliminar la foto: ' + error.message, 'error');
  }
};

const todasSubsanadas = computed(() => {
  if (incidencias.value.length === 0) return true;
  return incidencias.value.every(inc => !!inc.url_foto_despues);
});

function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      const dataUrl = reader.result;
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    reader.readAsDataURL(blob);
  });
}

const finalizarInforme = async () => {
  if (!confirm('¿Estás seguro de que quieres generar el Informe de Cierre, archivarlo y cerrar esta inspección?')) {
      return;
  }
  isFinalizing.value = true;
  try {
    // Llamamos a generateTextReport con el tipo 'remediation' que internamente genera el informe de cierre
    const report = await generateTextReport(inspeccionId, 'remediation', 'blob');
    if (!report || !report.blob) throw new Error("La generación del PDF de Cierre falló.");

    const base64File = await blobToBase64(report.blob);

    const centroId = inspeccion.value.centros.id;
    const fileNameWithId = `${inspeccionId}-${report.fileName}`;
    const finalFileName = `centro_${centroId}/${fileNameWithId}`;

    const { data, error: invokeError } = await supabase.functions.invoke('upload-pdf-to-b2', {
      body: { 
        file: base64File,
        fileName: finalFileName,
        contentType: 'application/pdf'
      }
    });

    if (invokeError) throw new Error(`Error al contactar con la función Edge: ${invokeError.message}.`);
    if (data.error) throw new Error(data.error);
    if (!data.publicUrl) throw new Error('La función Edge no devolvió una URL válida.');
    
    const publicUrl = data.publicUrl;
    
    const { error: updateError } = await supabase.from('inspecciones').update({ estado: 'cerrada', url_pdf_informe_final: publicUrl }).eq('id', inspeccionId);
    if (updateError) throw updateError;
    
    showNotification('Inspección cerrada y archivada con éxito.');
    router.push(`/centros/${inspeccion.value.centros.id}/historial`);
  } catch (error) {
    console.error("Error al finalizar el informe de cierre:", error);
    showNotification('Ocurrió un error al finalizar: ' + error.message, 'error');
  } finally {
    isFinalizing.value = false;
  }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex items-center justify-center">Cargando datos del informe...</div>
    <div v-else-if="inspeccion" class="flex-1 flex flex-col min-h-0">
      <header class="flex-shrink-0 px-4 sm:px-8 pt-6 sm:pt-8 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 class="text-2xl sm:text-3xl font-bold text-slate-800">Generar Informe de Cierre</h1>
            <p class="text-lg text-slate-600 mt-1">{{ inspeccion.centros.nombre }}</p>
            <p class="text-sm text-slate-500 mt-1">Inspección del {{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</p>
          </div>
          <div class="flex gap-4 w-full sm:w-auto">
            <button @click="router.go(-1)" class="flex-1 sm:flex-none px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Volver</button>
            <button @click="finalizarInforme" :disabled="!todasSubsanadas || isFinalizing" class="flex-1 sm:flex-none flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
              <CheckCircleIcon class="h-5 w-5" />
              {{ isFinalizing ? 'Finalizando...' : 'Finalizar y Cerrar' }}
            </button>
          </div>
        </div>
      </header>
      <main class="flex-1 overflow-y-auto p-4 sm:p-8">
        <div class="space-y-6 max-w-7xl mx-auto">
          <div v-if="incidencias.length === 0" class="bg-white p-8 rounded-lg shadow-sm text-center">
              <h3 class="text-lg font-medium text-slate-700">¡No hay incidencias que corregir!</h3>
              <p class="text-slate-500">Esta inspección no tiene incidencias que requieran una foto de corrección. Puedes cerrarla directamente.</p>
          </div>
          <div v-for="incidencia in incidencias" :key="incidencia.id" class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 class="font-bold text-lg text-slate-800 border-b pb-3 mb-4">{{ getItemText(incidencia.item_checklist) }}</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">ANTES (Incidencia Original)</p>
                <div class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden">
                  <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="w-full h-full object-contain">
                  <p v-else class="text-slate-500 text-sm p-4">No se adjuntó foto de la incidencia.</p>
                </div>
                <div v-if="incidencia.observaciones" class="mt-3 text-sm bg-slate-50 p-3 rounded-md">
                  <strong>Observaciones:</strong> {{ incidencia.observaciones }}
                </div>
              </div>
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">DESPUÉS (Evidencia de Corrección)</p>
                <div
                  class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden relative group transition-colors"
                  :class="{ 'bg-blue-200 border-2 border-blue-400 border-dashed': dragOverIncidenceId === incidencia.id }"
                  @dragover="onDragOver($event, incidencia.id)"
                  @dragleave="onDragLeave"
                  @drop="onDrop($event, incidencia)"
                >
                  <img v-if="incidencia.url_foto_despues" :src="incidencia.url_foto_despues" class="w-full h-full object-contain">
                  <div v-else-if="isUploading === incidencia.id" class="text-center text-slate-600">Subiendo foto...</div>
                  <div v-else class="text-center">
                    <p v-if="dragOverIncidenceId === incidencia.id" class="text-sm text-slate-600">Suelta la foto aquí</p>
                    <label v-else :for="'fileInput-' + incidencia.id" class="cursor-pointer flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                      <ArrowUpTrayIcon class="h-4 w-4" />
                      Subir Foto
                    </label>
                    <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id" accept="image/*">
                  </div>
                   <div v-if="incidencia.url_foto_despues" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                     <div class="flex gap-4">
                       <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInputChange-' + incidencia.id" accept="image/*">
                       <label :for="'fileInputChange-' + incidencia.id" class="cursor-pointer text-white font-semibold">Cambiar Foto</label>
                       <button @click="deletePhoto(incidencia)" class="text-white font-semibold hover:text-red-300 flex items-center gap-1">
                         <TrashIcon class="h-4 w-4" />
                         Eliminar
                       </button>
                     </div>
                   </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CierreInformeView.vue ---

--- INICIO DEL ARCHIVO: src/views/InspeccionDetailView.vue ---
<!-- src/views/InspeccionDetailView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import ChecklistModal from '../components/ChecklistModal.vue';
import InspectionSidebar from '../components/InspectionSidebar.vue';
import GlobalStatusIndicator from '../components/GlobalStatusIndicator.vue';
import { CheckCircleIcon, InformationCircleIcon, MapIcon, PlusIcon, PencilSquareIcon, ArrowLeftIcon, ListBulletIcon, Bars3Icon } from '@heroicons/vue/24/solid';
import { generateTextReport } from '../utils/pdf';
import SkeletonLoader from '../components/SkeletonLoader.vue';
import { addToQueue, processQueue, syncQueue, waitForQueueToEmpty } from '../utils/syncQueue';

const showNotification = inject('showNotification');
const showConfirm = inject('showConfirm');
const toggleSidebar = inject('toggleSidebar', null);
const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const isFinalizing = ref(false);
const inspeccion = ref(null);
const centro = ref(null);
const version = ref(null);
const salas = ref([]);
const puntosMaestros = ref([]);
const puntosInspeccionados = ref([]);
const isModalOpen = ref(false);
const selectedPunto = ref(null);
const allIncidencias = ref([]);
const allCustomFields = ref([]);
const isPlacementMode = ref(false);
const newPointSalaId = ref(null);
const isAreaDrawingMode = ref(false);
const salaParaDibujar = ref(null);
const isPlanoEditingMode = ref(false);
const isMobileAddPointOpen = ref(false);
const showMapInMobile = ref(false);

const canEditInspection = computed(() => {
  return inspeccion.value?.estado === 'en_progreso';
});

// --- INICIO DE LA CORRECCIÓN: Nueva propiedad computada para la validación ---
const existingIdentifiersInSala = computed(() => {
  if (!selectedPunto.value) return [];
  
  // 1. Encontrar el punto maestro correspondiente al punto de inspección seleccionado.
  const puntoMaestroSeleccionado = puntosMaestros.value.find(pm => pm.id === selectedPunto.value.punto_maestro_id);
  if (!puntoMaestroSeleccionado) return [];

  const salaId = puntoMaestroSeleccionado.sala_id;

  // 2. Obtener todos los puntos maestros de esa misma sala.
  return puntosMaestros.value
    .filter(pm => 
      // Que pertenezcan a la misma sala
      pm.sala_id === salaId && 
      // Y que no sea el punto que estamos editando actualmente
      pm.id !== puntoMaestroSeleccionado.id
    )
    .map(pm => pm.nomenclatura.split('-').pop() || ''); // 3. Extraer solo el identificador final (ej: "10", "Picking-A").
});
// --- FIN DE LA CORRECCIÓN ---


const refreshInspectedPoints = async () => {
  if (!navigator.onLine) {
    return;
  }
  const { data: updatedPoints, error: pointsError } = await supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId);
  if (pointsError) {
    showNotification('Error al refrescar los datos de los puntos.', 'error');
  } else {
    puntosInspeccionados.value = updatedPoints || [];
  }
  
  const { data: updatedIncidencias, error: incidenciasError } = await supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId);
  if (incidenciasError) {
      showNotification('Error al refrescar las incidencias.', 'error');
  } else {
      allIncidencias.value = updatedIncidencias || [];
  }
};

const loadAllData = async () => {
  loading.value = true;
  
  const { data: inspectionData, error: inspectionError } = await supabase
    .from('inspecciones')
    .select('*, centros(*), versiones_plano(*)')
    .eq('id', inspeccionId)
    .single();

  if (inspectionError || !inspectionData) {
    showNotification('Error crítico: No se pudo cargar la inspección.', 'error');
    loading.value = false;
    return;
  }
  
  inspeccion.value = inspectionData;
  centro.value = inspectionData.centros;
  version.value = inspectionData.versiones_plano;

  if (!version.value) {
      showNotification('Error: La inspección no tiene una versión de plano asociada.', 'error');
      loading.value = false;
      return;
  }
  
  const [salasRes, puntosMaestrosRes, puntosInspeccionadosRes, incidenciasRes, customFieldsRes] = await Promise.all([
    supabase.from('salas').select('*').eq('version_id', version.value.id).order('nombre'),
    supabase.from('puntos_maestros').select('*').eq('version_id', version.value.id),
    supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId),
    supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId),
    supabase.from('checklist_custom_fields').select('*').order('point_id, id')
  ]);
  
  salas.value = salasRes.data || [];
  puntosMaestros.value = puntosMaestrosRes.data || [];
  puntosInspeccionados.value = puntosInspeccionadosRes.data || [];
  allIncidencias.value = incidenciasRes.data || [];
  allCustomFields.value = customFieldsRes.data || [];

  await initializeInspectionPoints();

  loading.value = false;
};

const initializeInspectionPoints = async () => {
  if (canEditInspection.value && puntosInspeccionados.value.length === 0 && puntosMaestros.value.length > 0) {
    if (!navigator.onLine) {
        showNotification("Se necesita conexión a internet para iniciar una inspección por primera vez.", "warning", 5000);
        return;
    }
    const pointsToCreate = puntosMaestros.value.map(pm => ({
      inspeccion_id: inspeccionId, punto_maestro_id: pm.id, nomenclatura: pm.nomenclatura,
      coordenada_x: pm.coordenada_x, coordenada_y: pm.coordenada_y,
      estado: 'existente', tiene_placa_caracteristicas: true
    }));
    if (pointsToCreate.length > 0) {
      const { data: newPoints, error } = await supabase.from('puntos_inspeccionados').insert(pointsToCreate).select();
      if (newPoints) {
        puntosInspeccionados.value = newPoints;
      }
      if(error) {
        showNotification('Error al inicializar los puntos de la inspección.', 'error');
      }
    }
  }
};

onMounted(loadAllData);

const getSalaColor = (salaId) => salas.value.find(s => s.id === salaId)?.color || '#9CA3AF';

const puntosParaMostrar = computed(() => {
  return puntosInspeccionados.value.map(pi => {
    const maestro = puntosMaestros.value.find(pm => pm.id === pi.punto_maestro_id);
    return { ...pi, sala_id: maestro?.sala_id, color: getSalaColor(maestro?.sala_id) };
  });
});

const puntosAgrupadosPorSala = computed(() => {
  return salas.value.map(sala => ({
    ...sala,
    puntos: puntosParaMostrar.value
      .filter(p => p.sala_id === sala.id)
      .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}))
  })).filter(g => g.puntos.length > 0 || g.isNew);
});

const incidenciasDelPuntoSeleccionado = computed(() => {
    if (!selectedPunto.value) return [];
    return allIncidencias.value.filter(inc => inc.punto_inspeccionado_id === selectedPunto.value.id);
});

const handleIncidenciasUpdate = (nuevasIncidenciasDelPunto) => {
  if (!selectedPunto.value) return;

  const otrasIncidencias = allIncidencias.value.filter(
    inc => inc.punto_inspeccionado_id !== selectedPunto.value.id
  );

  allIncidencias.value = [...otrasIncidencias, ...nuevasIncidenciasDelPunto];
};

const createNewPointAt = async (coords, salaId) => {
  const salaSeleccionada = salas.value.find(s => s.id === salaId);
  const puntosDeLaSala = puntosMaestros.value.filter(p => p.sala_id === salaId);
  const ultimoNumero = Math.max(0, ...puntosDeLaSala.map(p => {
      const num = parseInt(p.nomenclatura.split('-').pop());
      return isNaN(num) ? 0 : num;
  }));
  const nuevaNomenclatura = `${salaSeleccionada.nombre}-${ultimoNumero + 1}`;

  const tempMaestroId = `temp_maestro_${Date.now()}`;
  const nuevoPuntoMaestro = {
    id: tempMaestroId, version_id: version.value.id, sala_id: salaId, 
    nomenclatura: nuevaNomenclatura, coordenada_x: coords.x, coordenada_y: coords.y
  };
  const tempInspeccionadoId = `temp_inspeccionado_${Date.now()}`;
  const nuevoPuntoIns = {
    id: tempInspeccionadoId, inspeccion_id: inspeccionId, punto_maestro_id: tempMaestroId,
    nomenclatura: nuevaNomenclatura, coordenada_x: coords.x, coordenada_y: coords.y,
    estado: 'nuevo', tiene_placa_caracteristicas: true
  };

  puntosMaestros.value.push(nuevoPuntoMaestro);
  puntosInspeccionados.value.push(nuevoPuntoIns);

  const { id: idM, ...payloadM } = nuevoPuntoMaestro;
  addToQueue({ table: 'puntos_maestros', type: 'insert', tempId: tempMaestroId, payload: payloadM });

  const { id: idI, ...payloadI } = nuevoPuntoIns;
  addToQueue({ table: 'puntos_inspeccionados', type: 'insert', tempId: tempInspeccionadoId, payload: payloadI });

  const tempIncidenciaId = `temp_incidencia_${Date.now()}`;
  const nuevaIncidencia = {
      id: tempIncidenciaId, inspeccion_id: inspeccionId, punto_inspeccionado_id: tempInspeccionadoId,
      item_checklist: 3, gravedad: 'ambar', observaciones: 'Alineación de nueva implantación.'
  };
  allIncidencias.value.push(nuevaIncidencia);

  const { id: idInc, ...payloadInc } = nuevaIncidencia;
  addToQueue({ table: 'incidencias', type: 'insert', tempId: tempIncidenciaId, payload: payloadInc });

  showNotification(`Punto ${nuevaNomenclatura} añadido localmente.`, 'success', 1500);
};

const openChecklistFor = (punto) => {
  if (isPlacementMode.value || isAreaDrawingMode.value) return;
  selectedPunto.value = punto; 
  isModalOpen.value = true;
};
const updatePuntoEstado = async (punto, nuevoEstado) => {
  const puntoEnArray = puntosInspeccionados.value.find(p => p.id === punto.id);
  if(puntoEnArray) puntoEnArray.estado = nuevoEstado;
  addToQueue({
      table: 'puntos_inspeccionados', type: 'update', id: punto.id, payload: { estado: nuevoEstado }
  });
};
const handleDeleteNewPoint = async (punto) => {
  if (!canEditInspection.value) return;
  if(!navigator.onLine){ showNotification("Necesitas conexión para borrar un punto.", "warning"); return; }
  if (confirm(`¿Estás seguro de que quieres borrar permanentemente el punto "${punto.nomenclatura}"?`)) {
      const { error: inspError } = await supabase.from('puntos_inspeccionados').delete().eq('id', punto.id);
      if (inspError) { showNotification("Error al borrar el punto de la inspección: " + inspError.message, 'error'); return; }
      const { error: maestroError } = await supabase.from('puntos_maestros').delete().eq('id', punto.punto_maestro_id);
      if (maestroError) { showNotification("Advertencia: No se pudo borrar el punto del plano maestro.", 'error'); }
      puntosInspeccionados.value = puntosInspeccionados.value.filter(p => p.id !== punto.id);
      puntosMaestros.value = puntosMaestros.value.filter(p => p.id !== punto.punto_maestro_id);
      allIncidencias.value = allIncidencias.value.filter(i => i.punto_inspeccionado_id !== punto.id);
      showNotification(`Punto ${punto.nomenclatura} borrado con éxito.`);
  }
};
const handleTogglePlanoEditing = (isActive) => {
  isPlanoEditingMode.value = isActive;
  if (!isActive) {
    isAreaDrawingMode.value = false;
    salaParaDibujar.value = null;
  }
};

// Función para manejar el toggle desde el header móvil
const toggleMobilePlanoEditing = () => {
  isPlanoEditingMode.value = !isPlanoEditingMode.value;
  handleTogglePlanoEditing(isPlanoEditingMode.value);
};

// Función para hacer toggle del mapa en móvil
const toggleMapInMobile = () => {
  showMapInMobile.value = !showMapInMobile.value;
  // Si estamos mostrando el mapa, desactivamos el modo de agregar puntos
  if (showMapInMobile.value) {
    isMobileAddPointOpen.value = false;
  }
};
const handleAddSala = async (name) => {
    if(!navigator.onLine){ showNotification("Necesitas conexión para añadir salas.", "warning"); return; }
    const { data: newSala, error } = await supabase.from('salas').insert({ version_id: version.value.id, nombre: name, color: '#808080' }).select().single();
    if (error) { showNotification('Error al crear la sala: ' + error.message, 'error'); return; }
    newSala.isNew = true;
    salas.value.push(newSala);
    salas.value.sort((a,b) => a.nombre.localeCompare(b.nombre));
    showNotification(`Sala "${name}" creada en el plano.`, 'success');
    handleStartAreaDrawing(newSala);
};
const handleStartAreaDrawing = (sala) => {
    salaParaDibujar.value = sala;
    isAreaDrawingMode.value = true;
    showNotification(`Modo dibujo activado para "${sala.nombre}". Haz clic en el mapa para definir su área.`, 'success', 4000);
};
const handleAreaDrawn = (points) => {
    const salaInArray = salas.value.find(s => s.id === salaParaDibujar.value.id);
    if (salaInArray) salaInArray.area_puntos = points;
    addToQueue({ table: 'salas', type: 'update', id: salaParaDibujar.value.id, payload: { area_puntos: points } });
    showNotification(`Área de "${salaParaDibujar.value.nombre}" guardada localmente.`, 'success');
    isAreaDrawingMode.value = false;
    salaParaDibujar.value = null;
};
const handleDrawingCancelled = () => {
    isAreaDrawingMode.value = false;
    salaParaDibujar.value = null;
    showNotification('Dibujo cancelado.', 'success', 2000);
};
const handleStartPlacementMode = (salaId) => {
  isPlacementMode.value = true;
  newPointSalaId.value = salaId;
};
const handleCancelPlacementMode = () => {
  isPlacementMode.value = false;
  newPointSalaId.value = null;
};
const handleMapClick = (coords) => {
  if (isPlacementMode.value) { createNewPointAt(coords, newPointSalaId.value); }
};

// --- INICIO DE LA CORRECCIÓN: Función simplificada sin validación ---
const handleUpdatePointNomenclatura = async (puntoMaestro, newNomenclature) => {
    // La validación ahora ocurre dentro del modal, por lo que aquí simplemente confiamos y procedemos.
    const puntoInspeccionado = puntosInspeccionados.value.find(pi => pi.punto_maestro_id === puntoMaestro.id);
    if (!puntoInspeccionado) { 
      showNotification('Error interno: no se encontró el punto de inspección correspondiente.', 'error'); 
      return; 
    }

    // Actualizamos el estado local para reflejar el cambio inmediatamente en la UI.
    const maestro = puntosMaestros.value.find(p => p.id === puntoMaestro.id);
    if (maestro) maestro.nomenclatura = newNomenclature;
    if (puntoInspeccionado) puntoInspeccionado.nomenclatura = newNomenclature;

    // Encolamos las acciones para sincronizarlas con la base de datos.
    addToQueue({ table: 'puntos_maestros', type: 'update', id: puntoMaestro.id, payload: { nomenclatura: newNomenclature } });
    addToQueue({ table: 'puntos_inspeccionados', type: 'update', id: puntoInspeccionado.id, payload: { nomenclatura: newNomenclature } });
    
    showNotification('Nombre del punto actualizado localmente.', 'success');
};
// --- FIN DE LA CORRECCIÓN ---

function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      const dataUrl = reader.result;
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    reader.readAsDataURL(blob);
  });
}
const finalizarInspeccion = async () => {
    if(!navigator.onLine){ showNotification("Necesitas conexión para finalizar y generar el PDF.", "error"); return; }
    const confirmed = await showConfirm('Finalizar Inspección', '¿Estás seguro de que quieres finalizar esta inspección? Se generará y archivará el informe PDF, y la inspección quedará bloqueada.');
    if (!confirmed) return;
    isFinalizing.value = true;
    try {
        // Wait for sync queue to be processed before generating PDF
        if (syncQueue.value.length > 0) {
            showNotification(`Sincronizando ${syncQueue.value.length} cambios pendientes...`, 'info', 3000);

            try {
                // Trigger queue processing
                await processQueue();
                // Wait for queue to be completely empty
                await waitForQueueToEmpty();
                showNotification('Sincronización completa', 'success', 2000);
            } catch (syncError) {
                console.error('Error during sync:', syncError);
                const continueAnyway = await showConfirm(
                    'Error de sincronización',
                    `No se pudieron sincronizar todos los cambios: ${syncError.message}\n\n¿Deseas continuar de todos modos? El PDF podría no incluir todos los cambios offline.`
                );
                if (!continueAnyway) {
                    isFinalizing.value = false;
                    return;
                }
            }
        }

        const report = await generateTextReport(inspeccionId, 'initial', 'blob');
        if (!report || !report.blob) throw new Error("La generación del PDF falló.");
        const base64File = await blobToBase64(report.blob);
        const centroId = centro.value.id;
        const fileNameWithId = `${inspeccionId}-${report.fileName}`;
        const finalFileName = `centro_${centroId}/${fileNameWithId}`;
        const { data, error: invokeError } = await supabase.functions.invoke('upload-pdf-to-b2', { body: { file: base64File, fileName: finalFileName, contentType: 'application/pdf' } });
        if (invokeError) throw new Error(`Error al contactar con la función Edge: ${invokeError.message}.`);
        if (data.error) throw new Error(`Error en el servidor al subir el archivo: ${data.error}`);
        if (!data.publicUrl) throw new Error('La función Edge no devolvió una URL válida.');
        const publicUrl = data.publicUrl;
        const { error: updateError } = await supabase.from('inspecciones').update({ estado: 'finalizada', url_pdf_informe_inicial: publicUrl }).eq('id', inspeccionId);
        if (updateError) throw updateError;
        const CACHE_KEY = `inspections_${centro.value.id}`;
        localStorage.removeItem(CACHE_KEY);
        showNotification('Inspección finalizada y archivada con éxito.');
        router.push(`/centros/${centro.value.id}/historial`);
    } catch (error) {
        console.error("Error completo al finalizar la inspección:", error);
        showNotification('Ocurrió un error al finalizar y archivar: ' + error.message, 'error');
    } finally {
        isFinalizing.value = false;
    }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex flex-col lg:flex-row overflow-hidden">
      <header class="flex-shrink-0 px-4 md:px-8 pt-6 pb-4 bg-slate-100/80 border-b border-slate-200 z-10">
         <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            <div class="flex-1 space-y-2">
               <SkeletonLoader class="h-8 w-3/4" />
               <SkeletonLoader class="h-5 w-1/2" />
            </div>
            <div class="w-full md:w-auto">
               <SkeletonLoader class="h-10 w-48" />
            </div>
         </div>
      </header>
      <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">
         <aside class="w-full lg:w-80 xl:w-96 flex-shrink-0 bg-white border-r border-slate-200 p-4 space-y-4">
            <SkeletonLoader class="h-10 w-full" />
            <div class="space-y-2 pt-4">
               <SkeletonLoader v-for="i in 5" :key="i" class="h-12 w-full" />
            </div>
         </aside>
         <main class="flex-1 bg-slate-100 min-w-0 h-1/2 lg:h-full p-4">
            <SkeletonLoader class="h-full w-full" />
         </main>
      </div>
    </div>
    
    <div v-else-if="inspeccion && centro && version" class="flex-1 flex flex-col min-h-0">
      <!-- ============ HEADER MÓVIL COMPACTO (visible solo < lg) ============ -->
      <header class="lg:hidden flex-shrink-0 px-3 py-2 bg-white border-b border-slate-200 z-10">
        <div class="flex items-center justify-between gap-2">
          <!-- Botón hamburguesa para el menú lateral -->
          <button
            v-if="toggleSidebar"
            @click="toggleSidebar"
            class="p-2 rounded-md bg-slate-100 text-slate-600 hover:bg-slate-200 transition-colors"
            title="Abrir Menú"
            aria-label="Abrir Menú">
            <Bars3Icon class="h-5 w-5" />
          </button>

          <!-- Indicador de conexión -->
          <GlobalStatusIndicator mode="mobile" />

          <!-- Botones de acción compactos -->
          <div class="flex items-center gap-1">
            <!-- Botón Editar Plano -->
            <button
              v-if="canEditInspection"
              @click="toggleMobilePlanoEditing"
              :class="[
                'p-2 rounded-md transition-colors',
                isPlanoEditingMode ? 'bg-orange-500 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              ]"
              :title="isPlanoEditingMode ? 'Finalizar Edición' : 'Editar Plano'"
              :aria-label="isPlanoEditingMode ? 'Finalizar Edición' : 'Editar Plano'">
              <PencilSquareIcon class="h-5 w-5" />
            </button>

            <!-- Botón Agregar Punto -->
            <button
              v-if="canEditInspection && !isPlanoEditingMode"
              @click="isMobileAddPointOpen = !isMobileAddPointOpen"
              :class="[
                'p-2 rounded-md transition-colors',
                isMobileAddPointOpen ? 'bg-blue-500 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              ]"
              title="Agregar Punto"
              aria-label="Agregar Punto">
              <PlusIcon class="h-5 w-5" />
            </button>

            <!-- Botón Ver Plano / Ver Lista -->
            <button
              @click="toggleMapInMobile"
              :class="[
                'p-2 rounded-md transition-colors',
                showMapInMobile ? 'bg-blue-500 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              ]"
              :title="showMapInMobile ? 'Ver Lista' : 'Ver Plano'"
              :aria-label="showMapInMobile ? 'Ver Lista' : 'Ver Plano'">
              <component :is="showMapInMobile ? ListBulletIcon : MapIcon" class="h-5 w-5" />
            </button>

            <!-- Botón Finalizar o Volver -->
            <button
              v-if="canEditInspection"
              @click="finalizarInspeccion"
              :disabled="isFinalizing"
              class="p-2 rounded-md bg-green-600 text-white hover:bg-green-700 disabled:bg-slate-400 transition-colors"
              title="Finalizar Inspección"
              :aria-label="isFinalizing ? 'Finalizando...' : 'Finalizar Inspección'">
              <CheckCircleIcon class="h-5 w-5" />
            </button>
            <button
              v-else
              @click="router.push(`/centros/${centro.id}/historial`)"
              class="p-2 rounded-md bg-slate-100 text-slate-600 hover:bg-slate-200 transition-colors"
              title="Volver al Historial"
              aria-label="Volver al Historial">
              <ArrowLeftIcon class="h-5 w-5" />
            </button>
          </div>
        </div>

        <!-- Aviso de solo lectura compacto (móvil) -->
        <div v-if="!canEditInspection" class="mt-2 flex items-center gap-2 text-xs font-medium text-orange-700 bg-orange-50 border border-orange-200 rounded px-2 py-1">
          <InformationCircleIcon class="h-4 w-4 flex-shrink-0" />
          <span>Solo lectura</span>
        </div>
      </header>

      <!-- ============ HEADER DESKTOP COMPLETO (visible solo >= lg) ============ -->
      <header class="hidden lg:flex flex-shrink-0 px-4 md:px-8 pt-6 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4 w-full">
          <div class="flex-1">
            <h1 class="text-2xl md:text-3xl font-bold text-slate-800 mb-1">Inspección: {{ centro.nombre }}</h1>
            <p class="text-slate-500 text-sm">
              Técnico: <span class="font-medium">{{ inspeccion.tecnico_nombre }}</span> |
              Fecha: <span class="font-medium">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</span> |
              Plano: <strong class="text-blue-600">{{ version.nombre }}</strong>
            </p>
            <div v-if="!canEditInspection" class="mt-2 flex items-center gap-2 text-sm font-semibold text-orange-700 bg-orange-100 border border-orange-200 rounded-md p-2 max-w-md">
                <InformationCircleIcon class="h-5 w-5 flex-shrink-0" />
                <span>Esta inspección está bloqueada (modo solo lectura).</span>
            </div>
          </div>
          <div class="w-full md:w-auto flex items-center flex-col sm:flex-row gap-2">
            <button v-if="canEditInspection" @click="finalizarInspeccion" :disabled="isFinalizing" class="w-full sm:w-auto flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 shadow-sm disabled:bg-slate-400">
              <CheckCircleIcon class="h-5 w-5" />
              {{ isFinalizing ? 'Finalizando...' : 'Finalizar Inspección' }}
            </button>
            <button v-else @click="router.push(`/centros/${centro.id}/historial`)" class="w-full sm:w-auto flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
              Volver al Historial
            </button>
          </div>
        </div>
      </header>
      
      <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">

        <InspectionSidebar
          :class="[
            'lg:block',
            showMapInMobile ? 'hidden' : 'block'
          ]"
          :can-edit="canEditInspection"
          :salas="salas"
          :puntos-agrupados="puntosAgrupadosPorSala"
          :all-incidencias="allIncidencias"
          :is-plano-editing-mode="isPlanoEditingMode"
          :is-mobile-add-point-open="isMobileAddPointOpen"
          @toggle-plano-editing="handleTogglePlanoEditing"
          @add-sala="handleAddSala"
          @start-area-drawing="handleStartAreaDrawing"
          @start-placement-mode="handleStartPlacementMode"
          @cancel-placement-mode="handleCancelPlacementMode"
          @select-point="openChecklistFor"
          @update-point-state="updatePuntoEstado"
          @delete-new-point="handleDeleteNewPoint"
          @update-point-nomenclatura="handleUpdatePointNomenclatura"
          @update:is-mobile-add-point-open="isMobileAddPointOpen = $event"
        />

        <main
          :class="[
            'flex-1 bg-slate-100 min-w-0 lg:h-full overflow-auto',
            showMapInMobile ? 'block' : 'hidden lg:block'
          ]"
        >
          <InteractiveMap
            v-if="!loading && version?.url_imagen_plano"
            :key="inspeccionId"
            :image-url="version.url_imagen_plano"
            :points="puntosParaMostrar.filter(p => p.estado !== 'suprimido')"
            :salas="salas"
            :all-incidencias="allIncidencias"
            :is-read-only="!canEditInspection || (!isPlacementMode && !isAreaDrawingMode)"
            :is-placement-mode="isPlacementMode"
            :is-area-drawing-mode="isAreaDrawingMode"
            @point-click="openChecklistFor"
            @add-point="handleMapClick"
            @delete-point="handleDeleteNewPoint"
            @area-drawn="handleAreaDrawn"
            @drawing-cancelled="handleDrawingCancelled"
          />
        </main>
      </div>
    </div>
    
    <div v-else class="flex-1 flex items-center justify-center text-red-500">No se encontraron datos válidos para esta inspección.</div>

    <ChecklistModal 
      v-if="isModalOpen"
      :is-open="isModalOpen" 
      :punto="selectedPunto"
      :inspeccion-id="inspeccionId"
      :initial-incidencias="incidenciasDelPuntoSeleccionado"
      :available-custom-fields="allCustomFields"
      :existing-identifiers-in-sala="existingIdentifiersInSala"
      @close="isModalOpen = false" 
      @save="refreshInspectedPoints"
      @update-nomenclatura="handleUpdatePointNomenclatura"
      @update:incidencias="handleIncidenciasUpdate"
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/InspeccionDetailView.vue ---

--- INICIO DEL ARCHIVO: src/views/DashboardView.vue ---
<!-- src/views/DashboardView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
import { 
  BuildingStorefrontIcon, 
  ClockIcon,
  PaperAirplaneIcon,
  CheckBadgeIcon,
  ArchiveBoxIcon
} from '@heroicons/vue/24/outline';
import { Line } from 'vue-chartjs';
import { Chart as ChartJS, Title, Tooltip, Legend, LineElement, PointElement, CategoryScale, LinearScale } from 'chart.js';
import SkeletonLoader from '../components/SkeletonLoader.vue';

ChartJS.register(Title, Tooltip, Legend, LineElement, PointElement, CategoryScale, LinearScale);

const loading = ref(true);
const centros = ref([]);
const resumenInspecciones = ref([]);
const router = useRouter();

// Modal states
const showModal = ref(false);
const selectedStatus = ref(null);

const statusLabels = {
  centros: 'Centros',
  en_progreso: 'En Progreso',
  pendientes_envio: 'Pendientes de Envío',
  pendientes_cierre: 'Pendientes de Cierre',
  cerradas: 'Cerradas'
};

// ===== INICIO DE LA CORRECCIÓN: Función robusta para parsear fechas =====
function parseDate(dateString) {
  if (!dateString) return null;
  // Añadimos 'T00:00:00' para asegurar que se interprete como la medianoche en la zona horaria local,
  // evitando problemas de desplazamiento de un día.
  return new Date(`${dateString}T00:00:00`);
}
// ===== FIN DE LA CORRECCIÓN =====


onMounted(async () => {
  loading.value = true;
  const [centrosRes, resumenRes] = await Promise.all([
    supabase.from('centros').select('id, nombre'),
    supabase.from('vista_resumen_inspecciones').select('*')
  ]);
  
  centros.value = centrosRes.data || [];
  
  // ===== INICIO DE LA CORRECCIÓN: Procesamos las fechas al recibir los datos =====
  if (resumenRes.data) {
    resumenInspecciones.value = resumenRes.data.map(inspeccion => ({
      ...inspeccion,
      fecha_inspeccion_obj: parseDate(inspeccion.fecha_inspeccion),
      fecha_envio_cliente_obj: parseDate(inspeccion.fecha_envio_cliente),
    }));
  } else {
    resumenInspecciones.value = [];
  }
  // ===== FIN DE LA CORRECCIÓN =====
  
  loading.value = false;
});

const totalCentros = computed(() => centros.value.length);
const inspeccionesEnProgreso = computed(() => resumenInspecciones.value.filter(i => i.estado === 'en_progreso').length);
const inspeccionesPendientesEnvio = computed(() => resumenInspecciones.value.filter(i => i.estado === 'finalizada').length);
const inspeccionesPendientesCierre = computed(() => resumenInspecciones.value.filter(i => i.estado === 'pendiente_subsanacion').length);
const inspeccionesCerradas = computed(() => resumenInspecciones.value.filter(i => i.estado === 'cerrada').length);


const actividadMensual = computed(() => {
    const meses = {};
    const hoy = new Date();
    
    for (let i = 11; i >= 0; i--) {
        const d = new Date(hoy.getFullYear(), hoy.getMonth() - i, 1);
        const clave = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`; // 'YYYY-MM'
        const etiqueta = d.toLocaleString('es-ES', { month: 'short', year: '2-digit' });
        meses[clave] = { etiqueta, iniciales: 0, cierres: 0 };
    }
    
    // ===== INICIO DE LA CORRECCIÓN: Usamos las fechas ya procesadas =====
    resumenInspecciones.value.forEach(inspeccion => {
        if (inspeccion.fecha_inspeccion_obj) {
            const fecha = inspeccion.fecha_inspeccion_obj;
            const claveMesInicial = `${fecha.getFullYear()}-${String(fecha.getMonth() + 1).padStart(2, '0')}`;
            if (meses[claveMesInicial]) {
                meses[claveMesInicial].iniciales++;
            }
        }
        
        if (inspeccion.estado === 'cerrada' && inspeccion.fecha_envio_cliente_obj) {
             const fecha = inspeccion.fecha_envio_cliente_obj;
             const claveMesCierre = `${fecha.getFullYear()}-${String(fecha.getMonth() + 1).padStart(2, '0')}`;
             if (meses[claveMesCierre]) {
                meses[claveMesCierre].cierres++;
            }
        }
    });
    // ===== FIN DE LA CORRECCIÓN =====
    
    return Object.values(meses);
});

const monthlyChartData = computed(() => ({
  labels: actividadMensual.value.map(m => m.etiqueta),
  datasets: [
    { 
      label: 'Informes Iniciales', 
      backgroundColor: '#3B82F6', 
      borderColor: '#3B82F6', 
      data: actividadMensual.value.map(m => m.iniciales), 
      tension: 0.2 
    },
    { 
      label: 'Informes de Cierre', 
      backgroundColor: '#22C55E', 
      borderColor: '#22C55E', 
      data: actividadMensual.value.map(m => m.cierres), 
      tension: 0.2 
    }
  ]
}));

const monthlyChartOptions = {
  responsive: true, maintainAspectRatio: false,
  plugins: { legend: { position: 'top' } },
  scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
};

const centrosConMasRojas = computed(() => {
  const centrosConteo = {};
  resumenInspecciones.value.filter(i => i.incidencias_rojas > 0 && i.estado !== 'cerrada').forEach(i => {
    if (!centrosConteo[i.centro_id]) centrosConteo[i.centro_id] = { id: i.centro_id, nombre: i.centro_nombre, rojas: 0 };
    centrosConteo[i.centro_id].rojas += i.incidencias_rojas;
  });
  return Object.values(centrosConteo).sort((a, b) => b.rojas - a.rojas).slice(0, 5);
});

const accionesPendientes = computed(() => {
    return resumenInspecciones.value
        .filter(i => i.estado === 'finalizada')
        // Usamos la fecha procesada para ordenar
        .sort((a, b) => a.fecha_inspeccion_obj - b.fecha_inspeccion_obj);
});

const modalItems = computed(() => {
  if (!selectedStatus.value) return [];
  return resumenInspecciones.value.filter(i => {
    switch(selectedStatus.value) {
      case 'en_progreso': return i.estado === 'en_progreso';
      case 'pendientes_envio': return i.estado === 'finalizada';
      case 'pendientes_cierre': return i.estado === 'pendiente_subsanacion';
      default: return false;
    }
  });
});

const openModal = (status) => {
  selectedStatus.value = status;
  showModal.value = true;
};

const closeModal = () => {
  showModal.value = false;
  selectedStatus.value = null;
};
</script>

<template>
  <div class="h-full overflow-y-auto p-4 sm:p-8 bg-slate-50">
    <h1 class="text-3xl md:text-4xl font-bold text-slate-800 mb-6">Cuadro de Mando</h1>
    
    <div v-if="loading" class="space-y-6">
      <!-- Skeleton for Stats -->
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        <div v-for="i in 5" :key="i" class="bg-white p-4 rounded-xl shadow-sm border border-slate-200 h-24"><SkeletonLoader/></div>
      </div>
      <!-- Skeleton for Main Content -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-sm border border-slate-200 h-96"><SkeletonLoader/></div>
        <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-sm border border-slate-200 h-96"><SkeletonLoader/></div>
      </div>
    </div>
    
    <div v-else class="space-y-6">
      <section>
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
          <div class="bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3">
            <div class="bg-blue-100 p-3 rounded-lg"><BuildingStorefrontIcon class="h-6 w-6 text-blue-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ totalCentros }}</p><p class="text-slate-500 text-sm font-semibold">Centros</p></div>
          </div>
          <div @click="openModal('en_progreso')" class="cursor-pointer bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3 hover:shadow-md transition-shadow">
            <div class="bg-yellow-100 p-3 rounded-lg"><ClockIcon class="h-6 w-6 text-yellow-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesEnProgreso }}</p><p class="text-slate-500 text-sm font-semibold">En Progreso</p></div>
          </div>
          <div @click="openModal('pendientes_envio')" class="cursor-pointer bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3 hover:shadow-md transition-shadow">
            <div class="bg-purple-100 p-3 rounded-lg"><PaperAirplaneIcon class="h-6 w-6 text-purple-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesPendientesEnvio }}</p><p class="text-slate-500 text-sm font-semibold">Pend. Envío</p></div>
          </div>
          <div @click="openModal('pendientes_cierre')" class="cursor-pointer bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3 hover:shadow-md transition-shadow">
            <div class="bg-orange-100 p-3 rounded-lg"><ArchiveBoxIcon class="h-6 w-6 text-orange-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesPendientesCierre }}</p><p class="text-slate-500 text-sm font-semibold">Pend. Cierre</p></div>
          </div>
          <div class="col-span-2 md:col-span-1 lg:col-span-1 bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3">
            <div class="bg-green-100 p-3 rounded-lg"><CheckBadgeIcon class="h-6 w-6 text-green-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesCerradas }}</p><p class="text-slate-500 text-sm font-semibold">Cerradas</p></div>
          </div>
        </div>
      </section>
      
      <section class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="lg:col-span-2 bg-white p-4 sm:p-6 rounded-xl shadow-sm border border-slate-200">
           <h2 class="text-lg font-bold text-slate-800 mb-4">Actividad Mensual</h2>
           <div class="h-80">
              <Line :data="monthlyChartData" :options="monthlyChartOptions" />
           </div>
        </div>

        <div class="lg:col-span-1 bg-white p-4 sm:p-6 rounded-xl shadow-sm border border-slate-200 flex flex-col">
          <h2 class="text-lg font-bold text-slate-800 mb-4 flex-shrink-0">Puntos Críticos Activos</h2>
          <ul v-if="centrosConMasRojas.length > 0" class="divide-y divide-slate-100">
            <li v-for="centro in centrosConMasRojas" :key="centro.id" class="py-3 flex justify-between items-center group">
              <div>
                <p class="font-semibold text-slate-800 group-hover:text-blue-600">{{ centro.nombre }}</p>
                <p class="text-sm text-slate-500 flex items-center"><span class="h-2.5 w-2.5 rounded-full bg-red-500 mr-2"></span><span class="font-bold text-red-600">{{ centro.rojas }}</span>&nbsp;incidencias graves</p>
              </div>
              <router-link :to="`/centros/${centro.id}/historial`" class="opacity-0 group-hover:opacity-100 px-3 py-1 text-sm font-semibold text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 transition-opacity">Revisar</router-link>
            </li>
          </ul>
          <div v-else class="flex-1 flex flex-col items-center justify-center text-center text-slate-500 p-4">
            <span class="text-2xl mb-2">🎉</span><p class="font-semibold">¡Todo en orden!</p><p class="text-sm">No hay incidencias graves activas.</p>
          </div>
        </div>
      </section>

      <section class="bg-white p-4 sm:p-6 rounded-xl shadow-sm border border-slate-200">
        <h2 class="text-lg font-bold text-slate-800 mb-4">Acciones Pendientes (Enviar a Cliente)</h2>
         <div class="overflow-x-auto">
          <table class="min-w-full divide-y divide-slate-200">
             <thead class="bg-slate-50">
              <tr>
                <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Centro</th>
                <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider hidden sm:table-cell">Fecha Finalización</th>
                <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider hidden md:table-cell">Técnico</th>
                <th class="relative px-4 py-3"><span class="sr-only">Acción</span></th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-slate-200">
              <tr v-if="accionesPendientes.length === 0">
                  <td colspan="4" class="px-4 py-8 text-center text-slate-500">No hay acciones pendientes. ¡Buen trabajo!</td>
              </tr>
              <tr v-for="inspeccion in accionesPendientes" :key="inspeccion.inspeccion_id" class="hover:bg-slate-50">
                <td class="px-4 py-4 whitespace-nowrap font-semibold text-slate-800 text-sm">
                  {{ inspeccion.centro_nombre }}
                  <div class="sm:hidden text-xs text-slate-500 font-normal">{{ inspeccion.fecha_inspeccion_obj.toLocaleDateString('es-ES') }}</div>
                </td>
                <td class="px-4 py-4 whitespace-nowrap text-slate-600 hidden sm:table-cell text-sm">{{ inspeccion.fecha_inspeccion_obj.toLocaleDateString('es-ES') }}</td>
                <td class="px-4 py-4 whitespace-nowrap text-slate-600 hidden md:table-cell text-sm">{{ inspeccion.tecnico_nombre }}</td>
                <td class="px-4 py-4 whitespace-nowrap text-right text-sm font-medium">
                  <router-link :to="`/centros/${inspeccion.centro_id}/historial`" class="font-semibold text-purple-600 hover:text-purple-800">Gestionar</router-link>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </div>

    <!-- Modal for status details -->
    <div v-if="showModal" @click.self="closeModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 z-50">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <div class="p-6">
          <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-slate-800">{{ statusLabels[selectedStatus] }}</h3>
            <button @click="closeModal" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
          </div>

          <div>
            <div v-if="modalItems.length === 0" class="text-slate-500 text-center p-8">No hay inspecciones en este estado.</div>
            <div v-else class="overflow-x-auto">
              <table class="min-w-full divide-y divide-slate-200">
                <thead class="bg-slate-50">
                  <tr>
                    <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Centro</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Fecha Inspección</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider hidden md:table-cell">Técnico</th>
                    <th class="relative px-4 py-3"><span class="sr-only">Acción</span></th>
                  </tr>
                </thead>
                <tbody class="bg-white divide-y divide-slate-200">
                  <tr v-for="inspeccion in modalItems" :key="inspeccion.inspeccion_id" class="hover:bg-slate-50">
                    <td class="px-4 py-4 whitespace-nowrap font-semibold text-slate-800 text-sm">{{ inspeccion.centro_nombre }}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-slate-600 text-sm">{{ inspeccion.fecha_inspeccion_obj.toLocaleDateString('es-ES') }}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-slate-600 hidden md:table-cell text-sm">{{ inspeccion.tecnico_nombre }}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <router-link :to="`/centros/${inspeccion.centro_id}/historial`" class="font-semibold text-blue-600 hover:text-blue-800">Ver Detalles</router-link>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/DashboardView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroVersionsView.vue ---
<!-- src/views/CentroVersionsView.vue -->
<script setup>
import { ref, onMounted, inject, nextTick, onUnmounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { PlusIcon, PencilIcon, CheckCircleIcon, ArchiveBoxIcon, CheckIcon } from '@heroicons/vue/24/solid';
import { addToQueue } from '../utils/syncQueue';

const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const loading = ref(true);
const centro = ref(null);
const versiones = ref([]);
const newVersionName = ref('');

// Inline editing state
const editingVersionId = ref(null);
const tempVersionName = ref('');

// Inject notification system
const showNotification = inject('showNotification');

const fetchVersions = async () => {
  loading.value = true;
  const { data: centroData } = await supabase.from('centros').select('nombre').eq('id', centroId).single();
  centro.value = centroData;

  const { data: versionsData } = await supabase
    .from('versiones_plano')
    .select('*')
    .eq('centro_id', centroId)
    .order('fecha_creacion', { ascending: false });
  versiones.value = versionsData || [];
  loading.value = false;
};

const createNewVersion = async () => {
    if (!newVersionName.value.trim()) {
        alert('Por favor, introduce un nombre para la nueva versión.');
        return;
    }

    // Llamamos a una función RPC de Supabase que se encarga de la lógica de duplicación
    // Esta función debería:
    // 1. Poner a `false` la `es_activa` de la versión activa actual.
    // 2. Crear la nueva versión con `es_activa = true`.
    // 3. Duplicar las salas y puntos de la versión anterior a la nueva.
    // 4. Devolver el ID de la nueva versión.
    const { data, error } = await supabase.rpc('crear_nueva_version_plano', {
        centro_id_param: centroId,
        nuevo_nombre_param: newVersionName.value.trim()
    });

    if (error) {
        alert('Error al crear la nueva versión: ' + error.message);
        console.error(error);
    } else {
        alert('Nueva versión creada con éxito.');
        newVersionName.value = '';
        await fetchVersions();
        // Opcionalmente, redirigir directamente a la configuración de la nueva versión
        if (data) {
           router.push(`/versiones/${data}/configurar`);
        }
    }
};

// Inline editing functions
const startEditingName = (version) => {
  editingVersionId.value = version.id;
  tempVersionName.value = version.nombre;
  nextTick(() => {
    // Find the input element by its data attribute
    const inputElement = document.querySelector(`input[data-version-id="${version.id}"]`);
    if (inputElement) {
      inputElement.focus();
      inputElement.select(); // Also select all text for easier editing
    }
  });
};

const cancelEditingName = () => {
  editingVersionId.value = null;
  tempVersionName.value = '';
};

const saveVersionName = async (versionId) => {
  const newName = tempVersionName.value.trim();

  // Validation
  if (!newName) {
    showNotification('El nombre de la versión no puede estar vacío.', 'error');
    return;
  }

  if (newName.length > 100) {
    showNotification('El nombre es demasiado largo (máximo 100 caracteres).', 'error');
    return;
  }

  try {
    // Use sync queue for offline support
    addToQueue({
      table: 'versiones_plano',
      type: 'update',
      id: versionId,
      payload: { nombre: newName }
    });

    // Update local state immediately
    const version = versiones.value.find(v => v.id === versionId);
    if (version) {
      version.nombre = newName;
    }

    showNotification('Nombre de versión actualizado correctamente.', 'success');
    cancelEditingName();
  } catch (error) {
    console.error('Error updating version name:', error);
    showNotification('Error al actualizar el nombre: ' + error.message, 'error');
  }
};

// Handle clicking outside to cancel edit
const handleClickOutside = (event) => {
  if (editingVersionId.value === null) {
    return; // Not editing, nothing to do
  }

  // Check if click target is the pencil button itself
  const pencilButton = event.target.closest('button[title="Editar nombre"]');
  if (pencilButton) {
    return; // Ignore clicks on the pencil button
  }

  const editContainer = document.querySelector('.version-name-edit-container');
  if (editContainer && !editContainer.contains(event.target)) {
    cancelEditingName();
  }
};

onMounted(() => {
  fetchVersions();
  document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
});
</script>

<template>
  <div class="p-8">
    <div v-if="loading">Cargando versiones...</div>
    <div v-else-if="centro">
      <div class="flex justify-between items-center mb-8">
        <div>
          <h1 class="text-4xl font-bold text-slate-800">Versiones del Plano</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <router-link to="/centros" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">
          Volver a Centros
        </router-link>
      </div>

      <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 mb-8 max-w-3xl mx-auto">
        <h2 class="text-2xl font-bold text-slate-800 mb-4">Crear Nueva Versión</h2>
        <p class="text-slate-500 mb-4">
          Crea una nueva versión para modificar el plano, añadir o quitar salas y puntos. Se copiará la configuración de la última versión activa.
        </p>
        <form @submit.prevent="createNewVersion" class="flex flex-col sm:flex-row gap-4">
          <input 
            v-model="newVersionName" 
            type="text" 
            placeholder="Ej: Reforma Almacén 2026" 
            required
            class="flex-1 block w-full rounded-md border-slate-300 shadow-sm"
          >
          <button 
            type="submit"
            class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm"
          >
            <PlusIcon class="h-5 w-5" />
            Crear Versión
          </button>
        </form>
      </div>

      <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
        <ul class="divide-y divide-slate-200">
          <li v-if="versiones.length === 0" class="p-8 text-center text-slate-500">
            No se han encontrado versiones para este centro. Crea la primera.
          </li>
          <li v-for="version in versiones" :key="version.id" class="p-4 grid grid-cols-1 md:grid-cols-4 gap-4 items-center">
            <div class="md:col-span-1">
              <!-- Editable version name -->
              <div class="flex items-center gap-2 group version-name-edit-container">
                <!-- Edit mode -->
                <div v-if="editingVersionId === version.id" class="flex items-center gap-1 flex-1">
                  <input
                    :data-version-id="version.id"
                    v-model="tempVersionName"
                    type="text"
                    @keyup.enter="saveVersionName(version.id)"
                    @keyup.esc="cancelEditingName"
                    class="font-semibold text-slate-800 text-lg px-2 py-1 border-2 border-blue-400 rounded-md focus:ring-2 focus:ring-blue-400 focus:outline-none flex-1"
                    maxlength="100"
                  />
                  <button
                    @mousedown.prevent="saveVersionName(version.id)"
                    class="p-1.5 text-green-600 hover:bg-green-100 rounded-md transition-colors"
                    title="Guardar"
                  >
                    <CheckIcon class="h-5 w-5" />
                  </button>
                </div>

                <!-- View mode -->
                <div v-else class="flex items-center gap-2 flex-1">
                  <p class="font-semibold text-slate-800 text-lg">{{ version.nombre }}</p>
                  <button
                    @click="startEditingName(version)"
                    class="p-1 text-slate-400 hover:text-blue-600 opacity-0 group-hover:opacity-100 transition-opacity"
                    title="Editar nombre"
                  >
                    <PencilIcon class="h-4 w-4" />
                  </button>
                </div>
              </div>
              <p class="text-sm text-slate-500">Creada: {{ new Date(version.fecha_creacion).toLocaleDateString() }}</p>
            </div>
            <div class="md:col-span-1">
              <span v-if="version.es_activa" class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <CheckCircleIcon class="h-4 w-4" />
                Versión Activa
              </span>
              <span v-else class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-600">
                <ArchiveBoxIcon class="h-4 w-4" />
                Archivada
              </span>
            </div>
            <div class="md:col-span-2 flex justify-end items-center gap-2">
              <router-link :to="`/versiones/${version.id}/configurar`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
                <PencilIcon class="h-4 w-4" />
                Configurar Plano
              </router-link>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroVersionsView.vue ---

--- INICIO DEL ARCHIVO: src/views/AdminView.vue ---
<!-- src/views/AdminView.vue -->
<script setup>
import { ref, onMounted, inject, computed, watch } from 'vue';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';

const showNotification = inject('showNotification');
const defaults = ref([]);
const customFields = ref([]);
const loading = ref(true);
const saving = ref(false);
const companyAssets = ref({ logo: null, signature: null });

// Modal states
const showPointModal = ref(false);
const showFieldModal = ref(false);
const editingField = ref(null);
const selectedPoint = ref(null);
const currentPointId = ref(null);
const fieldForm = ref({
  field_name: '',
  field_type: 'text',
  required: false,
  options: []
});

const gravedadOptions = [
  { label: 'Verde', value: 'verde' },
  { label: 'Ambar', value: 'ambar' },
  { label: 'Rojo', value: 'rojo' },
];

const fieldTypes = [
  { label: 'Texto', value: 'text' },
  { label: 'Selección Múltiple', value: 'select' },
  { label: 'Número', value: 'number' }
];

const pointsWithFields = computed(() => {
  const fieldsMap = new Map();
  customFields.value.forEach(field => {
    if (!fieldsMap.has(field.point_id)) fieldsMap.set(field.point_id, []);
    fieldsMap.get(field.point_id).push(field);
  });

  return defaults.value.map(point => ({
    ...point,
    fields: fieldsMap.get(point.id) || []
  }));
});

const updateDefaults = () => {
  if (selectedPoint.value) {
    const index = defaults.value.findIndex(d => d.id === selectedPoint.value.id);
    if (index !== -1) {
      defaults.value[index].default_severity = selectedPoint.value.default_severity;
    }
  }
};

watch(() => selectedPoint.value?.default_severity, (newVal, oldVal) => {
  if (newVal && newVal !== oldVal) {
    updateDefaults();
    saveDefaults();
  }
});

const loadData = async () => {
  loading.value = true;
  const [defaultsRes, fieldsRes, assetsRes] = await Promise.all([
    supabase.from('checklist_defaults').select('*').order('point_id'),
    supabase.from('checklist_custom_fields').select('*').order('point_id, id'),
    supabase.from('company_assets').select('*')
  ]);

  if (defaultsRes.error) {
    showNotification('Error al cargar gravedades: ' + defaultsRes.error.message, 'error');
  } else {
    const defaultsMap = new Map(defaultsRes.data.map(d => [d.point_id, d]));
    defaults.value = checklistItems.map(item => ({
      ...item,
      default_severity: defaultsMap.get(item.id)?.default_severity || 'ambar'
    }));
  }

  if (fieldsRes.error) {
    showNotification('Error al cargar campos personalizados: ' + fieldsRes.error.message, 'error');
  } else {
    customFields.value = fieldsRes.data;
  }

  if (assetsRes.error) {
    console.error('Error loading assets:', assetsRes.error);
  } else {
    const assetsMap = new Map(assetsRes.data.map(a => [a.asset_type, a.url]));
    companyAssets.value = {
      logo: assetsMap.get('header_logo'),
      signature: assetsMap.get('signature_logo')
    };
  }

  loading.value = false;
};

const validateFile = (file, maxSize, allowedTypes) => {
  if (!file) return 'No se seleccionó archivo';
  if (file.size > maxSize) return `Archivo demasiado grande (máx. ${maxSize / 1024}KB)`;
  if (!allowedTypes.includes(file.type)) return `Tipo de archivo no permitido (${allowedTypes.join(', ')})`;
  return null;
};

const handleLogoUpload = async (event) => {
  const file = event.target.files[0];
  const error = validateFile(file, 500 * 1024, ['image/png', 'image/jpeg', 'image/svg+xml']);
  if (error) {
    showNotification(error, 'error');
    return;
  }

  const fileName = `logo_${Date.now()}.${file.name.split('.').pop()}`;
  const { error: uploadError } = await supabase.storage.from('logos').upload(fileName, file);
  if (uploadError) {
    showNotification('Error al subir logo: ' + uploadError.message, 'error');
    return;
  }

  const { data: { publicUrl } } = supabase.storage.from('logos').getPublicUrl(fileName);
  const { error: dbError } = await supabase.from('company_assets').upsert({ asset_type: 'header_logo', url: publicUrl });
  if (dbError) {
    showNotification('Error al guardar logo: ' + dbError.message, 'error');
  } else {
    companyAssets.value.logo = publicUrl;
    showNotification('Logo actualizado correctamente', 'success');
  }
};

const handleSignatureUpload = async (event) => {
  const file = event.target.files[0];
  const error = validateFile(file, 200 * 1024, ['image/png', 'image/jpeg']);
  if (error) {
    showNotification(error, 'error');
    return;
  }

  const fileName = `signature_${Date.now()}.${file.name.split('.').pop()}`;
  const { error: uploadError } = await supabase.storage.from('logos').upload(fileName, file);
  if (uploadError) {
    showNotification('Error al subir firma: ' + uploadError.message, 'error');
    return;
  }

  const { data: { publicUrl } } = supabase.storage.from('logos').getPublicUrl(fileName);
  const { error: dbError } = await supabase.from('company_assets').upsert({ asset_type: 'signature_logo', url: publicUrl });
  if (dbError) {
    showNotification('Error al guardar firma: ' + dbError.message, 'error');
  } else {
    companyAssets.value.signature = publicUrl;
    showNotification('Firma actualizada correctamente', 'success');
  }
};

const saveDefaults = async () => {
  saving.value = true;
  const updates = defaults.value.map(item => ({
    point_id: item.id,
    default_severity: item.default_severity
  }));

  const { error } = await supabase
    .from('checklist_defaults')
    .upsert(updates, { onConflict: 'point_id' });

  if (error) {
    showNotification('Error al guardar gravedades: ' + error.message, 'error');
  } else {
    showNotification('Gravedades guardadas correctamente.', 'success');
  }
  saving.value = false;
};

const openPointModal = (point) => {
  selectedPoint.value = { ...point };
  showPointModal.value = true;
};

const closePointModal = () => {
  showPointModal.value = false;
  selectedPoint.value = null;
};

const openFieldModal = (pointId, field = null) => {
  currentPointId.value = pointId;
  editingField.value = field;
  if (field) {
    fieldForm.value = { ...field };
  } else {
    fieldForm.value = { field_name: '', field_type: 'text', required: false, options: [] };
  }
  showFieldModal.value = true;
};

const closeFieldModal = () => {
  showFieldModal.value = false;
  editingField.value = null;
  currentPointId.value = null;
};

const saveField = async () => {
  if (!fieldForm.value.field_name.trim()) {
    showNotification('El nombre del campo es obligatorio.', 'warning');
    return;
  }

  const fieldData = {
    point_id: currentPointId.value,
    ...fieldForm.value,
    options: fieldForm.value.field_type === 'select' ? fieldForm.value.options : []
  };

  const { error } = editingField.value
    ? await supabase.from('checklist_custom_fields').update(fieldData).eq('id', editingField.value.id)
    : await supabase.from('checklist_custom_fields').insert(fieldData);

  if (error) {
    showNotification('Error al guardar campo: ' + error.message, 'error');
  } else {
    showNotification('Campo guardado correctamente.', 'success');
    await loadData();
    // Update selectedPoint fields
    if (selectedPoint.value) {
      selectedPoint.value.fields = customFields.value.filter(f => f.point_id === selectedPoint.value.id);
    }
    closeFieldModal();
  }
};

const deleteField = async (fieldId) => {
  const { error } = await supabase.from('checklist_custom_fields').delete().eq('id', fieldId);
  if (error) {
    showNotification('Error al eliminar campo: ' + error.message, 'error');
  } else {
    showNotification('Campo eliminado.', 'success');
    await loadData();
    // Update selectedPoint fields
    if (selectedPoint.value) {
      selectedPoint.value.fields = customFields.value.filter(f => f.point_id === selectedPoint.value.id);
    }
  }
};

const addOption = () => {
  fieldForm.value.options.push('');
};

const removeOption = (index) => {
  fieldForm.value.options.splice(index, 1);
};

onMounted(loadData);
</script>

<template>
  <div class="p-8">
    <h1 class="text-4xl font-bold text-slate-800 mb-8">Administración de Checklist</h1>

    <div v-if="loading" class="text-center p-10">Cargando configuraciones...</div>
    <div v-else class="space-y-8">
      <!-- Configuración de Logos y Firmas -->
      <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
        <h2 class="text-xl font-semibold text-slate-800 mb-4">Configuración de Logos y Firmas</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Logo de ARSEL -->
          <div class="border border-slate-200 rounded-lg p-4">
            <h3 class="font-medium text-slate-800 mb-3">Logo de ARSEL</h3>
            <div class="mb-4">
              <img v-if="companyAssets.logo" :src="companyAssets.logo" alt="Logo ARSEL" class="max-w-full h-16 object-contain border border-slate-300 rounded">
              <div v-else class="w-full h-16 border-2 border-dashed border-slate-300 rounded flex items-center justify-center text-slate-500">
                No hay logo configurado
              </div>
            </div>
            <input type="file" ref="logoInput" @change="handleLogoUpload" accept="image/png,image/jpeg,image/svg+xml" class="hidden">
            <button @click="$refs.logoInput.click()" class="w-full px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
              Cambiar Logo
            </button>
          </div>

          <!-- Firma de ARSEL -->
          <div class="border border-slate-200 rounded-lg p-4">
            <h3 class="font-medium text-slate-800 mb-3">Firma de ARSEL</h3>
            <div class="mb-4">
              <img v-if="companyAssets.signature" :src="companyAssets.signature" alt="Firma ARSEL" class="max-w-full h-16 object-contain border border-slate-300 rounded">
              <div v-else class="w-full h-16 border-2 border-dashed border-slate-300 rounded flex items-center justify-center text-slate-500">
                No hay firma configurada
              </div>
            </div>
            <input type="file" ref="signatureInput" @change="handleSignatureUpload" accept="image/png,image/jpeg" class="hidden">
            <button @click="$refs.signatureInput.click()" class="w-full px-4 py-2 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
              Cambiar Firma
            </button>
          </div>
        </div>
      </div>

      <!-- Lista de Puntos del Checklist -->
      <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
        <h2 class="text-xl font-semibold text-slate-800 mb-4">Puntos del Checklist</h2>
        <div class="space-y-3">
          <div
            v-for="point in pointsWithFields"
            :key="point.id"
            @click="openPointModal(point)"
            class="flex items-center justify-between p-4 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition-colors"
          >
            <div class="flex items-center gap-4">
              <div class="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-sm"
                   :class="{
                     'bg-green-500': point.default_severity === 'verde',
                     'bg-amber-500': point.default_severity === 'ambar',
                     'bg-red-500': point.default_severity === 'rojo'
                   }">
                {{ point.id }}
              </div>
              <div>
                <p class="font-medium text-slate-800">{{ point.text }}</p>
                <p class="text-sm text-slate-600">{{ point.fields.length }} campos personalizados</p>
              </div>
            </div>
            <div class="text-right">
              <p class="text-xs text-slate-500">Gravedad predeterminada</p>
              <p class="font-medium" :class="{
                'text-green-600': point.default_severity === 'verde',
                'text-amber-600': point.default_severity === 'ambar',
                'text-red-600': point.default_severity === 'rojo'
              }">
                {{ gravedadOptions.find(o => o.value === point.default_severity)?.label }}
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Botón de Guardar -->
      <div class="text-center">
        <button
          @click="saveDefaults"
          :disabled="saving"
          class="px-8 py-3 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-slate-400"
        >
          {{ saving ? 'Guardando...' : 'Guardar Todos los Cambios' }}
        </button>
      </div>
    </div>

    <!-- Modal para gestionar punto -->
    <div v-if="showPointModal" @click.self="closePointModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 z-50">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div class="p-6">
          <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-slate-800">
              Punto {{ selectedPoint?.id }}: {{ selectedPoint?.text }}
            </h3>
            <button @click="closePointModal" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
          </div>

          <!-- Gravedad Predeterminada -->
          <div class="mb-6">
            <h4 class="text-lg font-semibold text-slate-800 mb-3">Gravedad Predeterminada</h4>
            <select
              v-model="selectedPoint.default_severity"
              class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
              <option v-for="opt in gravedadOptions" :key="opt.value" :value="opt.value">
                {{ opt.label }}
              </option>
            </select>
          </div>

          <!-- Campos Personalizados -->
          <div>
            <div class="flex justify-between items-center mb-4">
              <h4 class="text-lg font-semibold text-slate-800">Campos Personalizados</h4>
              <button
                @click="openFieldModal(selectedPoint.id)"
                class="px-4 py-2 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700"
              >
                Agregar Campo
              </button>
            </div>

            <div v-if="selectedPoint.fields.length === 0" class="text-slate-500 text-sm p-4 bg-slate-50 rounded-md">
              No hay campos personalizados configurados para este punto.
            </div>
            <div v-else class="space-y-3">
              <div v-for="field in selectedPoint.fields" :key="field.id" class="flex justify-between items-center p-4 bg-slate-50 rounded-md">
                <div>
                  <p class="font-medium text-slate-800">{{ field.field_name }}</p>
                  <p class="text-sm text-slate-600">
                    {{ fieldTypes.find(t => t.value === field.field_type)?.label }}
                    {{ field.required ? '(Obligatorio)' : '(Opcional)' }}
                  </p>
                </div>
                <div class="flex gap-2">
                  <button @click="openFieldModal(selectedPoint.id, field)" class="px-3 py-1 text-sm text-blue-600 hover:bg-blue-100 rounded">Editar</button>
                  <button @click="deleteField(field.id)" class="px-3 py-1 text-sm text-red-600 hover:bg-red-100 rounded">Eliminar</button>
                </div>
              </div>
            </div>
          </div>

          <div class="flex justify-end gap-3 mt-6 pt-6 border-t">
            <button @click="closePointModal" class="px-4 py-2 text-slate-700 bg-slate-100 rounded-md hover:bg-slate-200">Cerrar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal para editar campos -->
    <div v-if="showFieldModal" @click.self="closeFieldModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 z-50">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
        <div class="p-6">
          <h3 class="text-lg font-bold text-slate-800 mb-4">{{ editingField ? 'Editar Campo' : 'Nuevo Campo' }}</h3>

          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-1">Nombre del Campo</label>
              <input
                v-model="fieldForm.field_name"
                type="text"
                class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                placeholder="Ej: Bastidor, Larguero..."
              >
            </div>

            <div>
              <label class="block text-sm font-medium text-slate-700 mb-1">Tipo de Campo</label>
              <select
                v-model="fieldForm.field_type"
                class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              >
                <option v-for="type in fieldTypes" :key="type.value" :value="type.value">
                  {{ type.label }}
                </option>
              </select>
            </div>

            <div v-if="fieldForm.field_type === 'select'" class="space-y-2">
              <label class="block text-sm font-medium text-slate-700">Opciones</label>
              <div v-for="(option, index) in fieldForm.options" :key="index" class="flex gap-2">
                <input
                  v-model="fieldForm.options[index]"
                  type="text"
                  class="flex-1 rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  placeholder="Opción..."
                >
                <button @click="removeOption(index)" class="px-2 py-1 text-red-600 hover:bg-red-100 rounded">×</button>
              </div>
              <button @click="addOption" class="text-sm text-blue-600 hover:underline">+ Agregar Opción</button>
            </div>

            <div class="flex items-center">
              <input
                v-model="fieldForm.required"
                type="checkbox"
                class="rounded border-slate-300 text-blue-600 focus:ring-blue-500"
              >
              <label class="ml-2 text-sm text-slate-700">Campo obligatorio</label>
            </div>
          </div>

          <div class="flex justify-end gap-3 mt-6">
            <button @click="closeFieldModal" class="px-4 py-2 text-slate-700 bg-slate-100 rounded-md hover:bg-slate-200">Cancelar</button>
            <button @click="saveField" class="px-4 py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/AdminView.vue ---

--- INICIO DEL ARCHIVO: src/views/PlanoPreviewView.vue ---
<!-- src/views/PlanoPreviewView.vue -->
<script setup>
import { ref, onMounted, nextTick } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { fetchReportData } from '../utils/pdf/pdf-data';
import { calculatePlanoLayout } from '../utils/plano-layout';
import { generatePlanPdf } from '../utils/pdf';
import PlanoBadge from '../components/PlanoBadge.vue';
import { ArrowDownTrayIcon, ArrowUturnLeftIcon, ArrowPathIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const layoutReady = ref(false);
const errorState = ref(null);
const reportData = ref(null);
const labels = ref([]);
const planoContainer = ref(null);
const mapDimensions = ref({ x: 0, y: 0, width: 1, height: 1 });
const isGenerating = ref(false);

const draggedLabel = ref(null);
const dragOffset = ref({ x: 0, y: 0 });

const BADGE_WIDTH_RATIO = 0.04; // El ancho del badge será el 4% del ancho del plano
const BADGE_ASPECT_RATIO = 45 / 55; // Altura / Ancho

const loadData = async () => {
  reportData.value = await fetchReportData(inspeccionId, { optimizePlan: false });

  if (!reportData.value || !reportData.value.planoBase64) {
    errorState.value = "No se pudieron cargar los datos o el plano de la inspección.";
    loading.value = false;
    return;
  }
  loading.value = false;
  await nextTick();
  prepareLayout();
};

onMounted(loadData);

const prepareLayout = () => {
  const containerEl = planoContainer.value;
  if (!containerEl) {
    errorState.value = "Error: El contenedor del plano no se encontró en el DOM.";
    return;
  }
  
  const img = new Image();
  img.onload = () => {
    const containerRatio = containerEl.clientWidth / containerEl.clientHeight;
    const imageRatio = img.width / img.height;
    let imgW, imgH, imgX, imgY;

    if (imageRatio > containerRatio) {
      imgW = containerEl.clientWidth;
      imgH = imgW / imageRatio;
      imgX = 0;
      imgY = (containerEl.clientHeight - imgH) / 2;
    } else {
      imgH = containerEl.clientHeight;
      imgW = imgH * imageRatio;
      imgY = 0;
      imgX = (containerEl.clientWidth - imgW) / 2;
    }
    mapDimensions.value = { x: imgX, y: imgY, width: imgW, height: imgH };

    const allPoints = reportData.value.puntosInspeccionadosData.map(punto => {
      const maestro = reportData.value.puntosMaestrosData.find(pm => pm.id === punto.punto_maestro_id);
      if (!maestro) return null;
      return {
        ...punto,
        nomenclatura: maestro.nomenclatura,
        // Coordenadas relativas (0 a 1) respecto al plano
        relativeX: punto.coordenada_x,
        relativeY: punto.coordenada_y,
        counts: reportData.value.incidenceCounts.get(punto.id) || { verde: 0, ambar: 0, rojo: 0 }
      };
    }).filter(Boolean);
    
    // El layout ahora trabaja con coordenadas relativas
    labels.value = calculatePlanoLayout(allPoints, { width: img.width, height: img.height }, BADGE_WIDTH_RATIO);
    layoutReady.value = true;
  };
  
  img.onerror = () => { errorState.value = "No se pudo cargar la imagen del plano."; }
  img.src = reportData.value.planoBase64;
};

const handleGeneratePdf = async () => {
    isGenerating.value = true;
    try {
      const img = new Image();
      img.src = reportData.value.planoBase64;
      await new Promise(resolve => img.onload = resolve);

      const originalDimensions = {
          width: img.width,
          height: img.height
      };
      // Pasamos las etiquetas con coordenadas relativas y las dimensiones originales
      await generatePlanPdf(inspeccionId, labels.value, originalDimensions);
    } catch (error) {
        console.error("Error al generar el PDF del plano:", error);
        alert("Hubo un error al generar el plano. Revisa la consola.");
    } finally {
        isGenerating.value = false;
    }
};

const onMouseDown = (label, event) => {
  draggedLabel.value = label;
  const containerRect = planoContainer.value.getBoundingClientRect();
  const badgeWidthPx = mapDimensions.value.width * BADGE_WIDTH_RATIO;
  const badgeHeightPx = badgeWidthPx * BADGE_ASPECT_RATIO;
  
  const currentLeftPx = label.position.x * mapDimensions.value.width + mapDimensions.value.x - (badgeWidthPx / 2);
  const currentTopPx = label.position.y * mapDimensions.value.height + mapDimensions.value.y - (badgeHeightPx / 2);
  
  dragOffset.value = {
    x: event.clientX - containerRect.left - currentLeftPx,
    y: event.clientY - containerRect.top - currentTopPx
  };
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
};

const onMouseMove = (event) => {
  if (!draggedLabel.value) return;
  const containerRect = planoContainer.value.getBoundingClientRect();
  const badgeWidthPx = mapDimensions.value.width * BADGE_WIDTH_RATIO;
  const badgeHeightPx = badgeWidthPx * BADGE_ASPECT_RATIO;

  const newLeftPx = event.clientX - containerRect.left - dragOffset.value.x;
  const newTopPx = event.clientY - containerRect.top - dragOffset.value.y;
  
  draggedLabel.value.position.x = (newLeftPx + (badgeWidthPx / 2) - mapDimensions.value.x) / mapDimensions.value.width;
  draggedLabel.value.position.y = (newTopPx + (badgeHeightPx / 2) - mapDimensions.value.y) / mapDimensions.value.height;
};

const onMouseUp = () => {
  draggedLabel.value = null;
  window.removeEventListener('mousemove', onMouseMove);
  window.removeEventListener('mouseup', onMouseUp);
};
</script>

<template>
  <div class="h-screen w-screen bg-slate-800 flex flex-col">
    <header class="w-full bg-white shadow-md p-3 flex justify-between items-center z-20 flex-shrink-0">
      <div class="text-slate-700">
        <h1 class="font-bold">Editor de Plano</h1>
        <p v-if="reportData" class="text-sm text-slate-500">{{ reportData.inspectionData.centros.nombre }}</p>
      </div>
      <div class="flex items-center gap-4">
        <button @click="router.go(-1)" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <ArrowUturnLeftIcon class="h-4 w-4" /> Volver
        </button>
        <button @click="prepareLayout" :disabled="loading" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold bg-white border border-slate-300 rounded-md hover:bg-slate-50 disabled:opacity-50">
          <ArrowPathIcon class="h-4 w-4" /> Actualizar
        </button>
        <button @click="handleGeneratePdf" :disabled="isGenerating || !layoutReady" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-slate-400">
          <ArrowDownTrayIcon class="h-4 w-4" />
          {{ isGenerating ? 'Generando...' : 'Generar PDF' }}
        </button>
      </div>
    </header>

    <main class="flex-1 p-4 overflow-hidden">
      <div v-if="loading" class="h-full w-full flex items-center justify-center text-white">Cargando previsualización...</div>
      <div v-else-if="errorState" class="h-full w-full flex items-center justify-center text-red-300 bg-red-900/50 p-4 text-center rounded-md">{{ errorState }}</div>
      
      <div v-else ref="planoContainer" class="relative h-full w-full bg-white select-none">
        
        <img
          :src="reportData.planoBase64"
          class="absolute pointer-events-none"
          :style="{ 
            left: `${mapDimensions.x}px`, top: `${mapDimensions.y}px`,
            width: `${mapDimensions.width}px`, height: `${mapDimensions.height}px`
          }"
        >
        
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
          <g v-for="label in labels" :key="'line-' + label.pointData.id">
            <line
              :x1="label.pointData.relativeX * mapDimensions.width + mapDimensions.x"
              :y1="label.pointData.relativeY * mapDimensions.height + mapDimensions.y"
              :x2="label.position.x * mapDimensions.width + mapDimensions.x"
              :y2="label.position.y * mapDimensions.height + mapDimensions.y"
              stroke="#94a3b8"
              stroke-width="1"
            />
          </g>
        </svg>
        
        <div
          v-for="label in labels"
          :key="'badge-' + label.pointData.id"
          v-show="layoutReady"
          @mousedown.prevent="onMouseDown(label, $event)"
          class="z-20 absolute"
          :style="{
            width: `${mapDimensions.width * BADGE_WIDTH_RATIO}px`,
            height: `${mapDimensions.width * BADGE_WIDTH_RATIO * BADGE_ASPECT_RATIO}px`,
            left: `${label.position.x * mapDimensions.width + mapDimensions.x - (mapDimensions.width * BADGE_WIDTH_RATIO / 2)}px`,
            top: `${label.position.y * mapDimensions.height + mapDimensions.y - (mapDimensions.width * BADGE_WIDTH_RATIO * BADGE_ASPECT_RATIO / 2)}px`,
          }"
        >
            <PlanoBadge :pointData="label.pointData" />
        </div>
      </div>
    </main>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/PlanoPreviewView.vue ---

--- INICIO DEL ARCHIVO: src/views/InspeccionesListView.vue ---
<!-- src/views/InspeccionesListView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRouter } from 'vue-router';
import { supabase } from '../supabase';

const router = useRouter();
const showNotification = inject('showNotification');
const centros = ref([]);
const loading = ref(true);
const isStarting = ref(false);
const searchTerm = ref('');
const tecnicoNombre = ref('');
const fechaInspeccion = ref(new Date().toISOString().slice(0, 10));

const filteredCentros = computed(() => {
  if (!searchTerm.value) return centros.value;
  return centros.value.filter(centro =>
    centro.nombre.toLowerCase().includes(searchTerm.value.toLowerCase())
  );
});

// === INICIO DE LA LÓGICA CORREGIDA ===
const startInspection = async (centroId) => {
  if (!tecnicoNombre.value.trim()) {
    showNotification('Por favor, introduce el nombre del técnico para continuar.', 'warning');
    return;
  }
  if (!fechaInspeccion.value) {
    showNotification('Por favor, selecciona una fecha de inspección.', 'warning');
    return;
  }
  const today = new Date().toISOString().slice(0, 10);
  if (fechaInspeccion.value > today) {
    showNotification('La fecha de inspección no puede ser futura.', 'warning');
    return;
  }
  isStarting.value = true;

  // 1. Buscar la VERSIÓN ACTIVA para el centro seleccionado.
  const { data: activeVersion, error: versionError } = await supabase
    .from('versiones_plano')
    .select('id')
    .eq('centro_id', centroId)
    .eq('es_activa', true)
    .single();

  if (versionError || !activeVersion) {
    showNotification('Error: Este centro no tiene una versión de plano activa. Por favor, configúralo en el Maestro de Centros.', 'error');
    console.error("Error buscando versión activa:", versionError);
    isStarting.value = false;
    return;
  }
  const versionId = activeVersion.id;

  // 2. Buscar si ya existe una inspección en progreso para este centro
  let { data: inspection, error: findError } = await supabase
    .from('inspecciones')
    .select('id')
    .eq('centro_id', centroId)
    .eq('estado', 'en_progreso')
    .maybeSingle();

  if (findError) {
    showNotification('Error buscando inspección existente: ' + findError.message, 'error');
    isStarting.value = false;
    return;
  }

  // 3. Si no existe, crear una nueva asociándola a la versión activa
  if (!inspection) {
    const { data: newInspection, error: createError } = await supabase
      .from('inspecciones')
      .insert({
        centro_id: centroId,
        version_id: versionId, // <-- Guardamos la versión correcta
        estado: 'en_progreso',
        tecnico_nombre: tecnicoNombre.value.trim(),
        fecha_inspeccion: fechaInspeccion.value
      })
      .select('id')
      .single();

    if (createError) {
      showNotification('Error creando inspección: ' + createError.message, 'error');
      isStarting.value = false;
      return;
    }
    inspection = newInspection;
  } else {
    // Si ya existía, la actualizamos para asegurarnos de que usa la última versión activa
     await supabase.from('inspecciones').update({
       tecnico_nombre: tecnicoNombre.value.trim(),
       fecha_inspeccion: fechaInspeccion.value,
       version_id: versionId // <-- Actualizamos también la versión
     }).eq('id', inspection.id);
  }

  // 4. Navegar a la página de detalle
  router.push(`/inspecciones/${inspection.id}`);
};
// === FIN DE LA LÓGICA CORREGIDA ===

onMounted(async () => {
  loading.value = true;
  const { data } = await supabase.from('centros').select('id, nombre').order('nombre');
  if (data) centros.value = data;
  loading.value = false;
});
</script>

<template>
  <div class="p-8">
    <h1 class="text-4xl font-bold text-slate-800 mb-8">Iniciar Inspección</h1>
    <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 max-w-3xl mx-auto">
      
      <div class="mb-6">
        <label for="tecnico" class="block text-sm font-medium text-slate-700 mb-1">Nombre del Técnico</label>
        <input
          v-model="tecnicoNombre"
          id="tecnico"
          type="text"
          placeholder="Escribe tu nombre..."
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>

      <div class="mb-6">
        <label for="fecha" class="block text-sm font-medium text-slate-700 mb-1">Fecha de Inspección</label>
        <input
          v-model="fechaInspeccion"
          id="fecha"
          type="date"
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>

      <div>
        <label for="search" class="block text-sm font-medium text-slate-700 mb-1">Buscar y Seleccionar Centro</label>
        <input 
          v-model="searchTerm" 
          id="search" 
          type="search" 
          placeholder="Escribe para buscar un centro..." 
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>
      
      <div class="mt-4 max-h-60 overflow-y-auto border rounded-md">
        <div v-if="loading" class="p-4 text-center text-slate-500">Cargando centros...</div>
        <ul v-else-if="filteredCentros.length > 0">
          <li v-for="centro in filteredCentros" :key="centro.id" class="border-b last:border-b-0">
            <button 
              @click="startInspection(centro.id)" 
              :disabled="isStarting"
              class="w-full text-left p-4 hover:bg-blue-50 transition-colors disabled:bg-slate-100 disabled:cursor-wait"
            >
              {{ centro.nombre }}
            </button>
          </li>
        </ul>
        <div v-else class="p-4 text-center text-slate-500">No se encontraron centros.</div>
      </div>

    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/InspeccionesListView.vue ---

--- INICIO DEL ARCHIVO: src/views/GestionView.vue ---
<!-- src/views/GestionView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
import SkeletonLoader from '../components/SkeletonLoader.vue';
import GrupoVisitaEditable from '../components/GrupoVisitaEditable.vue';
// ===== CAMBIO 1: Importamos la nueva función para generar Excel =====
import { generateGestionExcel } from '../utils/excel/excel-module-gestion';
import { ArrowPathIcon, MagnifyingGlassIcon, ArrowDownTrayIcon } from '@heroicons/vue/24/solid';

const showNotification = inject('showNotification');
const router = useRouter();

const loading = ref(true);
const refreshing = ref(false);
const isGeneratingExcel = ref(false); // Renombramos la variable de estado
const resumenData = ref([]);
const searchTerm = ref('');

const filteredData = computed(() => {
  if (!searchTerm.value) {
    return resumenData.value;
  }
  const searchLower = searchTerm.value.toLowerCase();
  return resumenData.value.filter(item => 
    item.centro_nombre.toLowerCase().includes(searchLower)
  );
});

const estadoInfo = (estado) => {
  switch (estado) {
    case 'en_progreso': return { text: 'En Progreso', class: 'bg-blue-100 text-blue-800' };
    case 'finalizada': return { text: 'Pend. Envío', class: 'bg-orange-100 text-orange-800' };
    case 'pendiente_subsanacion': return { text: 'Pend. Cierre', class: 'bg-yellow-100 text-yellow-800' };
    case 'cerrada': return { text: 'Cerrada', class: 'bg-green-100 text-green-800' };
    default: return { text: 'Sin Inspección', class: 'bg-slate-100 text-slate-600' };
  }
};

const fetchData = async () => {
  const { data, error } = await supabase
    .from('vista_gestion_centros')
    .select('*');
  
  if (error) {
    showNotification(`Error al cargar los datos: ${error.message}`, 'error');
    console.error(error);
    return [];
  }
  return data;
};

const refreshView = async () => {
  refreshing.value = true;
  const { error: rpcError } = await supabase.rpc('refrescar_vista_gestion');
  if (rpcError) {
    showNotification(`Error al refrescar los datos: ${rpcError.message}`, 'error');
  } else {
    resumenData.value = await fetchData();
    showNotification('Datos actualizados correctamente.', 'success');
  }
  refreshing.value = false;
};

const handleSaveGrupo = async ({ inspeccionId, newValue }) => {
  const { error } = await supabase
    .from('inspecciones')
    .update({ grupo_visita: newValue })
    .eq('id', inspeccionId);

  if (error) {
    showNotification('Error al guardar el grupo: ' + error.message, 'error');
  } else {
    const item = resumenData.value.find(i => i.inspeccion_id === inspeccionId);
    if (item) item.grupo_visita = newValue;
    showNotification('Grupo de visita guardado.', 'success', 2000);
  }
};

// ===== CAMBIO 2: La función ahora llama al generador de Excel =====
const handleDownloadExcel = async () => {
  isGeneratingExcel.value = true;
  showNotification('Generando archivo XLSX, por favor espera...', 'info');
  try {
    await generateGestionExcel(filteredData.value);
  } catch (error) {
    showNotification('Hubo un error al generar el archivo Excel.', 'error');
  } finally {
    isGeneratingExcel.value = false;
  }
};

onMounted(async () => {
  loading.value = true;
  resumenData.value = await fetchData();
  loading.value = false;
});

</script>

<template>
  <div class="p-4 md:p-8">
    <div class="flex flex-col md:flex-row justify-between md:items-center mb-6 gap-4">
      <h1 class="text-3xl md:text-4xl font-bold text-slate-800">Panel de Gestión Anual</h1>
      
      <div class="flex items-center gap-x-2 w-full md:w-auto">
        <div class="relative flex-grow">
          <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
            <MagnifyingGlassIcon class="h-5 w-5 text-slate-400" />
          </div>
          <input 
            v-model="searchTerm"
            type="search"
            placeholder="Buscar centro..."
            class="block w-full rounded-md border-slate-300 py-2 pl-10 text-sm shadow-sm focus:border-blue-500 focus:ring-blue-500"
          >
        </div>
        <button @click="refreshView" :disabled="refreshing || isGeneratingExcel" class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm flex-shrink-0 disabled:bg-slate-400">
          <ArrowPathIcon class="h-5 w-5" :class="{'animate-spin': refreshing}" />
          <span class="hidden sm:inline">Actualizar</span>
        </button>
        <!-- ===== CAMBIO 3: El botón ahora llama a la función de Excel y tiene un texto más claro ===== -->
        <button @click="handleDownloadExcel" :disabled="refreshing || isGeneratingExcel" class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 shadow-sm flex-shrink-0 disabled:bg-slate-400">
          <ArrowDownTrayIcon class="h-5 w-5" />
          <span class="hidden sm:inline">Descargar XLSX</span>
        </button>
      </div>

    </div>

    <div v-if="loading" class="space-y-2">
      <div v-for="i in 10" :key="i" class="bg-white rounded-lg shadow-sm border border-slate-200 h-16"><SkeletonLoader/></div>
    </div>

    <div v-else class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-x-auto">
      <table class="min-w-full divide-y divide-slate-200 text-sm">
        <thead class="bg-slate-50">
          <tr>
            <th class="sticky left-0 bg-slate-50 px-4 py-3 text-left font-semibold text-slate-600">Centro</th>
            <th class="px-4 py-3 text-left font-semibold text-slate-600">Región</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Última Inspección</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Grupo Visita</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Estado Informe</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Cambios Alineaciones</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Faltan Fichas</th>
            <th colspan="3" class="px-4 py-3 text-center font-semibold text-slate-600 border-l border-r">Daños</th>
            <th class="px-4 py-3 text-left font-semibold text-slate-600"></th>
          </tr>
          <tr class="bg-slate-100">
             <th colspan="7"></th>
             <th class="w-16 text-center font-medium text-xs text-green-700 bg-green-100 py-1">V</th>
             <th class="w-16 text-center font-medium text-xs text-amber-700 bg-amber-100 py-1">A</th>
             <th class="w-16 text-center font-medium text-xs text-red-700 bg-red-100 py-1 border-r">R</th>
             <th></th>
          </tr>
        </thead>
        <tbody class="divide-y divide-slate-200">
          <tr v-for="item in filteredData" :key="item.centro_id" class="hover:bg-slate-50">
            <td class="sticky left-0 bg-white hover:bg-slate-50 px-4 py-3 font-semibold text-slate-800 whitespace-nowrap">
              <router-link :to="`/centros/${item.centro_id}/historial`" class="hover:underline text-blue-700">
                {{ item.centro_nombre }}
              </router-link>
            </td>
            <td class="px-4 py-3 text-slate-600 whitespace-nowrap">{{ item.region }}</td>
            <td class="px-4 py-3 text-center text-slate-600 whitespace-nowrap">
              {{ item.fecha_inspeccion ? new Date(item.fecha_inspeccion + 'T00:00:00').toLocaleDateString() : '-' }}
            </td>
            <td class="px-4 py-3 text-center text-slate-800">
              <GrupoVisitaEditable :value="item.grupo_visita" :inspeccion-id="item.inspeccion_id" @save="handleSaveGrupo" />
            </td>
            <td class="px-4 py-3 text-center">
              <span :class="['inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium', estadoInfo(item.estado_informe).class]">
                {{ estadoInfo(item.estado_informe).text }}
              </span>
            </td>
            <td class="px-4 py-3 text-center font-medium text-slate-800">{{ item.cambios_en_alineaciones }}</td>
            <td class="px-4 py-3 text-center font-medium" :class="item.faltan_fichas ? 'text-red-600' : 'text-slate-800'">
              {{ item.faltan_fichas ? 'SI' : 'NO' }}
            </td>
            <td class="px-4 py-3 text-center font-bold text-green-600 bg-green-50/50">{{ item.danos_verdes }}</td>
            <td class="px-4 py-3 text-center font-bold text-amber-600 bg-amber-50/50">{{ item.danos_ambares }}</td>
            <td class="px-4 py-3 text-center font-bold text-red-600 bg-red-50/50 border-r">{{ item.danos_rojos }}</td>
            <td class="px-4 py-3 text-center">
              <router-link :to="`/centros/${item.centro_id}/historial`" class="font-semibold text-blue-600 hover:text-blue-800">
                Ver
              </router-link>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/GestionView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroConfigView.vue ---
<!-- src/views/CentroConfigView.vue -->
<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import { ArrowPathIcon, ArrowUpTrayIcon, PlusIcon, TrashIcon, MapIcon, XCircleIcon, PencilIcon, CheckCircleIcon, InformationCircleIcon, BackspaceIcon } from '@heroicons/vue/24/solid';
import NomenclatureModal from '../components/NomenclatureModal.vue';

const route = useRoute();
const router = useRouter();
const versionId = route.params.id;

const loading = ref(true);
const version = ref(null);
const centro = ref(null);
const puntos = ref([]);
const salas = ref([]);
const activeSalaId = ref(null);
const newSalaName = ref('');
const fileInput = ref(null);

const isDrawingMode = ref(false);
const isPointEditingMode = ref(false);
const isSavingArea = ref(false);
const channel = ref(null);
const activeSala = computed(() => salas.value.find(s => s.id === activeSalaId.value));

const isNomenclatureModalOpen = ref(false);
const newPointCoords = ref(null);

const existingIdentifiersInActiveSala = computed(() => {
    if (!activeSalaId.value) return [];
    return puntos.value
        .filter(p => p.sala_id === activeSalaId.value)
        .map(p => p.nomenclatura.split('-').pop() || '');
});

// --- INICIO DE LA CORRECCIÓN: Lógica de sugerencia de número robusta ---
const suggestedNextNumber = computed(() => {
    if (!activeSalaId.value) return 1;

    // 1. Filtramos los identificadores para quedarnos solo con aquellos
    //    que son representaciones de números enteros puros.
    const numericIdentifiers = existingIdentifiersInActiveSala.value
        .filter(id => {
            const num = parseInt(id, 10);
            // La condición clave: un identificador es puramente numérico si al convertirlo a número
            // y luego de vuelta a string, es idéntico al original.
            // "1" -> parseInt -> 1 -> String -> "1". ('1' === '1') -> true.
            // "1,2" -> parseInt -> 1 -> String -> "1". ('1' === '1,2') -> false.
            // "Picking" -> parseInt -> NaN. -> false.
            return !isNaN(num) && String(num) === id;
        })
        // 2. Convertimos los strings validados a números reales.
        .map(id => parseInt(id, 10));

    if (numericIdentifiers.length === 0) return 1;

    // 3. El resto de la lógica para encontrar el siguiente número disponible funciona perfectamente.
    const sortedNumbers = [...numericIdentifiers].sort((a, b) => a - b);
    
    for (let i = 0; i < sortedNumbers.length; i++) {
        if (sortedNumbers[i] !== i + 1) {
            return i + 1;
        }
    }
    return sortedNumbers.length + 1;
});
// --- FIN DE LA CORRECCIÓN ---


const instructionText = computed(() => {
    if (isDrawingMode.value) {
        const salaName = activeSala.value?.nombre || 'la sala';
        return `Definiendo área para "${salaName}": Haz clic para añadir puntos. Haz clic en el primer punto para cerrar la forma.`;
    }
    if (isPointEditingMode.value) {
        const salaName = activeSala.value?.nombre || 'NINGUNA';
        return `Modo Edición de Puntos: Haz clic en el plano para añadir puntos en la sala "${salaName.toUpperCase()}".`;
    }
    return null;
});

onMounted(async () => {
  loading.value = true;
  const { data: versionData } = await supabase.from('versiones_plano').select('*, centros(*)').eq('id', versionId).single();
  if (!versionData) {
    alert("Error: No se pudo cargar la versión del plano o no existe.");
    loading.value = false; return;
  }
  version.value = versionData;
  centro.value = versionData.centros;
  const [salasRes, puntosRes] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', versionId).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', versionId)
  ]);
  salas.value = salasRes.data || [];
  puntos.value = puntosRes.data || [];
  if (salas.value.length > 0 && !activeSalaId.value) {
      activeSalaId.value = salas.value[0].id;
  }
  loading.value = false;

  // Suscripción en tiempo real
  channel.value = supabase.channel(`version-${versionId}`)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'salas', filter: `version_id=eq.${versionId}` }, (payload) => {
      if (payload.eventType === 'INSERT') {
        salas.value.push(payload.new);
        salas.value.sort((a, b) => a.nombre.localeCompare(b.nombre));
      } else if (payload.eventType === 'UPDATE') {
        const index = salas.value.findIndex(s => s.id === payload.new.id);
        if (index !== -1) salas.value[index] = payload.new;
      } else if (payload.eventType === 'DELETE') {
        salas.value = salas.value.filter(s => s.id !== payload.old.id);
        if (activeSalaId.value === payload.old.id) {
          activeSalaId.value = salas.value.length > 0 ? salas.value[0].id : null;
        }
      }
    })
    .on('postgres_changes', { event: '*', schema: 'public', table: 'puntos_maestros', filter: `version_id=eq.${versionId}` }, (payload) => {
      if (payload.eventType === 'INSERT') {
        puntos.value.push(payload.new);
      } else if (payload.eventType === 'UPDATE') {
        const index = puntos.value.findIndex(p => p.id === payload.new.id);
        if (index !== -1) puntos.value[index] = payload.new;
      } else if (payload.eventType === 'DELETE') {
        puntos.value = puntos.value.filter(p => p.id !== payload.old.id);
      }
    })
    .subscribe();
});

onUnmounted(() => {
  if (channel.value) {
    channel.value.unsubscribe();
  }
});

const togglePointEditingMode = () => {
    if (!isPointEditingMode.value && !activeSalaId.value) {
        alert('Por favor, selecciona primero una sala para empezar a editar sus puntos.');
        return;
    }
    isPointEditingMode.value = !isPointEditingMode.value;
    isDrawingMode.value = false;
};

const cancelAllModes = () => {
    isDrawingMode.value = false;
    isPointEditingMode.value = false;
};

const onFileSelected = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const fileName = `planos/centro_${centro.value.id}/version_${versionId}/${Date.now()}_${file.name}`;
    
    const { error: uploadError } = await supabase.storage.from('planos-clientes').upload(fileName, file, { upsert: true });
    if (uploadError) {
      alert("Error al subir el plano: " + uploadError.message);
      return;
    }
    const { data: { publicUrl } } = supabase.storage.from('planos-clientes').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('versiones_plano').update({ url_imagen_plano: publicUrl }).eq('id', versionId);
    if(updateError) {
        alert("Error al guardar la URL del plano: " + updateError.message);
    } else {
        version.value.url_imagen_plano = publicUrl;
        alert("Plano actualizado correctamente.");
    }
};


const enterDrawingMode = () => {
  if (!activeSalaId.value) { 
    alert("Selecciona una sala para poder definir su área."); 
    return; 
  }
  isDrawingMode.value = true;
  isPointEditingMode.value = false;
};

const handleAreaDrawn = async (points) => {
    console.log('Area drawn for sala', activeSalaId.value, 'points:', points);
    if (!activeSalaId.value) return;
    isSavingArea.value = true;
    try {
        console.log('Updating sala', activeSalaId.value, 'with points', points);
        const { error } = await supabase.from('salas').update({ area_puntos: points }).eq('id', activeSalaId.value);
        if (error) throw error;
        console.log('Area saved successfully');
        const sala = salas.value.find(s => s.id === activeSalaId.value);
        if (sala) sala.area_puntos = points;
        isDrawingMode.value = false;
    } catch (error) {
        console.error('Error saving area:', error);
        alert('Error al guardar el área: ' + error.message);
    } finally {
        isSavingArea.value = false;
    }
};

const clearArea = async () => {
    if (!activeSalaId.value) return;
    const { error } = await supabase.from('salas').update({ area_puntos: null }).eq('id', activeSalaId.value);
    if (error) {
        alert('Error al limpiar el área: ' + error.message);
    } else {
        const sala = salas.value.find(s => s.id === activeSalaId.value);
        if (sala) sala.area_puntos = null;
    }
};


const handleMapClick = (coords) => {
  if (isPointEditingMode.value) {
    newPointCoords.value = coords;
    isNomenclatureModalOpen.value = true;
  }
};

const handleSaveNomenclature = async (pointIdentifier) => {
  isNomenclatureModalOpen.value = false;
  const coords = newPointCoords.value;
  if (!coords || !activeSalaId.value) return;

  const sala = salas.value.find(s => s.id === activeSalaId.value);
  const newNomenclature = `${sala.nombre}-${pointIdentifier}`;

  const { data, error } = await supabase.from('puntos_maestros').insert({ 
    version_id: versionId, 
    sala_id: activeSalaId.value, 
    nomenclatura: newNomenclature, 
    coordenada_x: coords.x, 
    coordenada_y: coords.y
  }).select().single();
  
  if (data) {
    puntos.value.push(data);
  } else if (error) {
    alert(error.message);
  }
  newPointCoords.value = null;
};

const handleDeletePoint = async (point) => {
    if (confirm(`¿Estás seguro de que quieres borrar el punto "${point.nomenclatura}" de este plano?`)) {
        const { error } = await supabase.from('puntos_maestros').delete().eq('id', point.id);
        if (error) {
            alert('Error al borrar el punto: ' + error.message);
        } else {
            puntos.value = puntos.value.filter(p => p.id !== point.id);
        }
    }
};

const addSala = async () => {
  const name = newSalaName.value.trim();
  if (!name) {
    alert('El nombre de la sala no puede estar vacío.');
    return;
  }
  
  const nameExists = salas.value.some(s => s.nombre.toLowerCase() === name.toLowerCase());
  if (nameExists) {
    alert(`La sala "${name}" ya existe en esta versión del plano.`);
    return;
  }

  const { data: newSala, error } = await supabase
    .from('salas')
    .insert({
      version_id: versionId,
      nombre: name,
      color: '#CCCCCC' // Un color gris por defecto
    })
    .select()
    .single();

  if (error) {
    alert('Error al crear la nueva sala: ' + error.message);
  } else {
    salas.value.push(newSala);
    salas.value.sort((a, b) => a.nombre.localeCompare(b.nombre)); // Mantener el orden alfabético
    newSalaName.value = ''; // Limpiar el input
  }
};

const deleteSala = async (salaId) => {
  const sala = salas.value.find(s => s.id === salaId);
  if (!sala) return;
  
  const puntosEnSala = puntos.value.filter(p => p.sala_id === salaId).length;
  if (puntosEnSala > 0) {
    alert(`No se puede borrar la sala "${sala.nombre}" porque contiene ${puntosEnSala} puntos. Bórralos primero.`);
    return;
  }

  if (confirm(`¿Estás seguro de que quieres borrar la sala "${sala.nombre}"? Esta acción no se puede deshacer.`)) {
    const { error } = await supabase.from('salas').delete().eq('id', salaId);

    if (error) {
      alert('Error al borrar la sala: ' + error.message);
    } else {
      salas.value = salas.value.filter(s => s.id !== salaId);
      if (activeSalaId.value === salaId) {
        activeSalaId.value = salas.value.length > 0 ? salas.value[0].id : null;
      }
    }
  }
};

const handleUpdatePosition = async (point) => {
  const { error } = await supabase
    .from('puntos_maestros')
    .update({ 
        coordenada_x: point.coordenada_x, 
        coordenada_y: point.coordenada_y 
    })
    .eq('id', point.id);

  if (error) {
    alert('Error al actualizar la posición del punto: ' + error.message);
    // Opcional: recargar los datos para revertir el cambio visual
    // fetchData(); 
  }
};

const saveSalaColor = async (sala) => {
  await supabase.from('salas').update({ color: sala.color }).eq('id', sala.id);
};
</script>


<template>
  <div class="p-4 sm:p-8 h-full flex flex-col">
    <input type="file" @change="onFileSelected" accept="image/*" class="hidden" ref="fileInput">
    <div v-if="loading" class="flex justify-center items-center h-full">Cargando...</div>
    <div v-else-if="centro && version" class="flex-1 flex flex-col">
      <div v-if="version.url_imagen_plano" class="flex-1 flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-start mb-6 gap-4">
          <div>
            <h1 class="text-3xl font-bold text-slate-800">Configurar: {{ centro.nombre }}</h1>
            <p class="text-slate-600 mt-2">
              Editando versión: <strong class="text-blue-600">{{ version.nombre }}</strong> 
              <span v-if="version.es_activa" class="ml-2 text-xs font-bold text-green-700 bg-green-100 px-2 py-0.5 rounded-full">ACTIVA</span>
              <span v-else class="ml-2 text-xs font-bold text-slate-700 bg-slate-100 px-2 py-0.5 rounded-full">ARCHIVADA</span>
            </p>
          </div>
          <div class="flex gap-2 flex-shrink-0">
             <button @click="fileInput.click()" class="flex items-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <ArrowPathIcon class="h-5 w-5" /> Cambiar Plano
             </button>
             <button v-if="isDrawingMode || isPointEditingMode" @click="cancelAllModes" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
                <XCircleIcon class="h-5 w-5" /> Cancelar
             </button>
            <button @click="router.push(`/centros/${centro.id}/versiones`)" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">Volver a Versiones</button>
          </div>
        </div>
        
        <div class="flex-grow h-full grid grid-cols-1 lg:grid-cols-4 gap-8">
          <div class="lg:col-span-1 lg:sticky lg:top-8 self-start bg-white rounded-xl shadow-sm border border-slate-200 p-4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-slate-800">Salas</h2>
                <button 
                    @click="togglePointEditingMode" 
                    :disabled="salas.length === 0"
                    :class="[
                        'flex items-center gap-1.5 px-2.5 py-1 text-xs font-semibold text-white rounded-md transition-colors',
                        'disabled:bg-slate-400 disabled:cursor-not-allowed',
                        isPointEditingMode ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'
                    ]">
                    <component :is="isPointEditingMode ? CheckCircleIcon : PencilIcon" class="h-4 w-4" />
                    {{ isPointEditingMode ? 'Finalizar Edición' : 'Gestionar Puntos' }}
                </button>
            </div>
            <ul class="space-y-2">
              <li v-for="sala in salas" :key="sala.id">
                <div @click="activeSalaId = sala.id" :class="['w-full p-3 rounded-lg transition-colors flex justify-between items-center group cursor-pointer', activeSalaId === sala.id ? 'bg-blue-100 ring-2 ring-blue-300' : 'hover:bg-slate-100']">
                  <div class="flex items-center gap-3">
                    <input type="color" v-model="sala.color" @input="saveSalaColor(sala)" class="w-6 h-6 p-0 border-none rounded-md cursor-pointer flex-shrink-0">
                    <span class="font-semibold" :class="{'text-blue-800': activeSalaId === sala.id}">{{ sala.nombre }}</span>
                  </div>
                </div>
                <div v-if="activeSalaId === sala.id" class="pl-10 pt-1 pb-2 flex items-center space-x-4">
                    <button @click="enterDrawingMode" :disabled="isPointEditingMode || isSavingArea" class="flex items-center gap-1.5 text-xs text-blue-600 hover:text-blue-800 disabled:text-slate-400 disabled:cursor-not-allowed">
                       <MapIcon class="h-4 w-4" /> <span>Definir Área</span>
                     </button>
                     <button v-if="sala.area_puntos" @click="clearArea" :disabled="isPointEditingMode || isSavingArea" class="flex items-center gap-1.5 text-xs text-red-600 hover:text-red-800 disabled:text-slate-400 disabled:cursor-not-allowed">
                        <XCircleIcon class="h-4 w-4" /> <span>Limpiar</span>
                     </button>
                     <button @click="deleteSala(sala.id)" :disabled="isPointEditingMode || isSavingArea" class="flex items-center gap-1.5 text-xs text-slate-500 hover:text-red-600 disabled:text-slate-400 disabled:cursor-not-allowed">
                        <TrashIcon class="h-4 w-4" /> <span>Borrar</span>
                     </button>
                 </div>
              </li>
            </ul>
            <form @submit.prevent="addSala" class="mt-4 flex-shrink-0 flex gap-2">
              <input v-model="newSalaName" type="text" placeholder="Nueva sala..." class="flex-1 block w-full rounded-md border-slate-300 shadow-sm text-sm">
              <button type="submit" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                <PlusIcon class="h-5 w-5" />
              </button>
            </form>
          </div>
          
          <div class="lg:col-span-3 relative">
            <div v-if="instructionText" class="bg-blue-600 text-white text-sm font-semibold py-2 px-4 flex items-center gap-2 mb-4">
              <InformationCircleIcon class="h-5 w-5 flex-shrink-0" />
              <span>{{ instructionText }}</span>
            </div>
            <InteractiveMap
              class="h-full"
              :image-url="version.url_imagen_plano"
              :points="puntos"
              :salas="salas"
              :is-read-only="!isPointEditingMode && !isDrawingMode"
              :is-placement-mode="isPointEditingMode"
              :is-area-drawing-mode="isDrawingMode"
              @add-point="handleMapClick"
              @delete-point="handleDeletePoint"
              @update-point-position="handleUpdatePosition"
              @area-drawn="handleAreaDrawn"
              @drawing-cancelled="cancelAllModes"
            />
          </div>
        </div>
      </div>
      
      <div v-else class="flex-1 flex flex-col items-center justify-center">
         <div class="max-w-3xl mx-auto text-center">
          <h1 class="text-3xl font-bold text-slate-800">Se necesita un plano para esta versión</h1>
          <p class="text-slate-600 mt-4 text-lg">La versión <strong class="text-blue-600">{{ version.nombre }}</strong> no tiene un plano asignado.</p>
        </div>
        <div class="mt-8 max-w-lg w-full mx-auto bg-white p-8 rounded-lg shadow-md border">
          <button @click="fileInput.click()" class="w-full flex flex-col items-center justify-center gap-4 p-6 border-2 border-dashed border-slate-300 rounded-lg hover:bg-slate-50 transition-colors">
            <ArrowUpTrayIcon class="h-10 w-10 text-slate-400" />
            <span class="text-slate-500 font-medium">Haz clic aquí para seleccionar un archivo</span>
          </button>
        </div>
        <div class="text-center mt-8">
          <button @click="router.push(`/centros/${centro.id}/versiones`)" class="font-semibold text-slate-600 hover:text-slate-800">Volver a Versiones</button>
        </div>
      </div>
    </div>

    <NomenclatureModal
      :is-open="isNomenclatureModalOpen"
      :sala-nombre="activeSala?.nombre"
      :suggested-number="suggestedNextNumber"
      :existing-identifiers="existingIdentifiersInActiveSala"
      @close="isNomenclatureModalOpen = false"
      @save="handleSaveNomenclature"
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroConfigView.vue ---

--- INICIO DEL ARCHIVO: src/composables/useOnlineStatus.js ---
// src/composables/useOnlineStatus.js
import { ref, onMounted, onUnmounted } from 'vue';

export function useOnlineStatus() {
  const isOnline = ref(navigator.onLine);

  const updateOnlineStatus = () => {
    isOnline.value = navigator.onLine;
  };

  onMounted(() => {
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
  });

  onUnmounted(() => {
    window.removeEventListener('online', updateOnlineStatus);
    window.removeEventListener('offline', updateOnlineStatus);
  });

  return { isOnline };
}
--- FIN DEL ARCHIVO: src/composables/useOnlineStatus.js ---

--- INICIO DEL ARCHIVO: src/composables/useInspections.js ---
// src/composables/useInspections.js

import { ref, onMounted, onUnmounted, readonly } from 'vue';
import { supabase } from '../supabase';
import { createLogger } from '../utils/logger';

const logger = createLogger('Inspections');

// Web Worker for processing inspection details
const createProcessingWorker = () => {
  const workerCode = `
    self.onmessage = function(e) {
      const { puntosData } = e.data;

      const salasMap = new Map();
      const salaCountsMap = new Map();

      puntosData.forEach(punto => {
        const salaId = punto.puntos_maestros?.sala_id;
        const salaNombre = punto.puntos_maestros?.salas?.nombre;
        if (salaId && salaNombre) {
          if (!salasMap.has(salaId)) {
            salasMap.set(salaId, { id: salaId, nombre: salaNombre, puntos: [] });
            salaCountsMap.set(salaId, { verde: 0, ambar: 0, rojo: 0 });
          }
          const counts = { verde: 0, ambar: 0, rojo: 0 };
          (punto.incidencias || []).forEach(inc => {
            if (counts[inc.gravedad] !== undefined) counts[inc.gravedad]++;
          });
          salasMap.get(salaId).puntos.push({ ...punto, counts });
          const salaCounts = salaCountsMap.get(salaId);
          salaCounts.verde += counts.verde;
          salaCounts.ambar += counts.ambar;
          salaCounts.rojo += counts.rojo;
        }
      });

      const salasConPuntos = Array.from(salasMap.values()).map(sala => ({
        ...sala,
        puntos: sala.puntos.sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true})),
        counts: salaCountsMap.get(sala.id)
      })).filter(s => s.puntos.length > 0);

      self.postMessage({ salasConPuntos });
    };
  `;

  const blob = new Blob([workerCode], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
};

export function useInspections(centroId) {
  const loading = ref(true);
  const loadingMore = ref(false);
  const centro = ref(null);
  const inspecciones = ref([]);
  const realtimeSubscription = ref(null);
  const availableYears = ref([]);
  
  const pageSize = 20;
  const currentPage = ref(1);
  const totalInspecciones = ref(0);
  const hasMorePages = ref(false);

  const CACHE_KEY = `inspections_${centroId}`;
  const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  const getCachedData = () => {
    try {
      const cached = localStorage.getItem(CACHE_KEY);
      if (cached) {
        const { data, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp < CACHE_DURATION) return data;
      }
    } catch (error) { logger.warn('Error reading cache:', error); }
    return null;
  };

  const setCachedData = (data) => {
    try {
      const cacheData = { data, timestamp: Date.now() };
      localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
    } catch (error) { logger.warn('Error writing cache:', error); }
  };

  const fetchData = async (page = 1, append = false, silent = false) => {
    if (!append && !silent) loading.value = true;
    else if (append && !silent) loadingMore.value = true;

    if (page === 1 && !append) {
      const cachedData = getCachedData();
      if (cachedData) {
        centro.value = cachedData.centro;
        inspecciones.value = cachedData.inspecciones;
        totalInspecciones.value = cachedData.totalInspecciones;
        availableYears.value = cachedData.availableYears;
        hasMorePages.value = cachedData.hasMorePages;
        loading.value = false;
        return;
      }
    }

    const [centroRes, countRes] = await Promise.all([
      supabase.from('centros').select('nombre').eq('id', centroId).single(),
      supabase.from('inspecciones').select('id', { count: 'exact', head: true }).eq('centro_id', centroId)
    ]);

    centro.value = centroRes.data;
    totalInspecciones.value = countRes.count || 0;

    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    const { data: inspeccionesData } = await supabase
      .from('inspecciones')
      .select('id, fecha_inspeccion, estado, tecnico_nombre, centro_id, fecha_envio_cliente, responsable_envio_cliente, url_pdf_informe_inicial, url_pdf_informe_final, versiones_plano(id, nombre)')
      .eq('centro_id', centroId)
      .order('fecha_inspeccion', { ascending: false })
      .range(from, to);

    if (!inspeccionesData) {
      if (!append) inspecciones.value = [];
      loading.value = false;
      loadingMore.value = false;
      return;
    }

    const inspectionIds = inspeccionesData.map(i => i.id);
    const countsMap = new Map();
    inspectionIds.forEach(id => countsMap.set(id, { verde: 0, ambar: 0, rojo: 0 }));

    if (inspectionIds.length > 0) {
      const { data: countsData } = await supabase.from('incidencias').select('inspeccion_id, gravedad').in('inspeccion_id', inspectionIds);
      if (countsData) {
        countsData.forEach(inc => {
          const counts = countsMap.get(inc.inspeccion_id);
          if (counts && counts[inc.gravedad] !== undefined) counts[inc.gravedad]++;
        });
      }
    }

    const processedInspections = inspeccionesData.map(inspeccion => ({
      ...inspeccion,
      details: [],
      totalCounts: countsMap.get(inspeccion.id) || { verde: 0, ambar: 0, rojo: 0 }
    }));

    if (append) inspecciones.value.push(...processedInspections);
    else inspecciones.value = processedInspections;
    
    hasMorePages.value = (page * pageSize) < totalInspecciones.value;
    
    if (inspecciones.value.length > 0) {
      const years = new Set(inspecciones.value.map(i => new Date(i.fecha_inspeccion).getFullYear()));
      availableYears.value = Array.from(years).sort((a, b) => b - a);
    }

    if (page === 1 && !append) {
      setCachedData({ centro: centro.value, inspecciones: inspecciones.value, totalInspecciones: totalInspecciones.value, availableYears: availableYears.value, hasMorePages: hasMorePages.value });
    }

    if (!silent) {
      loading.value = false;
      loadingMore.value = false;
    }
  };

  const loadInspectionDetails = async (inspeccionId) => {
    const inspeccion = inspecciones.value.find(i => i.id === inspeccionId);
    if (!inspeccion || (inspeccion.details && inspeccion.details.length > 0)) return;

    const { data: puntosData } = await supabase.from('puntos_inspeccionados').select('id, nomenclatura, puntos_maestros!inner(id, sala_id, salas!inner(id, nombre)), incidencias(gravedad)').eq('inspeccion_id', inspeccionId);
    if (!puntosData) return;

    const worker = createProcessingWorker();
    worker.onmessage = (e) => {
      const { salasConPuntos } = e.data;
      const index = inspecciones.value.findIndex(i => i.id === inspeccionId);
      if (index !== -1) {
        inspecciones.value[index].details = salasConPuntos;
      }
      worker.terminate();
    };
    worker.postMessage({ puntosData });
  };
  
  const loadMore = async () => {
    if (!hasMorePages.value || loadingMore.value) return;
    currentPage.value++;
    await fetchData(currentPage.value, true);
  };

  const setupRealtime = () => {
    if (realtimeSubscription.value) realtimeSubscription.value.unsubscribe();
    realtimeSubscription.value = supabase.channel(`inspections_${centroId}`)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'inspecciones', filter: `centro_id=eq.${centroId}` }, () => {
        localStorage.removeItem(CACHE_KEY);
        fetchData(currentPage.value, false, true);
      }).subscribe();
  };
  
  onMounted(async () => {
    await fetchData(1);
    setupRealtime();
  });
  
  onUnmounted(() => {
    if (realtimeSubscription.value) realtimeSubscription.value.unsubscribe();
  });

  return {
    loading: readonly(loading),
    loadingMore: readonly(loadingMore),
    centro: readonly(centro),
    inspecciones, // Return as ref for updates
    availableYears: readonly(availableYears),
    hasMorePages: readonly(hasMorePages),
    totalInspecciones: readonly(totalInspecciones),
    loadMore,
    loadInspectionDetails,
    refreshData: () => fetchData(1, false),
    updateInspectionInList: (updatedInspection) => {
      const index = inspecciones.value.findIndex(i => i.id === updatedInspection.id);
      if (index !== -1) {
        inspecciones.value[index] = { ...inspecciones.value[index], ...updatedInspection };
      }
    },
    removeInspectionFromList: (inspectionId) => {
      inspecciones.value = inspecciones.value.filter(i => i.id !== inspectionId);
      totalInspecciones.value--;
    }
  };
}
--- FIN DEL ARCHIVO: src/composables/useInspections.js ---

--- INICIO DEL ARCHIVO: src/composables/useFileUpload.js ---
// src/composables/useFileUpload.js

import { ref } from 'vue';
import { useNotification } from '../utils/notification';
import { addToQueue, FILE_STORAGE_KEY_PREFIX } from '../utils/syncQueue';
import { createLogger } from '../utils/logger';

const logger = createLogger('FileUpload');

function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = (error) => reject(error);
    reader.readAsArrayBuffer(file);
  });
}

export function useFileUpload(inspeccionId, puntoId) {
  const { showNotification } = useNotification();
  const isUploading = ref(null);

  const compressImage = (file) => {
    // ... (función de compresión no cambia)
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => {
        let { width, height } = img;
        const maxDimension = 1024;
        if (width > height) {
          if (width > maxDimension) { height = (height * maxDimension) / width; width = maxDimension; }
        } else {
          if (height > maxDimension) { width = (width * maxDimension) / height; height = maxDimension; }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob((blob) => {
          if (blob) {
            const compressedFile = new File([blob], file.name, { type: 'image/jpeg', lastModified: Date.now() });
            resolve(compressedFile);
          } else { reject(new Error('Failed to compress image')); }
        }, 'image/jpeg', 0.6);
      };
      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = URL.createObjectURL(file);
    });
  };

  const handleFileUpload = async (file, incidencia) => {
    if (!file.type.startsWith('image/')) {
      showNotification('Solo se permiten archivos de imagen.', 'error'); return null;
    }
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      showNotification('El archivo es demasiado grande. Máximo 10MB.', 'error'); return null;
    }

    isUploading.value = incidencia.id;

    try {
      let fileToUpload = file;
      if (file.size > 500 * 1024) {
        showNotification('Comprimiendo imagen...', 'info');
        fileToUpload = await compressImage(file);
      }
      
      const arrayBuffer = await readFileAsArrayBuffer(fileToUpload);
      const stableBlob = new Blob([arrayBuffer], { type: fileToUpload.type });
      const stableBlobUrl = URL.createObjectURL(stableBlob);

      const fileName = `inspeccion_${inspeccionId}/punto_${puntoId}/${Date.now()}_${file.name}`;

      // addToQueue manejará la creación del fileId internamente
      const queueAction = {
        type: 'uploadAndUpdate',
        bucket: 'incidencias',
        path: fileName,
        file: stableBlob,
        table: 'incidencias',
        recordId: incidencia.id,
        urlColumn: 'url_foto_antes',
      };

      await addToQueue(queueAction);

      showNotification('Foto guardada localmente.', 'success');

      // addToQueue modifica el objeto queueAction y le añade el fileId
      return {
          offlinePhotoKey: queueAction.fileId, // Usamos el fileId que addToQueue creó
          previewUrl: stableBlobUrl,
      };

    } catch (error) {
      logger.error('Error procesando imagen para guardado local:', error);
      showNotification('Error al procesar la imagen: ' + error.message, 'error');
      return null;
    } finally {
      isUploading.value = null;
    }
  };

  return {
    isUploading,
    handleFileUpload,
  };
}
--- FIN DEL ARCHIVO: src/composables/useFileUpload.js ---

--- INICIO DEL ARCHIVO: src/router/index.js ---
// src/router/index.js

import { createRouter, createWebHistory } from 'vue-router'
import { supabase } from '../supabase'
import { createLogger } from '../utils/logger'

const logger = createLogger('Router')

// Importación de Vistas y Componentes
import Login from '../components/Login.vue'

const routes = [
  { path: '/', name: 'Login', component: Login, meta: { layout: 'Blank' } },
  { path: '/dashboard', name: 'Dashboard', component: () => import('../views/DashboardView.vue'), meta: { requiresAuth: true } },
  { path: '/gestion', name: 'Gestion', component: () => import('../views/GestionView.vue'), meta: { requiresAuth: true } },
  { path: '/centros', name: 'CentrosList', component: () => import('../views/CentrosListView.vue'), meta: { requiresAuth: true } },
  { path: '/centros/:id/versiones', name: 'CentroVersions', component: () => import('../views/CentroVersionsView.vue'), meta: { requiresAuth: true } },
  { path: '/versiones/:id/configurar', name: 'VersionConfig', component: () => import('../views/CentroConfigView.vue'), meta: { requiresAuth: true } },
  { path: '/inspecciones', name: 'InspeccionesList', component: () => import('../views/InspeccionesListView.vue'), meta: { requiresAuth: true } },
  { path: '/inspecciones/:id', name: 'InspeccionDetail', component: () => import('../views/InspeccionDetailView.vue'), meta: { requiresAuth: true, hideDefaultHeader: true } },
  { path: '/centros/:id/historial', name: 'CentroHistorial', component: () => import('../views/CentroHistorialView.vue'), meta: { requiresAuth: true } },
  {
    path: '/inspecciones/:id/plano-preview',
    name: 'PlanoPreview',
    component: () => import('../views/PlanoPreviewView.vue'),
    meta: { layout: 'Blank' }
  },
  {
    path: '/inspecciones/:id/cierre',
    name: 'CierreInforme',
    component: () => import('../views/CierreInformeView.vue'),
    meta: { requiresAuth: true }
  },
  { path: '/admin', name: 'Admin', component: () => import('../views/AdminView.vue'), meta: { requiresAuth: true } }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

router.beforeEach(async (to, from, next) => {
  logger.debug(`Navegando de '${from.fullPath}' a '${to.fullPath}'`);

  const { data: { session } } = await supabase.auth.getSession()
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth)

  if (requiresAuth && !session) { next({ name: 'Login' }) }
  else if (session && to.name === 'Login') { next({ name: 'Dashboard' }) }
  else { next() }
})

export default router
--- FIN DEL ARCHIVO: src/router/index.js ---

--- INICIO DEL ARCHIVO: src/layouts/BlankLayout.vue ---
<!-- src/layouts/BlankLayout.vue -->
<script setup>
import { onMounted } from 'vue';
// --- LOGS DE DEBUG ---
onMounted(() => console.log('[BlankLayout.vue] Componente montado en el DOM.'));
</script>

<template>
  <!-- 
    CORRECCIÓN: Se elimina el div contenedor. 
    <router-view> actuará como el elemento raíz de este layout,
    permitiendo que la página que renderiza controle su propio layout al 100%.
  -->
  <router-view />
</template>
--- FIN DEL ARCHIVO: src/layouts/BlankLayout.vue ---

--- INICIO DEL ARCHIVO: src/layouts/DefaultLayout.vue ---
<!-- src/layouts/DefaultLayout.vue -->
<script setup>
import { ref, provide } from 'vue';
import { RouterLink, useRoute } from 'vue-router';
import { HomeIcon, ListBulletIcon, DocumentMagnifyingGlassIcon, Cog6ToothIcon, Bars3Icon, TableCellsIcon } from '@heroicons/vue/24/outline';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
// --- INICIO DE LA MODIFICACIÓN ---
import GlobalStatusIndicator from '../components/GlobalStatusIndicator.vue';
// --- FIN DE LA MODIFICACIÓN ---

const route = useRoute();
const router = useRouter();
const isSidebarOpen = ref(false);

// Proporcionar el estado del sidebar a los componentes hijos
provide('toggleSidebar', () => { isSidebarOpen.value = true; });

const navigation = [
  { name: 'Menú Principal', href: '/dashboard', icon: HomeIcon },
  { name: 'Gestión', href: '/gestion', icon: TableCellsIcon },
  { name: 'Maestro de Centros', href: '/centros', icon: ListBulletIcon },
  { name: 'Inspecciones', href: '/inspecciones', icon: DocumentMagnifyingGlassIcon },
  { name: 'Admin', href: '/admin', icon: Cog6ToothIcon },
];

const isActive = (href) => {
  return route.path === href || (href !== '/dashboard' && route.path.startsWith(href));
};

const handleLogout = async () => {
  await supabase.auth.signOut();
  router.push('/');
};
</script>
<template>
<div class="relative h-screen flex overflow-hidden bg-slate-100">
  <!-- Overlay para móvil -->
  <div v-if="isSidebarOpen" @click="isSidebarOpen = false" class="fixed inset-0 bg-black bg-opacity-50 z-20 md:hidden"></div>
  
  <!-- Barra Lateral -->
  <aside 
    :class="[
      'absolute inset-y-0 left-0 w-64 bg-slate-800 flex flex-col z-30 transform transition-transform duration-300 ease-in-out md:relative md:translate-x-0',
      isSidebarOpen ? 'translate-x-0' : '-translate-x-full'
    ]"
  >
    <div class="h-16 flex-shrink-0 flex items-center justify-center">
      <h1 class="text-2xl font-bold text-white tracking-wider">Arsel</h1>
    </div>
    <nav class="flex-1 px-4 py-2 space-y-2">
        <RouterLink
          v-for="item in navigation"
          :key="item.name"
          :to="item.href"
          @click="isSidebarOpen = false"
          :class="[
            'flex items-center px-3 py-3 text-sm font-medium rounded-lg transition-colors',
            isActive(item.href)
              ? 'bg-blue-600 text-white shadow-inner'
              : 'text-slate-300 hover:bg-slate-700 hover:text-white',
          ]"
        >
          <component :is="item.icon" class="h-6 w-6 mr-3" />
          {{ item.name }}
        </RouterLink>
    </nav>
    
    <!-- --- INICIO DE LA MODIFICACIÓN: Indicador para ESCRITORIO --- -->
    <div class="px-4 py-2 border-t border-slate-700">
      <GlobalStatusIndicator mode="desktop" />
    </div>
    <!-- --- FIN DE LA MODIFICACIÓN --- -->

    <div class="p-4 border-t border-slate-700">
      <button @click="handleLogout" class="w-full px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
        Cerrar Sesión
      </button>
    </div>
  </aside>

  <!-- Contenido Principal -->
  <div class="flex-1 flex flex-col overflow-hidden">
      <header
        v-if="!route.meta.hideDefaultHeader"
        class="md:hidden h-16 bg-white shadow-sm flex items-center justify-between px-4 flex-shrink-0">
        <button @click="isSidebarOpen = true" class="text-slate-600">
          <Bars3Icon class="h-6 w-6" />
        </button>
        <h2 class="text-lg font-bold text-slate-800">{{ route.name }}</h2>
        <!-- --- INICIO DE LA MODIFICACIÓN: Indicador para MÓVIL --- -->
        <GlobalStatusIndicator mode="mobile" />
        <!-- --- FIN DE LA MODIFICACIÓN --- -->
      </header>

      <main class="flex-1 overflow-y-auto">
        <router-view />
      </main>
    </div>
  </div>
  
  <!-- El indicador flotante de escritorio ya no es necesario aquí -->
</template>
--- FIN DEL ARCHIVO: src/layouts/DefaultLayout.vue ---

