--- INICIO DEL ARCHIVO: package.json ---

{
"name": "arsel",
"private": true,
"version": "0.0.0",
"type": "module",
"scripts": {
"dev": "vite",
"build": "vite build",
"preview": "vite preview",
"tailwind:init": "tailwindcss init -p"
},
"dependencies": {
"@heroicons/vue": "^2.2.0",
"@supabase/supabase-js": "^2.53.1",
"browser-image-compression": "^2.0.2",
"chart.js": "^4.5.0",
"compressorjs": "^1.2.1",
"html2canvas": "^1.4.1",
"jspdf": "^3.0.1",
"jspdf-autotable": "^5.0.2",
"vue": "^3.5.18",
"vue-chartjs": "^5.3.2",
"vue-router": "^4.5.1",
"xlsx-js-style": "^1.2.0"
},
"devDependencies": {
"@vitejs/plugin-vue": "^5.0.5",
"autoprefixer": "^10.4.21",
"postcss": "^8.5.6",
"tailwindcss": "^3.4.17",
"vite": "^5.3.4",
"vite-plugin-pwa": "^0.20.0"
}
}
--- FIN DEL ARCHIVO: package.json ---

--- INICIO DEL ARCHIVO: vite.config.js ---
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { VitePWA } from 'vite-plugin-pwa'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'masked-icon.svg'],
      manifest: {
        name: 'Arsel Inspecciones',
        short_name: 'ArselInsp',
        description: 'Aplicaci√≥n de gesti√≥n de inspecciones de estanter√≠as.',
        theme_color: '#ffffff',
        background_color: '#ffffff',
        display: 'standalone',
        scope: '/',
        start_url: '/',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable',
          },
        ],
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/bgltxcklvjumltuktdvv\.supabase\.co\/storage\/v1\/object\/.*/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'supabase-images-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
            },
          },
          {
            urlPattern: /^https:\/\/bgltxcklvjumltuktdvv\.supabase\.co\/rest\/v1\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'supabase-api-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 60 * 24, // 1 day
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
            },
          },
        ],
      },
    }),
  ],
  server: {
    host: true,
  }
})
--- FIN DEL ARCHIVO: vite.config.js ---

--- INICIO DEL ARCHIVO: src/main.js ---
// src/main.js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router' // Importamos nuestro router

const app = createApp(App)

app.use(router) // Le decimos a la app que use el router

app.mount('#app')
--- FIN DEL ARCHIVO: src/main.js ---

--- INICIO DEL ARCHIVO: src/App.vue ---
<!-- src/App.vue -->
<script setup>
import { computed, onMounted, onUnmounted, onUpdated, provide } from 'vue';
import { useRoute } from 'vue-router';
import DefaultLayout from './layouts/DefaultLayout.vue';
import BlankLayout from './layouts/BlankLayout.vue';
import Notification from './components/Notification.vue';
import ConfirmModal from './components/ConfirmModal.vue';
import { useNotification } from './utils/notification';
import { useRegisterSW } from 'virtual:pwa-register/vue';
import ReloadPWA from './components/ReloadPWA.vue';
import { initializeQueue, processQueue } from './utils/syncQueue';
import { createLogger } from './utils/logger';

const logger = createLogger('App');

const { offlineReady, needRefresh, updateServiceWorker } = useRegisterSW();

const handleUpdateServiceWorker = async () => {
  await updateServiceWorker();
};

// --- INICIO DE LA MODIFICACI√ìN: Nuevo handler para visibilidad ---
const handleVisibilityChange = () => {
  if (document.visibilityState === 'visible') {
    // Cuando la app vuelve a ser visible, intentamos sincronizar.
    logger.debug("App is visible again, attempting to sync queue.");
    processQueue();
  }
};
// --- FIN DE LA MODIFICACI√ìN ---

onMounted(() => {
  logger.info('[App.vue] Componente montado en el DOM.');
  initializeQueue();
  window.addEventListener('online', processQueue);
  // --- INICIO DE LA MODIFICACI√ìN: A√±adimos el nuevo listener ---
  document.addEventListener('visibilitychange', handleVisibilityChange);
  // --- FIN DE LA MODIFICACI√ìN ---
});

onUnmounted(() => {
  window.removeEventListener('online', processQueue);
  // --- INICIO DE LA MODIFICACI√ìN: Limpiamos el nuevo listener ---
  document.removeEventListener('visibilitychange', handleVisibilityChange);
  // --- FIN DE LA MODIFICACI√ìN ---
});

onUpdated(() => logger.debug('[App.vue] Componente actualizado (cambio de layout o ruta).'));

const { notificationShow, notificationMessage, notificationType, confirmShow, confirmTitle, confirmMessage, showNotification, showConfirm, confirmYes, confirmNo } = useNotification();
provide('showNotification', showNotification);
provide('showConfirm', showConfirm);
provide('confirmYes', confirmYes);
provide('confirmNo', confirmNo);

const route = useRoute();
const layout = computed(() => {
  const layoutName = route.meta.layout === 'Blank' ? 'BlankLayout' : 'DefaultLayout';
  logger.debug(`[App.vue] Layout computado es: ${layoutName}`);
  return layoutName === 'BlankLayout' ? BlankLayout : DefaultLayout;
});
</script>

<template>
  <ReloadPWA 
    :offline-ready="offlineReady" 
    :need-refresh="needRefresh" 
    @update-service-worker="handleUpdateServiceWorker" 
  />
  
  <component :is="layout" />
  
  <Notification
    :show="notificationShow"
    :message="notificationMessage"
    :type="notificationType"
  />
  <ConfirmModal
    :is-open="confirmShow"
    :title="confirmTitle"
    :message="confirmMessage"
    @confirm="confirmYes"
    @cancel="confirmNo"
  />
</template>
--- FIN DEL ARCHIVO: src/App.vue ---

--- INICIO DEL ARCHIVO: src/supabase.js ---
// src/supabase.js
import { createClient } from '@supabase/supabase-js'

// Estas l√≠neas leen las claves que pusiste en el archivo .env.local
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

// Exportamos el cliente para poder usarlo en toda la aplicaci√≥n
export const supabase = createClient(supabaseUrl, supabaseAnonKey)
--- FIN DEL ARCHIVO: src/supabase.js ---

--- INICIO DEL ARCHIVO: src/style.css ---
/* src/style.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
--- FIN DEL ARCHIVO: src/style.css ---

--- INICIO DEL ARCHIVO: src/utils/notification.js ---
// src/utils/notification.js
import { ref, readonly } from 'vue';

// Estado reactivo que compartiremos en toda la app
const show = ref(false);
const message = ref('');
const type = ref('success');

// Estado para confirm modal
const confirmShow = ref(false);
const confirmTitle = ref('');
const confirmMessage = ref('');
let confirmResolve = null;

// Temporizador para ocultar la notificaci√≥n
let timeoutId = null;

// La funci√≥n que llamaremos desde cualquier componente
export function useNotification() {
  const showNotification = (newMessage, newType = 'success', duration = 3000) => {
    message.value = newMessage;
    type.value = newType;
    show.value = true;

    // Limpiamos cualquier temporizador anterior para evitar solapamientos
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    // Ocultamos la notificaci√≥n despu√©s de la duraci√≥n especificada
    timeoutId = setTimeout(() => {
      show.value = false;
    }, duration);
  };

  const showConfirm = (title, msg) => {
    return new Promise((resolve) => {
      confirmTitle.value = title;
      confirmMessage.value = msg;
      confirmShow.value = true;
      confirmResolve = resolve;
    });
  };

  const confirmYes = () => {
    confirmShow.value = false;
    if (confirmResolve) confirmResolve(true);
  };

  const confirmNo = () => {
    confirmShow.value = false;
    if (confirmResolve) confirmResolve(false);
  };

  return {
    // Exportamos los estados como `readonly` para que no se puedan modificar directamente
    notificationShow: readonly(show),
    notificationMessage: readonly(message),
    notificationType: readonly(type),
    // Confirm modal
    confirmShow: readonly(confirmShow),
    confirmTitle: readonly(confirmTitle),
    confirmMessage: readonly(confirmMessage),
    // Exportamos la funci√≥n que permite mostrar notificaciones
    showNotification,
    showConfirm,
    confirmYes,
    confirmNo,
  };
}
--- FIN DEL ARCHIVO: src/utils/notification.js ---

--- INICIO DEL ARCHIVO: src/utils/syncQueue.js ---
// src/utils/syncQueue.js

import { ref } from 'vue';
import { supabase } from '../supabase';
import { useNotification } from './notification';
import { createLogger } from './logger';

const { showNotification } = useNotification();
const logger = createLogger('SyncQueue');

export const syncQueue = ref([]);
export const isProcessing = ref(false);

const QUEUE_STORAGE_KEY = 'arsel-sync-queue';
export const FILE_STORAGE_KEY_PREFIX = 'arsel-offline-file-';

// LRU Cache para tempIdMap con l√≠mite de 500 entradas
const MAX_TEMP_ID_MAP_SIZE = 500;
const tempIdMapAccess = new Map(); // Tracking de √∫ltimo acceso
const tempIdMap = new Map();

const dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open("ArselOfflineFiles", 1);
    request.onerror = () => reject("Error al abrir IndexedDB");
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = event => {
        const db = event.target.result;
        db.createObjectStore("files");
    };
});

async function saveFileLocally(fileId, file) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(["files"], "readwrite");
        const store = transaction.objectStore("files");
        const request = store.put(file, fileId);
        request.onsuccess = () => resolve();
        request.onerror = () => reject("No se pudo guardar el archivo localmente.");
    });
}

export async function getFileLocally(fileId) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(["files"]);
        const store = transaction.objectStore("files");
        const request = store.get(fileId);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject("No se pudo leer el archivo local.");
    });
}

async function deleteFileLocally(fileId) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(["files"], "readwrite");
        const store = transaction.objectStore("files");
        store.delete(fileId);
        resolve();
    });
}

function saveQueueToStorage() {
  localStorage.setItem(QUEUE_STORAGE_KEY, JSON.stringify(syncQueue.value));
}

// Funciones LRU para tempIdMap
function setTempId(tempId, realId) {
  // Limpiar entrada m√°s antigua si excedemos el l√≠mite
  if (tempIdMap.size >= MAX_TEMP_ID_MAP_SIZE) {
    let oldestKey = null;
    let oldestTime = Date.now();

    for (const [key, time] of tempIdMapAccess.entries()) {
      if (time < oldestTime) {
        oldestTime = time;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      tempIdMap.delete(oldestKey);
      tempIdMapAccess.delete(oldestKey);
      logger.debug(`LRU: Removed oldest tempId ${oldestKey} to make space`);
    }
  }

  tempIdMap.set(tempId, realId);
  tempIdMapAccess.set(tempId, Date.now());
  logger.debug(`Mapped ${tempId} ‚Üí ${realId}`);
}

function getTempId(tempId) {
  if (!tempIdMap.has(tempId)) return null;

  // Actualizar tiempo de acceso (LRU)
  tempIdMapAccess.set(tempId, Date.now());
  return tempIdMap.get(tempId);
}

function hasTempId(tempId) {
  return tempIdMap.has(tempId);
}

export async function processQueue() {
  if (isProcessing.value || !navigator.onLine) {
    return Promise.resolve();
  }
  isProcessing.value = true;

  // L√≠mite para evitar bucles infinitos
  let processedActions = 0;
  const maxActionsInCycle = syncQueue.value.length * 2;

  while (syncQueue.value.length > 0 && processedActions < maxActionsInCycle) {
    const action = syncQueue.value[0];
    let success = false;
    processedActions++;

    try {
      if (action.payload) {
        for (const key in action.payload) {
          if (typeof action.payload[key] === 'string' && action.payload[key].startsWith('temp_')) {
            const realId = getTempId(action.payload[key]);
            if (realId) {
              action.payload[key] = realId;
            } else {
              throw new Error(`Dependencia de ID temporal (${action.payload[key]}) no resuelta. Reintentando...`);
            }
          }
        }
      }

      const sanitizedPayload = action.payload ? { ...action.payload } : {};
      if(sanitizedPayload.id) delete sanitizedPayload.id;
      if(sanitizedPayload.created_at) delete sanitizedPayload.created_at;

      switch (action.type) {
        case 'insert':
          const { data: insertData, error: insertError } = await supabase.from(action.table).insert(sanitizedPayload).select().single();
          if (insertError) throw insertError;
          if (action.tempId) {
            setTempId(action.tempId, insertData.id);
          }
          success = true;
          break;

        case 'update':
          let updateId = action.id;
          if (typeof updateId === 'string' && updateId.startsWith('temp_')) {
            const realId = getTempId(updateId);
            if (!realId) {
              logger.warn(`Update de ${updateId} reordenado - esperando resoluci√≥n`);
              throw new Error(`ID temporal ${updateId} no encontrado para actualizar.`);
            }
            updateId = realId;
            logger.debug(`Update resolved: ${action.id} ‚Üí ${updateId}`);
          }
          const { error: updateError } = await supabase.from(action.table).update(sanitizedPayload).eq('id', updateId);
          if (updateError) throw updateError;
          success = true;
          break;
        
        case 'delete':
          if (typeof action.id === 'string' && action.id.startsWith('temp_')) {
            success = true;
          } else {
            const { error: deleteError } = await supabase.from(action.table).delete().eq('id', action.id);
            if (!deleteError || deleteError.code === 'PGRST116') {
              success = true;
            } else {
              throw deleteError;
            }
          }
          break;

        case 'deleteFile':
          try {
            const url = new URL(action.url);
            const pathParts = url.pathname.split('/');
            const bucketIndex = pathParts.findIndex(part => part === action.bucket);
            if (bucketIndex === -1) throw new Error(`Bucket '${action.bucket}' no encontrado en la URL.`);
            const filePath = pathParts.slice(bucketIndex + 1).join('/');
            const { error: fileDeleteError } = await supabase.storage.from(action.bucket).remove([filePath]);
            if (fileDeleteError && fileDeleteError.message !== 'The resource was not found') {
              logger.error('Error al borrar archivo del storage:', fileDeleteError);
            }
          } catch(e) {
              logger.error('URL de archivo inv√°lida para borrado:', action.url, e);
          }
          success = true;
          break;

        case 'uploadAndUpdate':
          let fileData = await getFileLocally(action.fileId);
          if (!fileData) {
            logger.warn(`Archivo local ${action.fileId} no encontrado, saltando acci√≥n`);
            success = true;
            break;
          }
          const fileToUpload = new Blob([fileData], { type: fileData.type });
          const { error: uploadError } = await supabase.storage.from(action.bucket).upload(action.path, fileToUpload, { upsert: true });
          if (uploadError) throw uploadError;

          const { data: { publicUrl } } = supabase.storage.from(action.bucket).getPublicUrl(action.path);

          let recordId = action.recordId;
          if (typeof recordId === 'string' && recordId.startsWith('temp_')) {
            const realRecordId = getTempId(recordId);
            if (!realRecordId) {
              logger.error(`ID temporal ${recordId} no encontrado. Map size: ${tempIdMap.size}`);
              throw new Error(`ID temporal ${recordId} no encontrado para actualizar URL.`);
            }
            logger.debug(`Resolviendo ${recordId} ‚Üí ${realRecordId}`);
            recordId = realRecordId;
          }

          const updateUrlPayload = {};
          updateUrlPayload[action.urlColumn] = publicUrl;
          const { error: urlUpdateError } = await supabase.from(action.table).update(updateUrlPayload).eq('id', recordId);
          if (urlUpdateError) throw urlUpdateError;

          await deleteFileLocally(action.fileId);
          logger.debug(`Archivo subido y URL actualizada para recordId ${recordId}`);
          success = true;
          break;

        default:
          throw new Error(`Tipo de acci√≥n desconocido: ${action.type}`);
      }
    } catch (error) {
      logger.error('Error al procesar la acci√≥n de la cola:', error);

      // === MANEJO ROBUSTO DE ERRORES ===
      if (error.message.includes('Dependencia de ID temporal') || error.message.includes('ID temporal no encontrado')) {
        // Error de dependencia: la acci√≥n depende de un ID temporal que a√∫n no se ha resuelto
        logger.warn(`Reordenando acci√≥n por dependencia no resuelta:`, action);
        const failingAction = syncQueue.value.shift();
        syncQueue.value.push(failingAction);
        // NO marcamos success=true, el bucle continuar√° con el siguiente elemento
      } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
        // Error de red: detenemos el procesamiento para reintentar m√°s tarde
        logger.info('Fallo de red. La sincronizaci√≥n se detiene y reintentar√° m√°s tarde.');
        break;
      } else if (error.code === 'PGRST116' || error.message.includes('no rows returned')) {
        // El registro no existe en la BD (probablemente ya fue borrado)
        // Esto puede pasar si intentamos actualizar/borrar algo que ya no existe
        logger.warn(`Registro no encontrado, removiendo acci√≥n de la cola:`, action);
        success = true; // Marcamos como √©xito para remover la acci√≥n
      } else {
        // Error grave e inesperado: detenemos la cola y notificamos
        showNotification(`Error de sincronizaci√≥n: ${error.message}`, 'error');
        logger.error('Error grave en cola de sincronizaci√≥n:', error, action);
        break;
      }
    }
    if (success) {
      syncQueue.value.shift();

      // NOTA: NO limpiamos el tempIdMap aqu√≠
      // El mapa persiste durante toda la sesi√≥n para manejar updates tard√≠os
      // que puedan llegar despu√©s de que el insert se haya procesado
    }

    // Siempre guardamos el estado actual de la cola, especialmente si la hemos reordenado.
    saveQueueToStorage();
  }

  isProcessing.value = false;
  return Promise.resolve();
}

/**
 * Waits for the sync queue to become empty
 * @param {number} timeout - Timeout in milliseconds (default: 30000ms = 30s)
 * @returns {Promise<void>} Resolves when queue is empty or timeout is reached
 */
export async function waitForQueueToEmpty(timeout = 30000) {
  const startTime = Date.now();
  const checkInterval = 100; // Check every 100ms

  return new Promise((resolve, reject) => {
    const checkQueue = () => {
      // Check if queue is empty
      if (syncQueue.value.length === 0 && !isProcessing.value) {
        logger.debug('Queue is empty');
        resolve();
        return;
      }

      // Check if timeout exceeded
      if (Date.now() - startTime >= timeout) {
        const remainingItems = syncQueue.value.length;
        logger.warn(`Queue timeout after ${timeout}ms with ${remainingItems} items remaining`);
        reject(new Error(`Tiempo de espera agotado. Quedan ${remainingItems} elementos pendientes de sincronizaci√≥n.`));
        return;
      }

      // Continue checking
      setTimeout(checkQueue, checkInterval);
    };

    checkQueue();
  });
}

export async function addToQueue(action) {
  // === OPTIMIZACI√ìN: Borrado de registros con ID temporal ===
  // Si intentamos borrar un registro con ID temporal (creado offline),
  // eliminamos TODAS las acciones relacionadas con ese ID temporal de la cola.
  if (action.type === 'delete' && typeof action.id === 'string' && action.id.startsWith('temp_')) {
    const tempId = action.id;
    const actionsToRemove = [];

    // Buscamos todas las acciones relacionadas con este ID temporal
    syncQueue.value.forEach((item, index) => {
      // Insert con este tempId
      if (item.type === 'insert' && item.tempId === tempId) {
        actionsToRemove.push(index);
      }
      // Update con este id
      else if (item.type === 'update' && item.id === tempId) {
        actionsToRemove.push(index);
      }
      // uploadAndUpdate con este recordId
      else if (item.type === 'uploadAndUpdate' && item.recordId === tempId) {
        actionsToRemove.push(index);
        // Si hay un archivo guardado localmente, lo borramos
        if (item.fileId) {
          deleteFileLocally(item.fileId).catch(err =>
            logger.warn(`No se pudo borrar archivo local ${item.fileId}:`, err)
          );
        }
      }
    });

    // Eliminamos las acciones en orden inverso para no afectar los √≠ndices
    if (actionsToRemove.length > 0) {
      actionsToRemove.reverse().forEach(index => {
        syncQueue.value.splice(index, 1);
      });

      // Limpiamos el tempIdMap si existe
      if (hasTempId(tempId)) {
        tempIdMap.delete(tempId);
        tempIdMapAccess.delete(tempId);
      }

      showNotification('Operaciones locales de la incidencia canceladas.', 'info', 2000);
      saveQueueToStorage();
      return; // No agregamos la acci√≥n de delete
    }
  }

  // === OPTIMIZACI√ìN: Borrado de archivos asociados ===
  // Si es un deleteFile, buscamos si hay una acci√≥n uploadAndUpdate pendiente con la misma ruta
  if (action.type === 'deleteFile') {
    const filePathToDelete = extractFilePathFromUrl(action.url, action.bucket);

    // Buscamos uploadAndUpdate pendientes con la misma ruta
    const uploadIndex = syncQueue.value.findIndex(
      item => item.type === 'uploadAndUpdate' &&
              item.bucket === action.bucket &&
              item.path === filePathToDelete
    );

    if (uploadIndex > -1) {
      const uploadAction = syncQueue.value[uploadIndex];
      // Borramos el archivo local si existe
      if (uploadAction.fileId) {
        await deleteFileLocally(uploadAction.fileId).catch(err =>
          logger.warn(`No se pudo borrar archivo local ${uploadAction.fileId}:`, err)
        );
      }
      // Eliminamos la acci√≥n de upload
      syncQueue.value.splice(uploadIndex, 1);
      saveQueueToStorage();
      return; // No agregamos la acci√≥n de deleteFile
    }
  }

  // === Procesamiento normal de acciones ===
  if (action.type === 'uploadAndUpdate' && action.file) {
      const fileId = `${FILE_STORAGE_KEY_PREFIX}${Date.now()}`;
      try {
          await saveFileLocally(fileId, action.file);
          action.fileId = fileId;
          delete action.file;
      } catch(e) {
          showNotification(e.message, 'error');
          return;
      }
  }

  syncQueue.value.push(action);
  saveQueueToStorage();
  processQueue();
}

// Helper para extraer el path del archivo desde una URL
function extractFilePathFromUrl(url, bucket) {
  try {
    const urlObj = new URL(url);
    const pathParts = urlObj.pathname.split('/');
    const bucketIndex = pathParts.findIndex(part => part === bucket);
    if (bucketIndex === -1) return null;
    return pathParts.slice(bucketIndex + 1).join('/');
  } catch (e) {
    logger.error('Error extrayendo path de URL:', e);
    return null;
  }
}

export function initializeQueue() {
  const savedQueue = localStorage.getItem(QUEUE_STORAGE_KEY);
  if (savedQueue) {
    syncQueue.value = JSON.parse(savedQueue);

    // === LIMPIEZA DE ACCIONES HU√âRFANAS ===
    // Eliminamos acciones update/uploadAndUpdate de IDs temporales que no tienen insert
    const tempIdsWithInsert = new Set();

    // Primera pasada: recolectar todos los tempIds que tienen insert
    syncQueue.value.forEach(action => {
      if (action.type === 'insert' && action.tempId) {
        tempIdsWithInsert.add(action.tempId);
      }
    });

    // Segunda pasada: eliminar acciones hu√©rfanas
    syncQueue.value = syncQueue.value.filter(action => {
      // Si es un update o uploadAndUpdate con ID temporal sin insert correspondiente
      if ((action.type === 'update' || action.type === 'uploadAndUpdate') &&
          typeof action.id === 'string' && action.id.startsWith('temp_') &&
          !tempIdsWithInsert.has(action.id)) {
        logger.warn(`Removiendo acci√≥n hu√©rfana de ID temporal ${action.id}:`, action);

        // Si es uploadAndUpdate, borramos el archivo local
        if (action.type === 'uploadAndUpdate' && action.fileId) {
          deleteFileLocally(action.fileId).catch(err =>
            logger.warn(`No se pudo borrar archivo local ${action.fileId}:`, err)
          );
        }

        return false; // Filtrar esta acci√≥n
      }

      // Mismo chequeo para uploadAndUpdate con recordId
      if (action.type === 'uploadAndUpdate' &&
          typeof action.recordId === 'string' && action.recordId.startsWith('temp_') &&
          !tempIdsWithInsert.has(action.recordId)) {
        logger.warn(`Removiendo uploadAndUpdate hu√©rfano de recordId ${action.recordId}:`, action);

        if (action.fileId) {
          deleteFileLocally(action.fileId).catch(err =>
            logger.warn(`No se pudo borrar archivo local ${action.fileId}:`, err)
          );
        }

        return false;
      }

      return true; // Mantener esta acci√≥n
    });

    saveQueueToStorage();
  }

  processQueue();
}
--- FIN DEL ARCHIVO: src/utils/syncQueue.js ---

--- INICIO DEL ARCHIVO: src/utils/plano-layout.js ---
// src/utils/plano-layout.js

export function calculatePlanoLayout(allPointsData, mapDimensions, badgeWidthRatio) {
    const BADGE_ASPECT_RATIO = 45 / 55;
    const badgeSize = {
        width: mapDimensions.width * badgeWidthRatio,
        height: mapDimensions.width * badgeWidthRatio * BADGE_ASPECT_RATIO
    };

    const placedObstacles = allPointsData.map(p => ({
        x: p.relativeX * mapDimensions.width, 
        y: p.relativeY * mapDimensions.height,
        width: 1, height: 1 // Los puntos son obst√°culos peque√±os
    }));

    const labelsToDraw = [];
    const mapCenterX = mapDimensions.width / 2;
    const mapCenterY = mapDimensions.height / 2;
    
    const sortedPoints = [...allPointsData].sort((a, b) => {
        const distA = Math.sqrt(Math.pow((a.relativeX * mapDimensions.width) - mapCenterX, 2) + Math.pow((a.relativeY * mapDimensions.height) - mapCenterY, 2));
        const distB = Math.sqrt(Math.pow((b.relativeX * mapDimensions.width) - mapCenterX, 2) + Math.pow((b.relativeY * mapDimensions.height) - mapCenterY, 2));
        return distA - distB;
    });

    for (const point of sortedPoints) {
        const needsBadge = point.estado !== 'existente' || point.detalle_modificacion !== null ||
            (point.counts.verde > 0 || point.counts.ambar > 0 || point.counts.rojo > 0);
        if (!needsBadge) continue;

        const pointAbs = {
            x: point.relativeX * mapDimensions.width,
            y: point.relativeY * mapDimensions.height
        };
        
        const finalPositionAbs = findNonOverlappingPosition(pointAbs, badgeSize, placedObstacles, mapDimensions);
        
        const badgeRect = { 
            x: finalPositionAbs.x - badgeSize.width / 2, 
            y: finalPositionAbs.y - badgeSize.height / 2, 
            ...badgeSize 
        };
        placedObstacles.push(badgeRect);
        
        labelsToDraw.push({
            pointData: point,
            position: { // Posici√≥n RELATIVA (0-1)
                x: finalPositionAbs.x / mapDimensions.width,
                y: finalPositionAbs.y / mapDimensions.height
            },
            size: { // Tama√±o RELATIVO (0-1)
                width: badgeSize.width / mapDimensions.width,
                height: badgeSize.height / mapDimensions.height
            }
        });
    }
    return labelsToDraw;
}

function findNonOverlappingPosition(pointAbs, badgeSize, obstacles, pageBounds) {
    const isOverlapping = (rect1, rect2) => {
        const margin = 5; 
        return !(rect1.x > rect2.x + rect2.width + margin ||
            rect1.x + rect1.width + margin < rect2.x ||
            rect1.y > rect2.y + rect2.height + margin ||
            rect1.y + rect1.height + margin < rect2.y);
    };
    const isWithinBounds = (rect) => (
        rect.x >= 0 &&
        rect.y >= 0 &&
        rect.x + rect.width <= pageBounds.width &&
        rect.y + rect.height <= pageBounds.height
    );
    const checkPosition = (pos) => {
        const candidateRect = {
            x: pos.x - badgeSize.width / 2,
            y: pos.y - badgeSize.height / 2,
            ...badgeSize
        };
        if (isWithinBounds(candidateRect) && !obstacles.some(obs => isOverlapping(candidateRect, obs))) {
            return pos;
        }
        return null;
    };
    const preferredOffsets = [
        { x: 0, y: -(badgeSize.height / 2 + 10) }, { x: 0, y: (badgeSize.height / 2 + 10) },
        { x: (badgeSize.width / 2 + 10), y: 0 },   { x: -(badgeSize.width / 2 + 10), y: 0 }
    ];
    for (const offset of preferredOffsets) {
        const position = checkPosition({ x: pointAbs.x + offset.x, y: pointAbs.y + offset.y });
        if (position) return position;
    }

    let x = pointAbs.x, y = pointAbs.y, dx = 0, dy = -1, stepSize = 10, stepsInSegment = 1, turnCounter = 0;
    for (let i = 0; i < 1000; i++) {
        for (let j = 0; j < Math.floor(stepsInSegment); j++) {
            x += dx * stepSize;
            y += dy * stepSize;
            const position = checkPosition({ x, y });
            if (position) return position;
        }
        [dx, dy] = [-dy, dx];
        turnCounter++;
        if (turnCounter % 2 === 0) stepsInSegment += 0.5;
    }
    return { x: pointAbs.x, y: pointAbs.y - (badgeSize.height / 2 + 10) };
}
--- FIN DEL ARCHIVO: src/utils/plano-layout.js ---

--- INICIO DEL ARCHIVO: src/utils/logger.js ---
// src/utils/logger.js

/**
 * Sistema de logging condicional para desarrollo/producci√≥n
 *
 * En producci√≥n: Solo errores cr√≠ticos
 * En desarrollo: Logs completos con contexto
 */

const isDevelopment = import.meta.env.DEV || import.meta.env.MODE === 'development';

const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  NONE: 4
};

// En producci√≥n solo mostramos errores, en desarrollo todo
const currentLogLevel = isDevelopment ? LOG_LEVELS.DEBUG : LOG_LEVELS.ERROR;

class Logger {
  constructor(context = 'App') {
    this.context = context;
  }

  _log(level, levelName, message, ...args) {
    if (level < currentLogLevel) return;

    const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
    const prefix = `[${timestamp}] [${this.context}]`;

    switch (level) {
      case LOG_LEVELS.DEBUG:
        console.log(`${prefix} üîç`, message, ...args);
        break;
      case LOG_LEVELS.INFO:
        console.log(`${prefix} ‚ÑπÔ∏è`, message, ...args);
        break;
      case LOG_LEVELS.WARN:
        console.warn(`${prefix} ‚ö†Ô∏è`, message, ...args);
        break;
      case LOG_LEVELS.ERROR:
        console.error(`${prefix} ‚ùå`, message, ...args);
        break;
    }
  }

  debug(message, ...args) {
    this._log(LOG_LEVELS.DEBUG, 'DEBUG', message, ...args);
  }

  info(message, ...args) {
    this._log(LOG_LEVELS.INFO, 'INFO', message, ...args);
  }

  warn(message, ...args) {
    this._log(LOG_LEVELS.WARN, 'WARN', message, ...args);
  }

  error(message, ...args) {
    this._log(LOG_LEVELS.ERROR, 'ERROR', message, ...args);
  }

  // Helper para crear loggers con contexto espec√≠fico
  static create(context) {
    return new Logger(context);
  }
}

// Logger por defecto
export const logger = new Logger('App');

// Factory para crear loggers con contexto
export const createLogger = (context) => new Logger(context);

// Export para usar en console.log existentes sin cambiar mucho c√≥digo
export default logger;

--- FIN DEL ARCHIVO: src/utils/logger.js ---

--- INICIO DEL ARCHIVO: src/utils/provincias.js ---
// src/utils/provincias.js
export const provincias = [
  '√Ålava', 'Albacete', 'Alicante', 'Almer√≠a', 'Asturias', '√Åvila', 'Badajoz', 'Barcelona', 'Burgos', 'C√°ceres', 
  'C√°diz', 'Cantabria', 'Castell√≥n', 'Ciudad Real', 'C√≥rdoba', 'La Coru√±a', 'Cuenca', 'Gerona', 'Granada', 'Guadalajara', 
  'Guip√∫zcoa', 'Huelva', 'Huesca', 'Islas Baleares', 'Ja√©n', 'Le√≥n', 'L√©rida', 'Lugo', 'Madrid', 'M√°laga', 'Murcia', 
  'Navarra', 'Orense', 'Palencia', 'Las Palmas', 'Pontevedra', 'La Rioja', 'Salamanca', 'Segovia', 'Sevilla', 
  'Soria', 'Tarragona', 'Santa Cruz de Tenerife', 'Teruel', 'Toledo', 'Valencia', 'Valladolid', 'Vizcaya', 'Zamora', 'Zaragoza'
];
--- FIN DEL ARCHIVO: src/utils/provincias.js ---

--- INICIO DEL ARCHIVO: src/utils/checklist.js ---
// src/utils/checklist.js
export const checklistItems = [
  { id: 1, text: "Existe copia de la documentaci√≥n de validaci√≥n" },
  { id: 2, text: "Tiene las placas de identificaci√≥n correctamente colocadas y son legibles." },
  { id: 3, text: "El n√∫mero de m√≥dulos y niveles se corresponde con el establecido en el documento de validaci√≥n." },
  { id: 4, text: "Los niveles de altura est√°n dentro de los l√≠mites establecidos." },
  { id: 5, text: "El tipo de puntal se corresponde con el del documento de validaci√≥n." },
  { id: 6, text: "La verticalidad de los puntales est√° dentro de los l√≠mites permitidos." },
  { id: 7, text: "Las placas base no presentan deterioro y tienen todos los tornillos de fijaci√≥n previsto." },
  { id: 8, text: "Las placas base no presentan descalce." },
  { id: 9, text: "La estanter√≠a no est√° fijada a otros elementos." },
  { id: 10, text: "La estanter√≠a no sirve de soporte a otros elementos." },
  { id: 11, text: "Los puntales no presentan deterioro." },
  { id: 12, text: "Las diagonales y horizontales de bastidores no presentan deterioro." },
  { id: 13, text: "El tipo de larguero se corresponde con el del documento de validaci√≥n." },
  { id: 14, text: "Los largueros no presentan deterioro." },
  { id: 15, text: "Los largueros est√°n montados horizontales y a la misma altura que el larguero opuesto." },
  { id: 16, text: "La flecha de los largueros est√° dentro de los l√≠mites establecidos en el documento de validaci√≥n." },
  { id: 17, text: "Los largueros tienen puesto correctamente el dispositivo de fijaci√≥n (horquillas)." },
  { id: 18, text: "No se aprecia en inspecci√≥n visual grietas en soldadura o material base." },
  { id: 19, text: "Los elementos del sistema no presentan degradaci√≥n por p√©rdida de pintura de protecci√≥n y/o oxidaci√≥n." },
  { id: 20, text: "El estado de las protecciones en el bastidor es correcto (mantienen distancia de seguridad y est√°n correctamente fijadas al suelo)." },
  { id: 21, text: "Las cargas se ajustan a las dimensiones estandarizadas para las paletas." },
  { id: 22, text: "Las cargas a nivel de suelo no sobresalen de la alineaci√≥n, respetando los anchos de pasillo." },
  { id: 23, text: "La iluminaci√≥n es adecuada." },
  { id: 24, text: "En estanter√≠as de picking las barandillas de segundo nivel est√°n en perfecto estado, tienen pasamanos superior, intermedio y rodapi√©." },
  { id: 25, text: "En estanter√≠as de picking se mantienen todos los elementos de los niveles previstos y en caso contrario se mantiene los largueros y/o baldas superiores y se ha se√±alizado correctamente 'no utilizar'." },
  { id: 26, text: "La carga se distribuye uniformemente y de forma ordenada." },
  { id: 27, text: "Las cargas est√°n dentro de los l√≠mites establecidos en las placas identificativas." },
];
--- FIN DEL ARCHIVO: src/utils/checklist.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-checklist.js ---
// src/utils/pdf/pdf-module-checklist.js

import autoTable from 'jspdf-autotable';
import { checklistItems } from '../checklist';
import { FONT_SIZES, DOC_WIDTH, drawHeader, loadImageAsBase64 } from './pdf-helpers'; // Importamos loadImageAsBase64
import { getArselLogoUrl } from './pdf-helpers';
import { supabase } from '../../supabase';

function getHighestSeverity(incidencias) {
    if (incidencias.some(inc => inc.gravedad === 'rojo')) return 'rojo';
    if (incidencias.some(inc => inc.gravedad === 'ambar')) return 'ambar';
    if (incidencias.some(inc => inc.gravedad === 'verde')) return 'verde';
    return null;
}

export async function buildChecklistAnnex(pdf, reportData) {
    const LOCAL_MARGIN = 15;
    const { inspectionData, salasData, puntosMaestrosData, puntosInspeccionadosData, incidenciasData } = reportData;

    if (!incidenciasData || incidenciasData.length === 0) {
        return;
    }

    const [customFieldsRes, arselLogoUrl] = await Promise.all([
        supabase.from('checklist_custom_fields').select('*'),
        getArselLogoUrl()
    ]);
    const customFieldsMap = new Map(customFieldsRes.data.map(f => [f.id, f]));
    const puntosInspeccionadosConIncidenciasIds = new Set(incidenciasData.map(inc => inc.punto_inspeccionado_id));
    const puntosMaestrosConIncidenciasIds = new Set(
        puntosInspeccionadosData
            .filter(pi => puntosInspeccionadosConIncidenciasIds.has(pi.id))
            .map(pi => pi.punto_maestro_id)
    );
    if (puntosMaestrosConIncidenciasIds.size === 0) {
        return;
    }

    pdf.addPage();
    autoTable(pdf, {
        body: [['ANEXO 02:\nCHECKLIST']],
        startY: 145,
        theme: 'plain',
        styles: { 
            fontSize: FONT_SIZES.annexTitle, 
            fontStyle: 'bold', 
            halign: 'center',
            font: 'helvetica',
            textColor: 0
        },
        margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
    });

    for (const sala of salasData) {
        const puntosDeLaSala = puntosMaestrosData
            .filter(pm => pm.sala_id === sala.id && puntosMaestrosConIncidenciasIds.has(pm.id))
            .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}));
        
        if (puntosDeLaSala.length === 0) {
            continue;
        }

        for (const puntoMaestro of puntosDeLaSala) {
            pdf.addPage();

            const [clientLogoBase64, arselLogoBase64] = await Promise.all([
                loadImageAsBase64(inspectionData.centros.url_logo_cliente, { optimize: false }),
                loadImageAsBase64(arselLogoUrl, { optimize: false })
            ]);

            const logoHeight = 8;
            const headerY = 12;
            const arselLogoWidth = 30;

            if (clientLogoBase64) {
                pdf.addImage(clientLogoBase64, 'JPEG', LOCAL_MARGIN, headerY, 0, logoHeight);
            }
            if (arselLogoBase64) {
                pdf.addImage(arselLogoBase64, 'JPEG', DOC_WIDTH - LOCAL_MARGIN - arselLogoWidth, headerY, arselLogoWidth, logoHeight);
            }
            
            const firstTableStartY = headerY + logoHeight + 3;

            autoTable(pdf, {
                body: [['FORMATO DE INSPECCI√ìN DEL SISTEMA DE ALMACENAJE']],
                startY: firstTableStartY,
                theme: 'grid',
                styles: {
                    fontSize: 10,
                    fontStyle: 'bold',
                    halign: 'center',
                    fillColor: [255, 192, 0],
                    textColor: 0,
                    lineColor: 0,
                    lineWidth: 0.1,
                    minCellHeight: 8
                },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });

            autoTable(pdf, {
                body: [[
                    `CENTRO: ${inspectionData.centros.nombre.toUpperCase()}`,
                    `Reserva: ${sala.nombre.toUpperCase()}`,
                    `Alineaci√≥n: ${puntoMaestro.nomenclatura.split('-').pop()}`
                ]],
                startY: pdf.lastAutoTable.finalY,
                theme: 'grid',
                styles: {
                    fontStyle: 'bold',
                    fontSize: 9,
                    textColor: 0,
                    lineColor: 0,
                    lineWidth: 0.1,
                    valign: 'middle',
                    minCellHeight: 8
                },
                columnStyles: {
                    0: { cellWidth: 108, halign: 'left' },
                    1: { cellWidth: 42, halign: 'center' },
                    2: { cellWidth: 30, halign: 'center' }
                },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });
            
            const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.punto_maestro_id === puntoMaestro.id);
            const puntoInspeccionadoId = puntoInspeccionado ? puntoInspeccionado.id : null;
            
            const head = [
                [
                    { content: 'Par√°metro de control', rowSpan: 2, styles: { halign: 'center', valign: 'middle', fontSize: 9 } },
                    { content: 'S', rowSpan: 2, styles: { halign: 'center', valign: 'middle', fontSize: 8 } },
                    { content: 'I', rowSpan: 2, styles: { halign: 'center', valign: 'middle', fontSize: 8 } },
                    { content: 'RIESGO', colSpan: 3, styles: { halign: 'center', fontSize: 8 } }
                ],
                [{ content: 'V', styles: { fontSize: 8 } }, { content: 'A', styles: { fontSize: 8 } }, { content: 'R', styles: { fontSize: 8 } }]
            ];
            
            const body = checklistItems.map(item => {
                const itemIncidencias = incidenciasData.filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && inc.item_checklist === item.id);
                const tieneIncidencias = itemIncidencias.length > 0;
                const maxSeverity = tieneIncidencias ? getHighestSeverity(itemIncidencias) : null;
                
                return [
                    `${item.id}. ${item.text}`,
                    !tieneIncidencias ? 'X' : '',
                    tieneIncidencias ? 'X' : '',
                    maxSeverity === 'verde' ? 'X' : '',
                    maxSeverity === 'ambar' ? 'X' : '',
                    maxSeverity === 'rojo' ? 'X' : '',
                ];
            });

            autoTable(pdf, {
                head, body, 
                startY: pdf.lastAutoTable.finalY,
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }, 
                theme: 'grid',
                headStyles: { 
                    fillColor: [220, 220, 220], 
                    textColor: 0, 
                    fontStyle: 'bold', 
                    halign: 'center', 
                    lineColor: 0, 
                    lineWidth: 0.1, 
                    font: 'helvetica' 
                },
                // --- INICIO DE LA CORRECCI√ìN 2: Reducir el espaciado de las celdas ---
                styles: { fontSize: 8, cellPadding: 1.0, overflow: 'linebreak', lineColor: 0, lineWidth: 0.1, font: 'helvetica', textColor: 0 }, // cellPadding reducido de 1.5 a 1.0
                // --- FIN DE LA CORRECCI√ìN 2 ---
                columnStyles: {
                    0: { cellWidth: 136 },
                    1: { cellWidth: 7, halign: 'center' }, 
                    2: { cellWidth: 7, halign: 'center' }, 
                    3: { cellWidth: 10, halign: 'center' }, 
                    4: { cellWidth: 10, halign: 'center' }, 
                    5: { cellWidth: 10, halign: 'center' },
                },
            });

            let finalY = pdf.lastAutoTable.finalY;

            // --- INICIO DE LA CORRECCI√ìN 1: Bajar el l√≠mite de observaciones ---
            const OBSERVACIONES_THRESHOLD_COUNT = 10; // Reducido de 12 a 10
            // --- FIN DE LA CORRECCI√ìN 1 ---

            const observacionesArray = incidenciasData
                .filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && (inc.observaciones || inc.custom_fields))
                .map((obs) => {
                    let parts = [];
                    if (obs.custom_fields) {
                        const customs = Object.entries(obs.custom_fields).map(([fieldId, value]) => {
                            const field = customFieldsMap.get(parseInt(fieldId));
                            return field && value ? `${field.field_name}: ${value}` : '';
                        }).filter(s => s);
                        parts.push(...customs);
                    }
                    if (obs.observaciones && obs.observaciones.trim()) {
                        parts.push(`Observaciones: ${obs.observaciones.trim()}`);
                    }
                    if (parts.length > 0) {
                        return { text: `Par√°metro ${obs.item_checklist}: ${parts.join(' / ')}` };
                    }
                    return null;
                })
                .filter(obs => obs !== null);

            if (observacionesArray.length >= OBSERVACIONES_THRESHOLD_COUNT) {
                const placeholderText = '* Las observaciones detalladas para esta alineaci√≥n se encuentran en la p√°gina siguiente.';
                autoTable(pdf, {
                    body: [[{ content: placeholderText, styles: { fontStyle: 'italic', valign: 'top' } }]],
                    startY: finalY,
                    theme: 'grid',
                    styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 20, font: 'helvetica', textColor: 0 },
                    margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
                });
                finalY = pdf.lastAutoTable.finalY;

                pdf.addPage();
                await drawHeader(pdf, inspectionData, arselLogoUrl);

                autoTable(pdf, {
                    head: [[`Observaciones Detalladas de la Alineaci√≥n: ${puntoMaestro.nomenclatura}`]],
                    body: observacionesArray.map(obs => [obs.text]),
                    startY: 40,
                    theme: 'grid',
                    headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold' },
                    styles: { fontSize: FONT_SIZES.small, font: 'helvetica', textColor: 0 },
                    margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
                });

            } else {
                const observacionesDelPunto = observacionesArray.map(obs => obs.text).join('\n');
                autoTable(pdf, {
                    body: [[{ content: `Observaciones:\n${observacionesDelPunto}`, styles: { fontStyle: 'bold', valign: 'top' } }]],
                    startY: finalY,
                    theme: 'grid',
                    styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 20, font: 'helvetica', textColor: 0 },
                    margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
                });
                finalY = pdf.lastAutoTable.finalY;
            }

            const fechaInspeccion = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
            autoTable(pdf, {
                body: [[
                    `Fecha revisi√≥n: ${fechaInspeccion}\n\nFirma de Arsel Ingenieria S.L.:`,
                    `Firma del PRSES:`
                ]],
                startY: finalY,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 15, valign: 'top', font: 'helvetica', textColor: 0 },
                columnStyles: { 1: { halign: 'left' } },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });

            autoTable(pdf, {
                body: [['S: Satisfactorio, I: Insatisfactorio; V: Verde, A: √Åmbar, R: Rojo']],
                startY: pdf.lastAutoTable.finalY,
                theme: 'plain',
                styles: { fontSize: 7, halign: 'left', font: 'helvetica', textColor: 0 },
                margin: { left: LOCAL_MARGIN, right: LOCAL_MARGIN }
            });
        }
    }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-checklist.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-summary.js ---
// src/utils/pdf/pdf-module-summary.js

import { MARGIN } from './pdf-helpers';

function drawInfoBadge(pdf, position, pointData, badgeSizeMM) {
    const { width: BADGE_WIDTH_MM, height: BADGE_HEIGHT_MM } = badgeSizeMM;

    const FONT_SIZE_HEADER = BADGE_HEIGHT_MM * 0.70;
    const FONT_SIZE_STATE = BADGE_HEIGHT_MM * 0.38;
    const FONT_SIZE_SEMAPHORE = BADGE_HEIGHT_MM * 0.45;

    let stateText = null;
    if (pointData.estado === 'nuevo') stateText = 'NUEVA';
    else if (pointData.estado === 'suprimido') stateText = 'SUPRIMIDA';
    else if (pointData.detalle_modificacion === 'aumentado') stateText = 'AUMENTADA';
    else if (pointData.detalle_modificacion === 'disminuido') stateText = 'DISMINUIDA';

    const startX = position.x - BADGE_WIDTH_MM / 2;
    let currentY = position.y - BADGE_HEIGHT_MM / 2;

    pdf.setFillColor(255, 255, 255);
    pdf.roundedRect(startX, currentY, BADGE_WIDTH_MM, BADGE_HEIGHT_MM, 1, 1, 'F');

    pdf.setFontSize(FONT_SIZE_HEADER).setFont(undefined, 'bold');
    pdf.setTextColor(50, 50, 50);
    const headerText = `${pointData.nomenclatura.split('-').pop() || '?'}`;
    
    const headerY = stateText ? currentY + BADGE_HEIGHT_MM * 0.22 : currentY + BADGE_HEIGHT_MM * 0.35;
    pdf.text(headerText, position.x, headerY, { align: 'center' });

    if (stateText) {
        pdf.setFontSize(FONT_SIZE_STATE).setFont(undefined, 'bold');
        pdf.setTextColor(29, 78, 216);
        pdf.text(stateText, position.x, headerY + BADGE_HEIGHT_MM * 0.2, { align: 'center' });
    }
    
    currentY += BADGE_HEIGHT_MM * 0.5;
    pdf.setDrawColor(220, 220, 220);
    pdf.line(startX + 1, currentY, startX + BADGE_WIDTH_MM - 1, currentY);
    currentY += 0.5;

    const items = [
      { color: [34, 197, 94], count: pointData.counts.verde },
      { color: [245, 158, 11], count: pointData.counts.ambar },
      { color: [239, 68, 68], count: pointData.counts.rojo },
    ];
    const circleRadius = BADGE_HEIGHT_MM * 0.15;
    const semaphoreStartX = position.x - (items.length - 1) * (circleRadius * 2 + 0.8) / 2;
    
    pdf.setFontSize(FONT_SIZE_SEMAPHORE).setFont(undefined, 'bold');
    
    items.forEach((item, index) => {
        const circleX = semaphoreStartX + index * (circleRadius * 2 + 0.8);
        const circleY = currentY + BADGE_HEIGHT_MM * 0.2;
        pdf.setFillColor(item.color[0], item.color[1], item.color[2]);
        pdf.circle(circleX, circleY, circleRadius, 'F');
        pdf.setTextColor(255, 255, 255);
        pdf.text(String(item.count), circleX, circleY, { align: 'center', baseline: 'middle' });
    });
}

function drawLeaderLine(pdf, from, to) {
    pdf.setDrawColor(150, 150, 150);
    pdf.setLineWidth(0.2);
    pdf.line(from.x, from.y, to.x, to.y);
}

export async function buildSummaryAnnex(pdf, reportData, finalLabels, originalDimensions) {
    const { planoBase64 } = reportData;

    const PAGE_WIDTH_MM = pdf.internal.pageSize.getWidth();
    const PAGE_HEIGHT_MM = pdf.internal.pageSize.getHeight();
    
    const pageBounds = { x: MARGIN, y: MARGIN, width: PAGE_WIDTH_MM - MARGIN * 2, height: PAGE_HEIGHT_MM - MARGIN * 2 };

    const pageAspectRatio = pageBounds.width / pageBounds.height;
    const imageAspectRatio = originalDimensions.width / originalDimensions.height;

    let imgWidthMM, imgHeightMM, planoStartX, planoStartY;
    if (imageAspectRatio > pageAspectRatio) {
        imgWidthMM = pageBounds.width;
        imgHeightMM = imgWidthMM / imageAspectRatio;
        planoStartX = pageBounds.x;
        planoStartY = pageBounds.y + (pageBounds.height - imgHeightMM) / 2;
    } else {
        imgHeightMM = pageBounds.height;
        imgWidthMM = imgHeightMM * imageAspectRatio;
        planoStartY = pageBounds.y;
        planoStartX = pageBounds.x + (pageBounds.width - imgWidthMM) / 2;
    }

    pdf.addImage(planoBase64, 'JPEG', planoStartX, planoStartY, imgWidthMM, imgHeightMM, undefined, 'FAST');
    
    const labelsInMM = finalLabels.map(label => {
        const pointPdfX = planoStartX + (label.pointData.relativeX * imgWidthMM);
        const pointPdfY = planoStartY + (label.pointData.relativeY * imgHeightMM);
        const labelPdfX = planoStartX + (label.position.x * imgWidthMM);
        const labelPdfY = planoStartY + (label.position.y * imgHeightMM);
        
        const badgeSizeMM = {
            width: label.size.width * imgWidthMM,
            height: label.size.height * imgHeightMM
        };

        return {
            pointData: label.pointData,
            pointPosition: { x: pointPdfX, y: pointPdfY },
            labelPosition: { x: labelPdfX, y: labelPdfY },
            badgeSizeMM: badgeSizeMM
        };
    });

    labelsInMM.forEach(label => {
        drawLeaderLine(pdf, label.pointPosition, label.labelPosition);
    });
    
    labelsInMM.forEach(label => {
        drawInfoBadge(pdf, label.labelPosition, label.pointData, label.badgeSizeMM);
    });
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-summary.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-text.js ---
// src/utils/pdf/pdf-module-text.js

import { drawHeader, loadImageAsBase64, getArselLogoUrl, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

export async function buildTextPages(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;

  // Fetch logo URL
  const arselLogoUrl = await getArselLogoUrl();

  const CONTENT_WIDTH = DOC_WIDTH - (MARGIN * 2);

  const fecha = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
  const puntoMaestroASalaMap = new Map();
  puntosMaestrosData.forEach(pm => {
    const sala = salasData.find(s => s.id === pm.sala_id);
    if (sala) puntoMaestroASalaMap.set(pm.id, sala);
  });
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const agruparPuntosPorPropiedad = (propiedad, valor) => {
    const puntosFiltrados = puntosInspeccionadosData.filter(pi => pi[propiedad] === valor);
    if (puntosFiltrados.length === 0) return '';
    const grupos = {};
    puntosFiltrados.forEach(pi => {
      const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
      if (sala) {
        if (!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
        grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
      }
    });
    return Object.keys(grupos).sort().map(nombreSala =>
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
  };

  const agruparPuntosConPlacaInvalida = () => {
    const puntosConProblemaDePlaca = puntosInspeccionadosData.filter(pi => 
        pi.tiene_placa_caracteristicas === false || pi.detalle_modificacion === 'aumentado'
    );
      
    if (puntosConProblemaDePlaca.length === 0) return '';

    const grupos = {};
    puntosConProblemaDePlaca.forEach(pi => {
        const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
        if(sala) {
            if(!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
            grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
        }
    });
    return Object.keys(grupos).sort().map(nombreSala => 
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
  };

  const lineasSuprimidas = agruparPuntosPorPropiedad('estado', 'suprimido');
  const lineasNuevas = agruparPuntosPorPropiedad('estado', 'nuevo');
  const lineasDisminuidas = agruparPuntosPorPropiedad('detalle_modificacion', 'disminuido');
  const lineasAumentadas = agruparPuntosPorPropiedad('detalle_modificacion', 'aumentado');
  const lineasConPlacaInvalida = agruparPuntosConPlacaInvalida();
  
  const getSalaYNumeroDeIncidencia = (incidencia) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(incidencia.punto_inspeccionado_id);
    if (!puntoMaestroId) return null;
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    if (!sala || !puntoMaestro) return null;
    return { nombreSala: sala.nombre, numeroPunto: puntoMaestro.nomenclatura.split('-').pop() };
  };

  const agruparIncidenciasPorSala = (incidencias) => {
    if (incidencias.length === 0) return '';
    const grupos = {};
    incidencias.forEach(inc => {
      const info = getSalaYNumeroDeIncidencia(inc);
      if (info) {
        if (!grupos[info.nombreSala]) grupos[info.nombreSala] = new Set();
        grupos[info.nombreSala].add(info.numeroPunto);
      }
    });
    const nombresDeSalasOrdenados = Object.keys(grupos).sort((a, b) => a.localeCompare(b));
    return nombresDeSalasOrdenados.map(nombreSala => {
      const numerosOrdenados = [...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ');
      return `${nombreSala.toUpperCase()}: ${numerosOrdenados}`;
    }).join('\n');
  };

  const incidenciasVerdeAmbar = incidenciasData.filter(i => i.gravedad === 'verde' || i.gravedad === 'ambar');
  const textoVerdeAmbar = agruparIncidenciasPorSala(incidenciasVerdeAmbar);
  const incidenciasRojo = incidenciasData.filter(i => i.gravedad === 'rojo');
  const textoRojo = agruparIncidenciasPorSala(incidenciasRojo);
  
  const TOP_MARGIN = 50;

  // --- P√ÅGINA 1 ---
  await drawHeader(pdf, inspectionData, arselLogoUrl);
  let currentY = TOP_MARGIN;
  
  pdf.setFont('helvetica', 'bold');
  const titulo = `INFORME VISITA INSPECCI√ìN DEL SISTEMA DE ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES DEL CENTRO ${inspectionData.centros.nombre.toUpperCase()}`;
  pdf.setFontSize(FONT_SIZES.title);
  const tituloLines = pdf.splitTextToSize(titulo, CONTENT_WIDTH);
  pdf.text(tituloLines, DOC_WIDTH / 2, currentY, { align: 'center' });
  currentY += (tituloLines.length * 9) + 15;

  pdf.setFontSize(FONT_SIZES.h1).setFont('helvetica', 'bold'); 
  pdf.text('1. OBJETO', MARGIN, currentY); 
  currentY += 8; 
  pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); 
  pdf.text(`Con motivo de la visita programada para la inspecci√≥n del sistema de almacenaje para cargas paletizadas y manuales del ${inspectionData.centros.nombre}, se redacta el presente informe que recoge de forma somera el resultado de la visita.`, MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 40;

  pdf.setFontSize(FONT_SIZES.h1).setFont('helvetica', 'bold'); 
  pdf.text('2. ANTECEDENTES', MARGIN, currentY); 
  currentY += 8; 
  pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); 
  pdf.text('Para realizar la inspecci√≥n del sistema de almacenaje de cargas paletizadas y manuales ubicadas en las reservas se toma como base la memoria t√©cnica previa de evaluaci√≥n de dichos sistemas facilitada al centro para la realizaci√≥n de las correcciones oportunas. Este documento establece los par√°metros dimensionales y de carga, as√≠ como los elementos y medidas de seguridad que deben contemplar los sistemas de almacenaje para garantizar su estabilidad y uso seguro.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 40; 
  pdf.text('La inspecci√≥n consiste en la revisi√≥n visual del sistema llevada a cabo por un t√©cnico cualificado, con la comprobaci√≥n de los puntos recogidos en el checklist previsto para tal fin en la memoria de evaluaci√≥n previa, con el consiguiente registro escrito de los resultados obtenidos.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  
  pdf.addPage();
  await drawHeader(pdf, inspectionData, arselLogoUrl);
  currentY = TOP_MARGIN;

  // --- P√ÅGINA 2 Y SIGUIENTES ---
  const PAGE_HEIGHT = pdf.internal.pageSize.getHeight();
  const FOOTER_MARGIN = 30;

  const checkPageBreak = async (heightNeeded) => {
    if (currentY + heightNeeded > PAGE_HEIGHT - FOOTER_MARGIN) {
      pdf.addPage();
      await drawHeader(pdf, inspectionData, arselLogoUrl);
      currentY = TOP_MARGIN;
    }
  };

  const addSection = async (title, content) => {
    content = content || 'Ninguna';

    const titleHeight = 8;
    const contentHeight = content.split('\n').length * 5 + 5;
    await checkPageBreak(titleHeight + contentHeight);

    pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body).text(title, MARGIN, currentY);
    currentY += titleHeight;
    pdf.setFont('helvetica', 'bold').text(content, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += contentHeight;
  };

  pdf.setFontSize(FONT_SIZES.h1).setFont('helvetica', 'bold'); 
  pdf.text('3. RESULTADO DE LA VISITA', MARGIN, currentY); 
  currentY += 8; 
  pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); 
  pdf.text('En rasgos generales los sistemas de almacenaje cumplen los par√°metros establecidos en la memoria t√©cnica de evaluaci√≥n.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 15; 
  
  if (textoVerdeAmbar) {
    const introText = 'Se han detectado anomal√≠as de riesgo verde y/o √°mbar, tal y como se refleja en los listados de inspecci√≥n elaborados durante la visita en:';
    pdf.text(introText, MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 });
    const introTextHeight = pdf.splitTextToSize(introText, CONTENT_WIDTH).length * 5 * 1.5;
    currentY += introTextHeight;
  }

  if (textoVerdeAmbar) {
    pdf.setFont('helvetica', 'bold').setFontSize(FONT_SIZES.body);
    pdf.text(textoVerdeAmbar, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (textoVerdeAmbar.split('\n').length * 5) + 5;
  }
  
  pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body);
  
  const textoPostVerdeAmbar = 'Estas anomal√≠as, si bien no comprometen de forma inmediata la estabilidad ni seguridad del sistema, deben subsanarse lo antes posible para evitar que puedan derivar en un riesgo mayor. (Se adjuntan listados de chequeo y reportaje fotogr√°fico de la visita).';
  const newMargin = MARGIN + 5;
  const newContentWidth = DOC_WIDTH - (newMargin * 2);
  await checkPageBreak((pdf.splitTextToSize(textoPostVerdeAmbar, newContentWidth).length * 5 * 1.5) + 5);
  pdf.text(textoPostVerdeAmbar, newMargin, currentY, { maxWidth: newContentWidth, align: 'justify', lineHeightFactor: 1.5 });
  currentY += (pdf.splitTextToSize(textoPostVerdeAmbar, newContentWidth).length * 5 * 1.5) + 15;

  if(textoRojo) {
    currentY += 5;
    const textoPreRojo = 'Puntualmente, se han detectado anomal√≠as de riesgo rojo en:';
    await checkPageBreak(8 + textoRojo.split('\n').length * 5 + 5);
    pdf.text(textoPreRojo, MARGIN, currentY, { align: 'justify' }); 
    currentY += 8;
    pdf.setFont('helvetica', 'bold');
    pdf.text(textoRojo, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (textoRojo.split('\n').length * 5) + 5;
    
    pdf.setFont('helvetica', 'normal');
    const textoRiesgoRojo = 'Estas anomal√≠as deben subsanarse inmediatamente para evitar el colapso de las estanter√≠as en el caso de una combinaci√≥n de cargas desfavorables, procediendo a la descarga de la mercanc√≠a de los m√≥dulos afectados y se√±alizando la zona para que no se almacene producto en los mismos hasta que puedan ser sustituidos los elementos da√±ados. La sustituci√≥n se llevar√° a cabo con nuevo material que se tiene que solicitar si no cuenta con repuesto en el centro.';
    await checkPageBreak((pdf.splitTextToSize(textoRiesgoRojo, CONTENT_WIDTH).length * 5 * 1.5) + 15);
    pdf.text(textoRiesgoRojo, MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 });
    currentY += (pdf.splitTextToSize(textoRiesgoRojo, CONTENT_WIDTH).length * 5 * 1.5) + 15;
  }

  await addSection('Alineaciones sin ficha de caracter√≠sticas o con ficha no v√°lida:', lineasConPlacaInvalida);
  await addSection('Alineaciones con m√≥dulos DISMINUIDOS desde la inspecci√≥n anterior:', lineasDisminuidas);
  await addSection('Alineaciones con m√≥dulos AUMENTADOS desde la inspecci√≥n anterior:', lineasAumentadas);
  await addSection('Alineaciones desmontadas desde la inspecci√≥n anterior:', lineasSuprimidas);
  await addSection('Alineaciones nuevas montadas desde la inspecci√≥n anterior:', lineasNuevas);

  await checkPageBreak(80);
  pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body);
  pdf.text('Para cerrar el proceso de inspecci√≥n completo, el centro subsanar√° las deficiencias de menor grado detectadas en los pr√≥ximos d√≠as, comunicando la resoluci√≥n de las mismas mediante correo electr√≥nico a ARSEL Ingenier√≠a y al T√©cnico de Prevenci√≥n Regional.', MARGIN, currentY, { maxWidth: CONTENT_WIDTH, align: 'justify', lineHeightFactor: 1.5 }); 
  currentY += 40;
  pdf.text('Informe realizado por:', MARGIN, currentY);
  
  // --- INICIO DE LA CORRECCI√ìN ---
  currentY += 4; // 1. Reducir el espacio vertical
  const signatureLogoUrl = await getArselLogoUrl('signature_logo');
  const finalLogoUrl = signatureLogoUrl || arselLogoUrl;
  const arselLogoBase64 = await loadImageAsBase64(finalLogoUrl);
  if (arselLogoBase64) {
      pdf.addImage(arselLogoBase64, 'PNG', MARGIN, currentY, 55, 25, undefined, 'MEDIUM'); // 2. Aumentar el tama√±o de la imagen
      currentY += 28; // Ajustar el incremento de Y para que coincida con el nuevo tama√±o
  }
  // --- FIN DE LA CORRECCI√ìN ---

  pdf.setFont('helvetica', 'bold').text('ARSEL INGENIERIA', MARGIN, currentY);
  currentY += 5;
  pdf.setFont('helvetica', 'normal').text(`Valencia, ${fecha}`, MARGIN, currentY);
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-text.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-data.js ---
// src/utils/pdf/pdf-data.js

import { supabase } from '../../supabase';
import { loadImageAsBase64 } from './pdf-helpers';

export async function fetchReportData(inspeccionId, options = {}) {
  const { optimizePlan = true } = options;
  console.log(`[fetchReportData] Iniciando b√∫squeda de datos para la inspecci√≥n ID: ${inspeccionId}`);

  try {
    // √öNICA LLAMADA A LA BASE DE DATOS
    const { data: reportJson, error } = await supabase.rpc('get_report_data', {
      inspeccion_id_param: inspeccionId
    });

    if (error) {
      console.error('[fetchReportData] ¬°ERROR CR√çTICO al llamar a la funci√≥n RPC!', error);
      throw new Error(`Error en la funci√≥n de base de datos: ${error.message}`);
    }

    const reportData = reportJson; // El JSON ya viene con la estructura correcta

    const planoUrl = reportData.inspectionData.versiones_plano?.url_imagen_plano;
    const planoBase64 = planoUrl ? await loadImageAsBase64(planoUrl, { optimize: optimizePlan }) : null;

    // Calcular los contadores de incidencias (esto es r√°pido y se puede quedar en el cliente)
    const incidenceCounts = new Map();
    (reportData.puntosInspeccionadosData || []).forEach(pi => {
        incidenceCounts.set(pi.id, { verde: 0, ambar: 0, rojo: 0 });
    });
    (reportData.incidenciasData || []).forEach(inc => {
        const counts = incidenceCounts.get(inc.punto_inspeccionado_id);
        if (counts && counts[inc.gravedad] !== undefined) {
            counts[inc.gravedad]++;
        }
    });
    
    const result = {
      ...reportData,
      planoBase64,
      incidenceCounts,
    };
    
    console.log('[fetchReportData] B√∫squeda de datos con RPC completada con √©xito.');
    return result;

  } catch (error) {
    console.error('[fetchReportData] La funci√≥n ha fallado con una excepci√≥n:', error);
    return null;
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-data.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-gestion.js ---
// src/utils/pdf/pdf-module-gestion.js

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

// Helper para obtener el texto del estado
const getEstadoText = (estado) => {
  switch (estado) {
    case 'en_progreso': return 'En Progreso';
    case 'finalizada': return 'Pend. Env√≠o';
    case 'pendiente_subsanacion': return 'Pend. Cierre';
    case 'cerrada': return 'Cerrada';
    default: return 'Sin Inspecci√≥n';
  }
};

export async function generateGestionReport(resumenData) {
  // ===== PRUEBA IRREFUTABLE: Si ves este mensaje, est√°s ejecutando el c√≥digo nuevo =====
  console.log('‚úÖ ‚úÖ ‚úÖ Ejecutando generateGestionReport v2 (SIN LOGO) ‚úÖ ‚úÖ ‚úÖ');
  
  try {
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const PAGE_WIDTH = pdf.internal.pageSize.getWidth();
    const MARGIN = 15;

    // --- CABECERA DEL DOCUMENTO (SIN LOGO) ---
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.text('Informe Resumen Anual de Inspecciones', PAGE_WIDTH / 2, 17, { align: 'center' });
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`Fecha de generaci√≥n: ${new Date().toLocaleDateString('es-ES')}`, PAGE_WIDTH - MARGIN, 25, { align: 'right' });


    // --- TABLA DE DATOS ---
    const head = [
        [
            { content: 'Centro', rowSpan: 2, styles: { halign: 'left', valign: 'middle' } },
            { content: 'Regi√≥n', rowSpan: 2, styles: { halign: 'left', valign: 'middle' } },
            { content: '√öltima Inspecci√≥n', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Grupo Visita', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Estado Informe', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Cambios Alineaciones', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Faltan Fichas', rowSpan: 2, styles: { valign: 'middle' } },
            { content: 'Da√±os', colSpan: 3, styles: { halign: 'center' } },
        ],
        [
            { content: 'V' },
            { content: 'A' },
            { content: 'R' }
        ]
    ];

    const body = resumenData.map(item => [
      item.centro_nombre,
      item.region || '-',
      item.fecha_inspeccion ? new Date(item.fecha_inspeccion + 'T00:00:00').toLocaleDateString('es-ES') : '-',
      item.grupo_visita || '-',
      getEstadoText(item.estado_informe),
      item.cambios_en_alineaciones,
      item.faltan_fichas ? 'SI' : 'NO',
      item.danos_verdes,
      item.danos_ambares,
      item.danos_rojos
    ]);

    autoTable(pdf, {
      head: head,
      body: body,
      startY: 35,
      theme: 'grid',
      margin: { left: MARGIN, right: MARGIN },
      styles: {
        fontSize: 7,
        cellPadding: 1.5,
        valign: 'middle',
        overflow: 'linebreak'
      },
      headStyles: {
        fillColor: [75, 85, 99],
        textColor: 255,
        fontStyle: 'bold',
        halign: 'center',
        fontSize: 8,
        cellWidth: 'wrap'
      },
      alternateRowStyles: {
        fillColor: [243, 244, 246]
      },
      columnStyles: {
        0: { cellWidth: 45, halign: 'left' },
        1: { cellWidth: 28, halign: 'left' },
        2: { cellWidth: 17, halign: 'center' },
        3: { cellWidth: 15, halign: 'center' },
        4: { cellWidth: 17, halign: 'center' },
        5: { cellWidth: 17, halign: 'center' },
        6: { cellWidth: 15, halign: 'center' },
        7: { cellWidth: 9, halign: 'center' },
        8: { cellWidth: 9, halign: 'center' },
        9: { cellWidth: 9, halign: 'center' },
      },
      didParseCell: function (data) {
        if (data.row.section === 'head' && data.row.index === 1) {
          if (data.column.index === 0) data.cell.styles.fillColor = [34, 197, 94];
          if (data.column.index === 1) data.cell.styles.fillColor = [245, 158, 11];
          if (data.column.index === 2) data.cell.styles.fillColor = [239, 68, 68];
          data.cell.styles.textColor = 255;
          data.cell.styles.fontStyle = 'bold';
        }

        if (data.row.section === 'body') {
          if (data.column.index === 6 && data.cell.raw === 'SI') {
            data.cell.styles.textColor = [239, 68, 68];
            data.cell.styles.fontStyle = 'bold';
          }
          if (data.column.index === 7 && data.cell.raw > 0) data.cell.styles.fillColor = '#e0f2e9';
          if (data.column.index === 8 && data.cell.raw > 0) data.cell.styles.fillColor = '#fff4e0';
          if (data.column.index === 9 && data.cell.raw > 0) data.cell.styles.fillColor = '#ffe0e0';
        }
      },
      didDrawPage: function (data) {
        const pageCount = pdf.internal.getNumberOfPages();
        pdf.setFontSize(8);
        pdf.setTextColor(100);
        pdf.text(
          `P√°gina ${data.pageNumber} de ${pageCount}`,
          PAGE_WIDTH / 2,
          pdf.internal.pageSize.getHeight() - 10,
          { align: 'center' }
        );
      }
    });

    const fileName = `Informe_Gestion_Anual_${new Date().toISOString().slice(0, 10)}.pdf`;
    pdf.save(fileName);

  } catch (error) {
    console.error("Error generando el PDF de gesti√≥n:", error);
    alert("Hubo un error al generar el PDF. Revisa la consola para m√°s detalles.");
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-gestion.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-photos.js ---
// src/utils/pdf/pdf-module-photos.js

import { checklistItems } from '../checklist';
import { drawHeader, loadImageAsBase64, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';
import { getArselLogoUrl } from './pdf-helpers';
import { supabase } from '../../supabase';

// --- ANEXO DE FOTOS INICIAL (OPTIMIZADO) ---
export async function buildInitialPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;

  const incidenciasConFoto = incidenciasData.filter(inc =>
    inc.url_foto_antes && inc.item_checklist !== 2
  );
  if (incidenciasConFoto.length === 0) return;

  // Fetch custom fields and logo
  const [customFieldsRes, arselLogoUrl] = await Promise.all([
    supabase.from('checklist_custom_fields').select('*'),
    getArselLogoUrl()
  ]);
  const customFieldsMap = new Map(customFieldsRes.data.map(f => [f.id, f]));

  const puntoMaestroASalaMap = new Map(puntosMaestrosData.map(pm => [pm.id, salasData.find(s => s.id === pm.sala_id)]));
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const getSortInfoForIncidencia = (inc) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(inc.punto_inspeccionado_id);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    return {
      salaNombre: sala ? sala.nombre : 'ZZZ',
      puntoNumero: puntoMaestro ? parseInt(puntoMaestro.nomenclatura.split('-').pop() || 0) : 9999
    };
  };

  incidenciasConFoto.sort((a, b) => {
    const infoA = getSortInfoForIncidencia(a);
    const infoB = getSortInfoForIncidencia(b);
    const comparacionSala = infoA.salaNombre.localeCompare(infoB.salaNombre);
    if (comparacionSala !== 0) return comparacionSala;
    return infoA.puntoNumero - infoB.puntoNumero;
  });

  pdf.addPage();
  await drawHeader(pdf, inspectionData, arselLogoUrl);
  
  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont('helvetica', 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  pdf.text('REPORTAJE FOTOGR√ÅFICO', DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont('helvetica', 'normal');

  for (const incidencia of incidenciasConFoto) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;

    pdf.addPage();
    await drawHeader(pdf, inspectionData, arselLogoUrl);
    
    let currentY = 45;
    pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'normal');
    pdf.text(`Alineaci√≥n: ${puntoMaestro.nomenclatura}`, MARGIN, currentY);
    currentY += 8;

    const checklistItem = checklistItems.find(item => item.id === incidencia.item_checklist);
    if (checklistItem) {
      pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'italic');
      pdf.setTextColor(100);
      const itemText = `Incidencia: ${checklistItem.id}. ${checklistItem.text}`;
      const splitText = pdf.splitTextToSize(itemText, DOC_WIDTH - (MARGIN * 2));
      pdf.text(splitText, MARGIN, currentY);
      currentY += (splitText.length * 5) + 5;
      pdf.setTextColor(0);
      pdf.setFont('helvetica', 'normal');
    }

    const photoWidth = DOC_WIDTH - (MARGIN * 2);
    const photoHeight = photoWidth * (100 / 180);

    const fotoAntesBase64 = await loadImageAsBase64(incidencia.url_foto_antes);
    if(fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN, currentY, photoWidth, photoHeight, undefined, 'MEDIUM');
    }

    let obsBlockY = currentY + photoHeight + 10;
    pdf.setFontSize(FONT_SIZES.body);
    let obsText = '';
    if (incidencia.custom_fields) {
      const customs = Object.entries(incidencia.custom_fields).map(([fieldId, value]) => {
        const field = customFieldsMap.get(parseInt(fieldId));
        return field ? `${field.field_name}: ${value}` : '';
      }).filter(s => s).join(' / ');
      if (customs) obsText = customs;
    }
    const obsNotes = incidencia.observaciones || '';
    if (obsNotes) obsText = obsText ? `${obsText} / ${obsNotes}` : obsNotes;
    
    // ===== CAMBIO 1: Ajustamos c√≥mo se dibuja el bloque de observaciones =====
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight + 2); // +2 for padding

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont('helvetica', 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 12); // Aumentamos el espacio vertical
  }
}


// --- ANEXO DE FOTOS DE SUBSANACI√ìN (OPTIMIZADO) ---
export async function buildRemediationPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData } = reportData;

  const incidenciasCorregidas = incidenciasData.filter(inc => inc.url_foto_antes && inc.url_foto_despues);
  if (incidenciasCorregidas.length === 0) return;

  // Fetch custom fields and logo
  const [customFieldsRes, arselLogoUrl] = await Promise.all([
    supabase.from('checklist_custom_fields').select('*'),
    getArselLogoUrl()
  ]);
  const customFieldsMap = new Map(customFieldsRes.data.map(f => [f.id, f]));

  pdf.addPage();
  await drawHeader(pdf, inspectionData, arselLogoUrl);

  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont('helvetica', 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  const remediationTitleLines = pdf.splitTextToSize('INFORME FOTOGR√ÅFICO DE CIERRE', 180);
  pdf.text(remediationTitleLines, DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont('helvetica', 'normal');
  
  for (const incidencia of incidenciasCorregidas) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;
    
    pdf.addPage();
    await drawHeader(pdf, inspectionData, arselLogoUrl);
    pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'normal').text(`Correcci√≥n de Incidencia: ${puntoMaestro.nomenclatura}`, MARGIN, 45);

    const [fotoAntesBase64, fotoDespuesBase64] = await Promise.all([
      loadImageAsBase64(incidencia.url_foto_antes, { maxWidth: 600, maxHeight: 600 }),
      loadImageAsBase64(incidencia.url_foto_despues, { maxWidth: 600, maxHeight: 600 })
    ]);
    
    const photoBoxY = 65;
    const photoBoxSize = (DOC_WIDTH - (MARGIN * 2) - 10) / 2;
    const photoPadding = 2;

    pdf.text('ANTES', MARGIN + (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(MARGIN, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'MEDIUM');
    }
    
    const secondPhotoX = MARGIN + photoBoxSize + 10;
    pdf.text('DESPU√âS', secondPhotoX + (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(secondPhotoX, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoDespuesBase64) {
      pdf.addImage(fotoDespuesBase64, 'JPEG', secondPhotoX + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'MEDIUM');
    }
    
    let obsBlockY = 160;
    pdf.setFontSize(FONT_SIZES.body);
    let obsText = '';
    if (incidencia.custom_fields) {
      const customs = Object.entries(incidencia.custom_fields).map(([fieldId, value]) => {
        const field = customFieldsMap.get(parseInt(fieldId));
        return field ? `${field.field_name}: ${value}` : '';
      }).filter(s => s).join(' / ');
      if (customs) obsText = customs;
    }
    const obsNotes = incidencia.observaciones || '';
    if (obsNotes) obsText = obsText ? `${obsText} / ${obsNotes}` : obsNotes;

    // ===== CAMBIO 1: Ajustamos c√≥mo se dibuja el bloque de observaciones =====
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight + 2); // +2 for padding

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont('helvetica', 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 12); // Aumentamos el espacio vertical
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-photos.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/index.js ---
import jsPDF from 'jspdf';
import { fetchReportData } from './pdf-data';
import { buildTextPages } from './pdf-module-text';
import { buildInitialPhotoAnnex, buildRemediationPhotoAnnex } from './pdf-module-photos';
import { buildChecklistAnnex } from './pdf-module-checklist';
import { buildSummaryAnnex } from './pdf-module-summary';
// --- INICIO DE LA CORRECCI√ìN: Importamos getArselLogoUrl ---
import { drawHeader, FONT_SIZES, DOC_WIDTH, getArselLogoUrl } from './pdf-helpers';

function sanitizeFileName(name) {
  let sanitized = name.replace(/\s+/g, '_');
  sanitized = sanitized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  sanitized = sanitized.replace(/[^a-zA-Z0-9_.-]/g, '');
  return sanitized;
}

export async function generateTextReport(inspeccionId, reportType = 'initial', outputType = 'download') {
  try {
    console.log(`Iniciando generaci√≥n de Informe de Texto (output: ${outputType})...`);
    const reportData = await fetchReportData(inspeccionId, { optimizePlan: true }); 
    if (!reportData) throw new Error("No se pudieron cargar los datos para el informe.");
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    console.log("Construyendo p√°ginas de texto...");
    await buildTextPages(pdf, reportData);
    
    if (reportType === 'initial') {
      console.log("Construyendo anexo de fotos inicial...");
      await buildInitialPhotoAnnex(pdf, reportData);
    } else if (reportType === 'remediation') {
      console.log("Construyendo anexo de fotos de subsanaci√≥n...");
      await buildRemediationPhotoAnnex(pdf, reportData);
    }
    
    console.log("Construyendo anexo de checklist...");
    await buildChecklistAnnex(pdf, reportData);

    // --- INICIO DE LA CORRECCI√ìN: Obtenemos y pasamos el logo de Arsel a la cabecera ---
    console.log("A√±adiendo p√°gina de Anexo de Planos...");
    const arselLogoUrl = await getArselLogoUrl(); // Obtenemos la URL del logo
    pdf.addPage();
    await drawHeader(pdf, reportData.inspectionData, arselLogoUrl); // Pasamos la URL a la funci√≥n
    pdf.setFontSize(FONT_SIZES.annexTitle);
    pdf.setFont('helvetica', 'bold');
    pdf.text('ANEXO 03:', DOC_WIDTH / 2, 145, { align: 'center' });
    pdf.text('PLANOS', DOC_WIDTH / 2, 155, { align: 'center' });
    // --- FIN DE LA CORRECCI√ìN ---
    
    const { inspectionData } = reportData;
    const reportTypeName = reportType === 'initial' ? 'Informe_Inicial' : 'Informe_Cierre';
    
    const rawFileName = `${reportTypeName}_${inspectionData.centros.nombre}_${inspectionData.fecha_inspeccion}.pdf`;
    const fileName = sanitizeFileName(rawFileName);

    if (outputType === 'blob') {
      console.log('Devolviendo PDF como Blob.');
      return { blob: pdf.output('blob'), fileName: fileName };
    } else {
      console.log(`Guardando PDF como: ${fileName}`);
      pdf.save(fileName);
      return { blob: null, fileName: fileName };
    }

  } catch (err) {
    console.error("Error generando el Informe de Texto:", err);
    alert(`Hubo un error al generar el informe. Revisa la consola: ${err.message}`);
    return null;
  }
}


export async function generatePlanPdf(inspeccionId, finalLabels, originalDimensions) {
  try {
    console.log("Iniciando generaci√≥n de PDF del Plano en formato A3...");
    const reportData = await fetchReportData(inspeccionId, { optimizePlan: false }); 
    
    if (!reportData.planoBase64) {
        throw new Error("No se pudo cargar la imagen del plano para esta inspecci√≥n.");
    }

    const pdf = new jsPDF('l', 'mm', 'a3');
    
    console.log("Construyendo anexo de resumen visual con posiciones ajustadas...");
    await buildSummaryAnnex(pdf, reportData, finalLabels, originalDimensions);
    
    const { inspectionData } = reportData;
    
    const rawFileName = `Plano_Incidencias_${inspectionData.centros.nombre}_${inspectionData.fecha_inspeccion}.pdf`;
    const fileName = sanitizeFileName(rawFileName);

    console.log(`Guardando PDF como: ${fileName}`);
    pdf.save(fileName);

  } catch (err) {
    console.error("Error generando el PDF del Plano:", err);
    alert(`Hubo un error al generar el plano. Revisa la consola: ${err.message}`);
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/index.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-helpers.js ---
// src/utils/pdf/pdf-helpers.js

// --- CONSTANTES ---
export const MARGIN = 25;
export const DOC_WIDTH = 210;
export const DOC_WIDTH_LANDSCAPE = 297;
export const FONT_SIZES = { annexTitle: 22, title: 16, h1: 14, h2: 12, body: 11, small: 8 };

// --- FUNCI√ìN PARA OBTENER LOGO DIN√ÅMICO ---
export async function getArselLogoUrl(assetType = 'header_logo') {
  try {
    const { supabase } = await import('../../supabase');
    const { data: assets } = await supabase.from('company_assets').select('*');
    const assetsMap = new Map((assets || []).map(a => [a.asset_type, a.url]));
    return assetsMap.get(assetType) || null;
  } catch (error) {
    console.error('Error fetching ARSEL logo:', error);
    return null;
  }
}

// --- FUNCI√ìN DE AYUDA PARA CARGAR IM√ÅGENES (CON CONTROL DE OPTIMIZACI√ìN) ---
export async function loadImageAsBase64(url, options = {}) {
  // Opciones por defecto: optimizar siempre con un m√°ximo de 1024px
  const { optimize = true, maxWidth = 1024, maxHeight = 1024 } = options;

  if (!url || !url.startsWith('http')) return null;
  try {
    const response = await fetch(url);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.startsWith("image/")) {
      console.warn(`La URL no devolvi√≥ una imagen: ${url}`);
      return null;
    }
    const blob = await response.blob();

    return new Promise((resolve, reject) => {
      if (!optimize) {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
        return;
      }

      const img = new Image();
      const objectUrl = URL.createObjectURL(blob);
      img.src = objectUrl;
      
      img.onload = () => {
        let { width, height } = img;
        
        if (width <= maxWidth && height <= maxHeight) {
            const reader = new FileReader();
            reader.onloadend = () => {
                URL.revokeObjectURL(objectUrl);
                resolve(reader.result);
            };
            reader.onerror = (err) => {
                URL.revokeObjectURL(objectUrl);
                reject(err);
            };
            reader.readAsDataURL(blob);
            return;
        }

        const ratio = Math.min(maxWidth / width, maxHeight / height);
        const newWidth = Math.floor(width * ratio);
        const newHeight = Math.floor(height * ratio);
        
        const canvas = document.createElement('canvas');
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, newWidth, newHeight);
        
        const dataUrl = canvas.toDataURL('image/jpeg', 0.80);
        
        URL.revokeObjectURL(objectUrl);
        resolve(dataUrl);
      };

      img.onerror = (err) => {
        URL.revokeObjectURL(objectUrl);
        reject(err);
      };
    });

  } catch (error) {
    console.error("Error cargando y optimizando imagen para PDF:", url, error);
    return null;
  }
}

// --- CABECERA PRINCIPAL (REUTILIZABLE EN TODO EL PDF) ---
export async function drawHeader(pdf, inspectionData, arselLogoUrl = null) {
  const [clientLogoBase64, arselLogoBase64] = await Promise.all([
    loadImageAsBase64(inspectionData.centros.url_logo_cliente, { optimize: false }),
    arselLogoUrl ? loadImageAsBase64(arselLogoUrl, { optimize: false }) : Promise.resolve(null)
  ]);

  const pageSize = pdf.internal.pageSize;
  const pageWidth = pageSize.getWidth();
  
  const HEADER_MARGIN = 15;
  const headerY = 10;
  const headerHeight = 22;
  const contentWidth = pageWidth - (HEADER_MARGIN * 2); 
  
  const cell1Width = 38;
  const cell3Width = 32;
  const cell2Width = contentWidth - cell1Width - cell3Width;
  const textCenter = HEADER_MARGIN + cell1Width + (cell2Width / 2);

  // Dibujar el contorno y las l√≠neas
  pdf.rect(HEADER_MARGIN, headerY, contentWidth, headerHeight);
  pdf.line(HEADER_MARGIN, headerY + 8, pageWidth - HEADER_MARGIN, headerY + 8);
  pdf.line(HEADER_MARGIN + cell1Width, headerY + 8, HEADER_MARGIN + cell1Width, headerY + headerHeight);
  pdf.line(HEADER_MARGIN + cell1Width + cell2Width, headerY + 8, HEADER_MARGIN + cell1Width + cell2Width, headerY + headerHeight);

  // T√≠tulo del Centro
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(FONT_SIZES.h2);
  pdf.text(`${inspectionData.centros.nombre.toUpperCase()}`, pageWidth / 2, headerY + 5.5, { align: 'center' });

  const logoY = headerY + 8 + ((headerHeight - 8) - 9) / 2;
  
  // Logo Cliente (Celda 1)
  if (clientLogoBase64) {
    pdf.addImage(clientLogoBase64, 'JPEG', HEADER_MARGIN + 2, logoY, cell1Width - 4, 9, undefined, 'MEDIUM');
  }

  // Subt√≠tulo del Informe (Celda 2)
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(10); 

  const titleLines = [
    "INFORME VISITA INSPECCI√ìN DEL SISTEMA DE",
    "ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES"
  ];
  
  const cellBottomY = headerY + headerHeight;
  const cellTopY = headerY + 8;
  const cellMiddleY = cellTopY + (cellBottomY - cellTopY) / 2;
  
  const lineSpacing = 4.5; 
  
  const startY = cellMiddleY - (lineSpacing / 2);

  pdf.text(titleLines[0], textCenter, startY, { align: 'center', baseline: 'middle' });
  pdf.text(titleLines[1], textCenter, startY + lineSpacing, { align: 'center', baseline: 'middle' });
  
  // Logo Arsel (Celda 3)
  if (arselLogoBase64) {
    pdf.addImage(arselLogoBase64, 'JPEG', HEADER_MARGIN + cell1Width + cell2Width + 2, logoY, cell3Width - 4, 9, undefined, 'MEDIUM');
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-helpers.js ---

--- INICIO DEL ARCHIVO: src/utils/excel/excel-module-gestion.js ---
// src/utils/excel/excel-module-gestion.js

import * as XLSX from 'xlsx-js-style';

const getEstadoInfo = (estado) => {
  switch (estado) {
    case 'en_progreso': return { text: 'En Progreso', style: { font: { color: { rgb: "2563EB" } } } }; // Blue
    case 'finalizada': return { text: 'Pend. Env√≠o', style: { font: { color: { rgb: "D97706" } } } }; // Amber
    case 'pendiente_subsanacion': return { text: 'Pend. Cierre', style: { font: { color: { rgb: "F59E0B" } } } }; // Yellow
    case 'cerrada': return { text: 'Cerrada', style: { font: { color: { rgb: "10B981" } } } }; // Green
    default: return { text: 'Sin Inspecci√≥n', style: { font: { color: { rgb: "6B7280" } } } }; // Gray
  }
};

export async function generateGestionExcel(resumenData) {
  try {
    // --- ESTILOS PROFESIONALES ---
    const headerStyle = { font: { sz: 12, bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "2563EB" } }, alignment: { vertical: "center", horizontal: "center" } };
    const titleStyle = { font: { sz: 18, bold: true }, alignment: { horizontal: "center" } };
    const baseCellStyle = { font: { sz: 11, name: 'Calibri' }, alignment: { vertical: "center" } };
    const centerAlignStyle = { alignment: { horizontal: "center", vertical: "center" } };
    const bandedRowStyle = { fill: { fgColor: { rgb: "F3F4F6" } } };
    const redTextStyle = { font: { bold: true, color: { rgb: "EF4444" } } };

    // --- PREPARACI√ìN DE DATOS ---
    const headers = ["Centro", "Regi√≥n", "√öltima Inspecci√≥n", "Grupo Visita", "Estado Informe", "Cambios Alineaciones", "Faltan Fichas", "Da√±os (Verdes)", "Da√±os (√Åmbar)", "Da√±os (Rojos)"];
    
    const dataRows = resumenData.map(item => ([
      item.centro_nombre,
      item.region || '-',
      item.fecha_inspeccion ? new Date(item.fecha_inspeccion + 'T00:00:00') : '-',
      item.grupo_visita || '-',
      getEstadoInfo(item.estado_informe).text,
      item.cambios_en_alineaciones,
      item.faltan_fichas ? 'SI' : 'NO',
      item.danos_verdes,
      item.danos_ambares,
      item.danos_rojos
    ]));
    
    const finalData = [
      ['Informe de Gesti√≥n Anual'],
      [`Fecha de Generaci√≥n: ${new Date().toLocaleDateString('es-ES')}`],
      [],
      headers,
      ...dataRows
    ];

    // --- CREACI√ìN Y ESTILIZADO DE LA HOJA ---
    const worksheet = XLSX.utils.aoa_to_sheet(finalData);

    // Unir t√≠tulo
    worksheet['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } }];
    worksheet['A1'].s = titleStyle;

    // Aplicar estilos a la cabecera
    for (let C = 0; C < headers.length; C++) {
      const cellAddress = XLSX.utils.encode_cell({ r: 3, c: C });
      worksheet[cellAddress].s = headerStyle;
    }

    // Aplicar estilos a las filas de datos
    for (let R = 4; R < finalData.length; R++) {
      const item = resumenData[R - 4]; // -4 to align with dataRows index
      const isBanded = (R - 4) % 2 === 1;

      for (let C = 0; C < headers.length; C++) {
        const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
        if (!worksheet[cellAddress]) continue;

        let cellStyle = { ...baseCellStyle };
        if (isBanded) cellStyle.fill = bandedRowStyle.fill;
        
        // Estilos y formatos espec√≠ficos
        switch(C) {
          case 2: // √öltima Inspecci√≥n (Fecha)
            if (worksheet[cellAddress].v instanceof Date) {
              worksheet[cellAddress].t = 'd';
              worksheet[cellAddress].z = 'dd/mm/yyyy';
            }
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 4: // Estado Informe
            cellStyle.font = { ...cellStyle.font, ...getEstadoInfo(item.estado_informe).style.font, bold: true };
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 6: // Faltan Fichas
            if (worksheet[cellAddress].v === 'SI') cellStyle.font = { ...cellStyle.font, ...redTextStyle.font };
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 7: // Da√±os Verdes
            if(worksheet[cellAddress].v > 0) cellStyle.fill = { fgColor: { rgb: "E0F2F1" } }; // Light green
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 8: // Da√±os √Åmbar
            if(worksheet[cellAddress].v > 0) cellStyle.fill = { fgColor: { rgb: "FFFBEB" } }; // Light amber
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 9: // Da√±os Rojos
            if(worksheet[cellAddress].v > 0) cellStyle.fill = { fgColor: { rgb: "FEF2F2" } }; // Light red
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
          case 3: case 5: // Grupo Visita, Cambios Alineaciones
            cellStyle.alignment = { ...cellStyle.alignment, ...centerAlignStyle };
            break;
        }
        worksheet[cellAddress].s = cellStyle;
      }
    }
    
    // Ancho de columnas
    worksheet['!cols'] = [ { wch: 45 }, { wch: 25 }, { wch: 18 }, { wch: 15 }, { wch: 18 }, { wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 } ];
    // Auto-filtro
    worksheet['!autofilter'] = { ref: `A4:${XLSX.utils.encode_col(headers.length - 1)}4` };
    // Congelar panel
    worksheet['!view'] = { state: 'frozen', ySplit: 4 };

    // --- DESCARGA ---
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Resumen de Gesti√≥n');
    const fileName = `Informe_Gestion_Anual_${new Date().toISOString().slice(0, 10)}.xlsx`;
    XLSX.writeFile(workbook, fileName);

  } catch (error) {
    console.error("Error generando el archivo XLSX de gesti√≥n:", error);
    alert("Hubo un error al generar el archivo Excel. Revisa la consola para m√°s detalles.");
  }
}
--- FIN DEL ARCHIVO: src/utils/excel/excel-module-gestion.js ---

--- INICIO DEL ARCHIVO: src/components/PointList.vue ---
<!-- src/components/PointList.vue -->
<script setup>
import { ref } from 'vue';
import { EyeSlashIcon, ArrowUturnLeftIcon, TrashIcon, ChevronDownIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  groupedPoints: Array,
  canEdit: Boolean,
  allIncidencias: {
    type: Array,
    default: () => []
  }
});

const emit = defineEmits(['select-point', 'update-state', 'delete-new-point']);

const openSalaId = ref(null);

const toggleSala = (salaId) => {
  openSalaId.value = openSalaId.value === salaId ? null : salaId;
};

function handleUpdateState(punto, newState) {
  emit('update-state', punto, newState);
}

// Calculate incident counts for a specific point
function getIncidentCountsForPoint(puntoId) {
  const incidents = props.allIncidencias.filter(inc => inc.punto_inspeccionado_id === puntoId);
  return {
    verde: incidents.filter(inc => inc.gravedad === 'verde').length,
    ambar: incidents.filter(inc => inc.gravedad === 'ambar').length,
    rojo: incidents.filter(inc => inc.gravedad === 'rojo').length,
    total: incidents.length
  };
}
</script>

<template>
  <div class="space-y-2">
    <div v-for="grupo in groupedPoints" :key="grupo.id">
      <div class="w-full flex justify-between items-center p-3 rounded-lg" :class="openSalaId === grupo.id ? 'bg-blue-50' : 'hover:bg-slate-50'">
        <button @click="toggleSala(grupo.id)" class="flex-1 flex items-center text-left gap-2">
          <h3 class="font-bold text-slate-700">{{ grupo.nombre }}</h3>
          <span v-if="grupo.isNew" class="text-xs font-bold text-orange-600 bg-orange-100 px-2 py-0.5 rounded-full">NUEVA</span>
          <ChevronDownIcon class="h-5 w-5 text-slate-400 transition-transform" :class="{'rotate-180': openSalaId === grupo.id}" />
        </button>
        <slot name="sala-actions" :sala="grupo"></slot>
      </div>

      <ul v-if="openSalaId === grupo.id" class="space-y-1 pl-4 border-l-2 ml-3">
        <li v-for="punto in grupo.puntos" :key="punto.id">
          <div :class="['p-2 rounded-lg flex items-center justify-between group', { 'bg-slate-100': punto.estado === 'suprimido' }]">
            <!-- ===== CORRECCI√ìN: El div entero ahora emite el evento para abrir el modal ===== -->
            <div @click="$emit('select-point', punto)" class="flex-1 flex items-center cursor-pointer">
              <span class="w-3 h-3 rounded-full flex-shrink-0" :style="{ backgroundColor: punto.color }"></span>

              <span
                :class="['font-semibold ml-3', { 'line-through text-slate-500': punto.estado === 'suprimido', 'text-slate-700': punto.estado !== 'suprimido' }]"
              >
                {{ punto.nomenclatura }}
              </span>

              <!-- Incident indicators (semaphore badges) -->
              <div v-if="getIncidentCountsForPoint(punto.id).total > 0" class="flex items-center gap-1 ml-2">
                <!-- Green dot + count -->
                <div v-if="getIncidentCountsForPoint(punto.id).verde > 0" class="flex items-center gap-0.5">
                  <span class="h-1.5 w-1.5 rounded-full bg-green-500"></span>
                  <span class="text-[10px] font-semibold text-slate-600">{{ getIncidentCountsForPoint(punto.id).verde }}</span>
                </div>
                <!-- Amber dot + count -->
                <div v-if="getIncidentCountsForPoint(punto.id).ambar > 0" class="flex items-center gap-0.5">
                  <span class="h-1.5 w-1.5 rounded-full bg-amber-500"></span>
                  <span class="text-[10px] font-semibold text-slate-600">{{ getIncidentCountsForPoint(punto.id).ambar }}</span>
                </div>
                <!-- Red dot + count -->
                <div v-if="getIncidentCountsForPoint(punto.id).rojo > 0" class="flex items-center gap-0.5">
                  <span class="h-1.5 w-1.5 rounded-full bg-red-500"></span>
                  <span class="text-[10px] font-semibold text-slate-600">{{ getIncidentCountsForPoint(punto.id).rojo }}</span>
                </div>
              </div>

              <span v-if="punto.estado === 'nuevo'" class="ml-2 text-xs font-bold text-green-600 bg-green-100 px-2 py-0.5 rounded-full">NUEVO</span>
            </div>

            <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
              <button v-if="punto.estado === 'nuevo'" @click.stop="$emit('delete-new-point', punto)" class="p-1 text-slate-400 hover:text-red-500" title="Borrar punto nuevo">
                <TrashIcon class="h-5 w-5" />
              </button>
              
              <button v-if="punto.estado !== 'suprimido'" @click.stop="handleUpdateState(punto, 'suprimido')" class="p-1 text-slate-400 hover:text-red-500" title="Marcar como suprimido">
                <EyeSlashIcon class="h-5 w-5" />
              </button>
              <button v-else @click.stop="handleUpdateState(punto, 'existente')" class="p-1 text-slate-500 hover:text-blue-500" title="Reactivar punto">
                <ArrowUturnLeftIcon class="h-5 w-5" />
              </button>
            </div>
          </div>
        </li>
      </ul>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/PointList.vue ---

--- INICIO DEL ARCHIVO: src/components/ChecklistModal.vue ---
<!-- src/components/ChecklistModal.vue -->
<script setup>
import { ref, watch, computed, nextTick, inject } from 'vue';
import { supabase } from '../supabase';
// --- INICIO DE LA MODIFICACI√ìN: Importamos addToQueue ---
import { addToQueue, getFileLocally } from '../utils/syncQueue';
// --- FIN DE LA MODIFICACI√ìN ---
import { checklistItems } from '../utils/checklist';
import { useFileUpload } from '../composables/useFileUpload';
import {
  ArrowUpTrayIcon, CheckCircleIcon, XCircleIcon, PlusCircleIcon, TrashIcon,
  ChevronUpIcon, ChevronDownIcon, PencilIcon, CheckIcon
} from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  punto: Object,
  inspeccionId: Number,
  initialIncidencias: { type: Array, required: true },
  availableCustomFields: { type: Array, required: true },
  existingIdentifiersInSala: { type: Array, default: () => [] }
});

const emit = defineEmits(['close', 'save', 'update-nomenclatura', 'update:incidencias']);
const showNotification = inject('showNotification');

const incidencias = ref([]);
const puntoInspeccionado = computed(() => props.punto);
const customFields = ref([]);
const customValues = ref({});
const collapsedItems = ref(new Set());
const isEditingName = ref(false);
const tempPointIdentifier = ref('');
const nameInputRef = ref(null);
const { isUploading, handleFileUpload: processAndUploadFile } = useFileUpload(props.inspeccionId, props.punto.id);
const dragOverIncidenceId = ref(null);


const hydrateOfflineImages = async () => {
  for (const inc of incidencias.value) {
    if (inc.offlinePhotoKey_antes && !inc.url_foto_antes?.startsWith('blob:')) {
      try {
        const fileData = await getFileLocally(inc.offlinePhotoKey_antes);
        if (fileData) {
          inc.url_foto_antes = URL.createObjectURL(fileData);
        }
      } catch (error) {
        console.error(`No se pudo reconstruir la vista previa para ${inc.offlinePhotoKey_antes}:`, error);
      }
    }
  }
};

watch(() => props.isOpen, async (newVal) => {
  if (newVal) {
    incidencias.value = JSON.parse(JSON.stringify(props.initialIncidencias));
    customFields.value = props.availableCustomFields;
    customValues.value = {};
    incidencias.value.forEach(inc => {
        customValues.value[inc.id] = inc.custom_fields || {};
    });
    
    await hydrateOfflineImages();

    isEditingName.value = false;
    collapsedItems.value.clear();
  }
}, { immediate: true });


const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;

  // --- INICIO DE LA MODIFICACI√ìN: Borrado de foto antigua ---
  // Si ya hay una foto online, la marcamos para borrar.
  if (incidencia.url_foto_antes && incidencia.url_foto_antes.startsWith('http')) {
    addToQueue({
      type: 'deleteFile',
      bucket: 'incidencias',
      url: incidencia.url_foto_antes
    });
  }
  // --- FIN DE LA MODIFICACI√ìN ---

  const result = await processAndUploadFile(file, incidencia);
  if (result) {
    incidencia.url_foto_antes = result.previewUrl;
    incidencia.offlinePhotoKey_antes = result.offlinePhotoKey;
    emit('update:incidencias', incidencias.value);
  }
};

const onDrop = async (event, incidencia) => {
  event.preventDefault();
  dragOverIncidenceId.value = null;
  const files = event.dataTransfer.files;
  if (files.length === 0) return;
  const file = files[0];
  
  // --- INICIO DE LA MODIFICACI√ìN: Borrado de foto antigua ---
  if (incidencia.url_foto_antes && incidencia.url_foto_antes.startsWith('http')) {
    addToQueue({
      type: 'deleteFile',
      bucket: 'incidencias',
      url: incidencia.url_foto_antes
    });
  }
  // --- FIN DE LA MODIFICACI√ìN ---

  const result = await processAndUploadFile(file, incidencia);
  if (result) {
    incidencia.url_foto_antes = result.previewUrl;
    incidencia.offlinePhotoKey_antes = result.offlinePhotoKey;
    emit('update:incidencias', incidencias.value);
  }
};

const saveIncidencia = (incidencia) => {
  const { id, ...dataToUpdate } = incidencia;
  dataToUpdate.custom_fields = customValues.value[id] || {};

  // CRITICAL FIX: Update the incidencia object's custom_fields so it persists in the local state
  // This ensures that when the parent component receives the updated incidencias array,
  // the custom_fields are included and will be sent in the sync queue payload
  incidencia.custom_fields = dataToUpdate.custom_fields;

  emit('update:incidencias', incidencias.value);

  const payload = { ...dataToUpdate };
  delete payload.url_foto_antes;
  delete payload.offlinePhotoKey_antes;

  addToQueue({ table: 'incidencias', type: 'update', id: id, payload });
};

const addIncidencia = async (itemId, defaults = {}) => {
  if (!puntoInspeccionado.value) return;
  let defaultSeverity = defaults.gravedad || 'verde';
  if (!navigator.onLine && !defaults.gravedad) {
      defaultSeverity = 'ambar';
  } else if (!defaults.gravedad) {
    const { data: def } = await supabase.from('checklist_defaults').select('default_severity').eq('point_id', itemId).single();
    if (def) defaultSeverity = def.default_severity;
  }
  const tempId = `temp_${Date.now()}`;
  const newIncidencia = {
    id: tempId,
    punto_inspeccionado_id: puntoInspeccionado.value.id,
    inspeccion_id: props.inspeccionId,
    item_checklist: itemId,
    gravedad: defaultSeverity,
    observaciones: defaults.observaciones || null,
    custom_fields: {},
    url_foto_antes: null,
    url_foto_despues: null,
  };
  incidencias.value.push(newIncidencia);
  customValues.value[newIncidencia.id] = {};
  
  emit('update:incidencias', incidencias.value);

  const { id, ...payload } = newIncidencia;
  addToQueue({ table: 'incidencias', type: 'insert', tempId: tempId, payload: payload });
};

// --- INICIO DE LA MODIFICACI√ìN: Funci√≥n de borrado offline ---
const deleteIncidencia = (incidenciaId) => {
  const incidencia = incidencias.value.find(inc => inc.id === incidenciaId);
  if (!incidencia) return;

  // 1. Si hay una foto online, la encolamos para su borrado.
  if (incidencia.url_foto_antes && incidencia.url_foto_antes.startsWith('http')) {
    addToQueue({
      type: 'deleteFile',
      bucket: 'incidencias',
      url: incidencia.url_foto_antes
    });
  }

  // 2. Encolamos el borrado del registro de la incidencia.
  addToQueue({
    type: 'delete',
    table: 'incidencias',
    id: incidenciaId
  });

  // 3. Actualizamos la interfaz de usuario inmediatamente.
  incidencias.value = incidencias.value.filter(inc => inc.id !== incidenciaId);
  delete customValues.value[incidenciaId];
  emit('update:incidencias', incidencias.value);
  showNotification('Incidencia eliminada. Se sincronizar√° en segundo plano.', 'success');
};
// --- FIN DE LA MODIFICACI√ìN ---

const toggleItemStatus = async (itemId) => {
  const itemIncidencias = getIncidenciasForItem(itemId).value;
  if (itemIncidencias.length > 0) {
    if (confirm(`¬øMarcar este punto como "Satisfactorio"? Se borrar√°n las ${itemIncidencias.length} incidencias registradas.`)) {
      // Borramos cada incidencia usando la nueva funci√≥n offline-first
      for (const incidencia of itemIncidencias) {
        deleteIncidencia(incidencia.id);
      }
    }
  } else {
    await addIncidencia(itemId);
  }
};
const pointPrefix = computed(() => {
  if (!props.punto?.nomenclatura) return '';
  const parts = props.punto.nomenclatura.split('-');
  if (parts.length > 1) {
    parts.pop(); return `${parts.join('-')}-`;
  }
  return '';
});
const startNameEditing = () => {
  isEditingName.value = true;
  const parts = props.punto.nomenclatura.split('-');
  tempPointIdentifier.value = parts.length > 1 ? parts.pop() : props.punto.nomenclatura;
  nextTick(() => nameInputRef.value?.focus());
};

const saveName = () => {
  const newIdentifier = tempPointIdentifier.value.trim();
  const newNomenclature = `${pointPrefix.value}${newIdentifier}`;
  
  if (newIdentifier && newNomenclature !== props.punto.nomenclatura) {
    if (props.existingIdentifiersInSala.includes(newIdentifier)) {
      showNotification(`El identificador "${newIdentifier}" ya existe en esta sala. Por favor, elige otro.`, 'error');
      return;
    }
    
    findPuntoMaestroAndEmitUpdate(newNomenclature);
  }
  
  isEditingName.value = false;
};

const findPuntoMaestroAndEmitUpdate = async (newNomenclature) => {
  const { data: puntoMaestro, error } = await supabase.from('puntos_maestros').select('*').eq('id', props.punto.punto_maestro_id).single();
  if (puntoMaestro && !error) {
    emit('update-nomenclatura', puntoMaestro, newNomenclature);
  } else {
    alert('Error: No se pudo encontrar el punto maestro para actualizar.');
  }
};
const gravedadOptions = [{ label: 'Verde', value: 'verde' }, { label: 'Ambar', value: 'ambar' }, { label: 'Rojo', value: 'rojo' }];
const tienePlaca = computed({
  get: () => puntoInspeccionado.value?.tiene_placa_caracteristicas,
  set: (newValue) => { if (puntoInspeccionado.value) { puntoInspeccionado.value.tiene_placa_caracteristicas = newValue; handlePlacaStatusChange(newValue); } }
});
const handlePlacaStatusChange = async (status) => {
  if (!puntoInspeccionado.value) return;
  addToQueue({ table: 'puntos_inspeccionados', type: 'update', id: puntoInspeccionado.value.id, payload: { tiene_placa_caracteristicas: status } });

  const incidenciasPlaca = getIncidenciasForItem(2).value;
  if (status === true) {
    if (incidenciasPlaca.length > 0) {
      for (const inc of incidenciasPlaca) {
        deleteIncidencia(inc.id);
      }
    }
  } else {
    if (incidenciasPlaca.length === 0) { await addIncidencia(2, { gravedad: 'verde', observaciones: 'Falta ficha' }); }
  }
};
const getIncidenciasForItem = (itemId) => computed(() => incidencias.value.filter(inc => inc.item_checklist === itemId));
const getCustomFieldsForItem = (itemId) => customFields.value.filter(field => field.point_id === itemId);
const isCollapsed = (itemId) => collapsedItems.value.has(itemId);
const toggleCollapse = (itemId) => { if (isCollapsed(itemId)) { collapsedItems.value.delete(itemId); } else { collapsedItems.value.add(itemId); } };
const onDragOver = (event, incidenceId) => { event.preventDefault(); dragOverIncidenceId.value = incidenceId; };
const onDragLeave = (event) => { event.preventDefault(); dragOverIncidenceId.value = null; };
const handleClose = () => {
  for (const item of checklistItems) {
    const itemFields = getCustomFieldsForItem(item.id);
    const itemIncidencias = getIncidenciasForItem(item.id).value;
    if (itemIncidencias.length > 0) {
      for (const field of itemFields) {
        if (field.required) {
          const hasFilledField = itemIncidencias.some(inc => customValues.value[inc.id]?.[field.id]);
          if (!hasFilledField) {
            showNotification(`No se puede guardar sin completar los campos obligatorios. El campo "${field.field_name}" es obligatorio.`, 'error');
            return;
          }
        }
      }
    }
  }
  emit('save'); 
  emit('close');
};
</script>

<template>
<div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
<div class="bg-slate-50 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
<header class="p-4 border-b bg-white rounded-t-lg flex justify-between items-center">
<div class="flex items-center gap-2">
<h2 class="text-xl font-bold text-slate-800">Checklist para Punto:</h2>
<div v-if="isEditingName" class="flex items-center gap-1 bg-white border border-blue-400 rounded-md p-1">
<span class="text-slate-500 pl-1">{{ pointPrefix }}</span>
<input
ref="nameInputRef"
v-model="tempPointIdentifier"
@keyup.enter="saveName"
@keyup.esc="isEditingName = false"
type="text"
class="text-xl font-bold text-slate-800 p-0 border-none focus:ring-0 w-24"
/>
<button @click="saveName" class="p-1 text-green-600 hover:bg-green-100 rounded">
<CheckIcon class="h-5 w-5"/>
</button>
</div>
<h2 v-else class="text-xl font-bold text-slate-800">{{ punto?.nomenclatura }}</h2>
<button v-if="!isEditingName" @click="startNameEditing" class="p-1 text-slate-400 hover:text-blue-600">
<PencilIcon class="h-5 w-5"/>
</button>
</div>
<button @click="handleClose" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
</header>
<main class="flex-1 overflow-y-auto p-6 space-y-3">
    <div v-if="!punto" class="text-center p-10">Cargando datos del punto...</div>
    <div v-else>
      <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-6">
        <h3 class="font-bold text-blue-800 mb-3">¬øDispone de placa de caracter√≠sticas?</h3>
        <div class="flex flex-col sm:flex-row gap-4">
          <button @click="tienePlaca = true" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === true ? 'bg-green-600 text-white shadow-md ring-2 ring-offset-2 ring-green-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><CheckCircleIcon class="h-5 w-5" />S√≠, dispone de placa</button>
          <button @click="tienePlaca = false" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === false ? 'bg-red-600 text-white shadow-md ring-2 ring-offset-2 ring-red-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><XCircleIcon class="h-5 w-5" />No, no dispone de placa</button>
        </div>
        <p v-if="tienePlaca !== null" class="text-xs text-slate-500 mt-3 text-center">El estado del punto "2. Tiene las placas de identificaci√≥n..." se ha actualizado autom√°ticamente.</p>
      </div>

      <div v-for="item in checklistItems" :key="item.id" class="bg-white rounded-lg shadow-sm border transition-all duration-300">
        <div class="p-3 flex items-center justify-between">
          <p class="text-slate-700">{{ item.id }}. {{ item.text }}</p>
          <button
            @click="toggleItemStatus(item.id)"
            :class="['px-3 py-1 text-xs font-bold rounded-full',
                     getIncidenciasForItem(item.id).value.length > 0 ? 'bg-red-100 text-red-800 hover:bg-red-200' : 'bg-green-100 text-green-800 hover:bg-green-200']"
          >
            {{ getIncidenciasForItem(item.id).value.length > 0 ? 'INSATISFACTORIO' : 'SATISFACTORIO' }}
          </button>
        </div>

        <div v-if="getIncidenciasForItem(item.id).value.length > 0" class="border-t">
          <div 
            @click="toggleCollapse(item.id)" 
            class="bg-slate-100/50 p-2 flex justify-between items-center cursor-pointer hover:bg-slate-100"
          >
            <span class="text-sm font-semibold text-slate-600">
              {{ getIncidenciasForItem(item.id).value.length }} Incidencia(s)
            </span>
            <component :is="isCollapsed(item.id) ? ChevronDownIcon : ChevronUpIcon" class="h-5 w-5 text-slate-500" />
          </div>

          <div v-show="!isCollapsed(item.id)" class="bg-slate-50 p-4 space-y-4">
            <div v-for="(incidencia, index) in getIncidenciasForItem(item.id).value" :key="incidencia.id" class="bg-white border rounded-lg p-4 shadow-sm relative">
              <div class="flex justify-between items-center mb-3">
                <h4 class="font-bold text-slate-700">Incidencia #{{ index + 1 }}</h4>
                <button @click="deleteIncidencia(incidencia.id)" title="Borrar esta incidencia" class="p-1 text-slate-400 hover:text-red-500"><TrashIcon class="h-5 w-5"/></button>
              </div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="space-y-4">
                  <div>
                    <label class="block text-xs font-medium text-slate-600">Gravedad</label>
                    <select v-model="incidencia.gravedad" @change="saveIncidencia(incidencia)" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"><option v-for="opt in gravedadOptions" :key="opt.value" :value="opt.value">{{ opt.label }}</option></select>
                  </div>

                  <div v-if="getCustomFieldsForItem(item.id).length > 0" class="space-y-3">
                    <div v-for="field in getCustomFieldsForItem(item.id)" :key="field.id">
                      <label class="block text-xs font-medium text-slate-600">
                        {{ field.field_name }}
                        <span v-if="field.required" class="text-red-500">*</span>
                      </label>
                      <input
                        v-if="field.field_type === 'text'"
                        v-model="customValues[incidencia.id][field.id]"
                        @blur="saveIncidencia(incidencia)"
                        type="text"
                        :required="field.required"
                        class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"
                        :placeholder="`Ingrese ${field.field_name.toLowerCase()}`"
                      >
                      <input
                        v-else-if="field.field_type === 'number'"
                        v-model.number="customValues[incidencia.id][field.id]"
                        @blur="saveIncidencia(incidencia)"
                        type="number"
                        :required="field.required"
                        class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"
                        :placeholder="`Ingrese ${field.field_name.toLowerCase()}`"
                      >
                      <select
                        v-else-if="field.field_type === 'select'"
                        v-model="customValues[incidencia.id][field.id]"
                        @change="saveIncidencia(incidencia)"
                        :required="field.required"
                        class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"
                      >
                        <option value="">Seleccionar...</option>
                        <option v-for="option in field.options" :key="option" :value="option">{{ option }}</option>
                      </select>
                    </div>
                  </div>

                  <div>
                    <label class="block text-xs font-medium text-slate-600">Observaciones</label>
                    <textarea v-model="incidencia.observaciones" @blur="saveIncidencia(incidencia)" rows="3" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm"></textarea>
                  </div>
                </div>
                <div>
                  <label class="block text-xs font-medium text-slate-600 mb-1">Foto de la Incidencia</label>
                  <div
                    class="aspect-video bg-slate-200 rounded-md flex items-center justify-center overflow-hidden relative group transition-colors"
                    :class="{ 'bg-blue-200 border-2 border-blue-400 border-dashed': dragOverIncidenceId === incidencia.id }"
                    @dragover="onDragOver($event, incidencia.id)"
                    @dragleave="onDragLeave"
                    @drop="onDrop($event, incidencia)"
                  >
                    <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="object-cover w-full h-full">
                    <div v-else class="text-center p-4">
                      <p v-if="isUploading === incidencia.id" class="text-sm text-slate-600">Procesando...</p>
                      <p v-else-if="dragOverIncidenceId === incidencia.id" class="text-sm text-slate-600">Suelta la foto aqu√≠</p>
                      
                      <div v-else class="flex flex-col gap-2">
                        <label :for="'cameraInput-' + incidencia.id" class="cursor-pointer flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                          <ArrowUpTrayIcon class="h-4 w-4" /> Hacer Foto
                        </label>
                        <label :for="'fileInput-' + incidencia.id" class="cursor-pointer text-xs text-slate-600 hover:underline">
                          o seleccionar de la galer√≠a
                        </label>
                      </div>

                      <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'cameraInput-' + incidencia.id" accept="image/*" capture="environment">
                      <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id" accept="image/*">
                    </div>
                    <div v-if="incidencia.url_foto_antes" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                       <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-change-' + incidencia.id" accept="image/*">
                       <label :for="'fileInput-change-' + incidencia.id" class="cursor-pointer text-white text-sm font-semibold">Cambiar Foto</label>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div>
              <button @click="addIncidencia(item.id)" class="w-full flex items-center justify-center gap-2 py-2 text-sm font-semibold text-blue-700 bg-blue-50 rounded-md hover:bg-blue-100 border border-dashed border-blue-300"><PlusCircleIcon class="h-5 w-5"/>A√±adir otra incidencia</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="p-4 bg-white border-t rounded-b-lg flex justify-end">
    <button @click="handleClose" class="px-5 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Cerrar</button>
  </footer>
</div>
</div>
</template>
--- FIN DEL ARCHIVO: src/components/ChecklistModal.vue ---

--- INICIO DEL ARCHIVO: src/components/InspectionSidebar.vue ---
<!-- src/components/InspectionSidebar.vue -->
<script setup>
import { ref } from 'vue';
import PointList from './PointList.vue';
import AddPointForm from './AddPointForm.vue';
import { PlusIcon, XCircleIcon, CheckCircleIcon, PencilSquareIcon, MapIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  canEdit: Boolean,
  salas: Array,
  puntosAgrupados: Array,
  allIncidencias: {
    type: Array,
    default: () => []
  },
  isPlanoEditingMode: {
    type: Boolean,
    default: false
  },
  isMobileAddPointOpen: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits([
  'toggle-plano-editing',
  'add-sala',
  'start-area-drawing',
  'start-placement-mode',
  'cancel-placement-mode',
  'select-point',
  'update-point-state',
  'delete-new-point',
  'update-point-nomenclatura',
  'update:is-mobile-add-point-open'
]);

// Estado local para desktop
const isPlanoEditingModeLocal = ref(false);
const showAddSalaForm = ref(false);
const newSalaName = ref('');
const showAddPointForm = ref(false);
const isPlacementMode = ref(false);

const handleTogglePlanoEditing = () => {
  isPlanoEditingModeLocal.value = !isPlanoEditingModeLocal.value;
  emit('toggle-plano-editing', isPlanoEditingModeLocal.value);
  if (!isPlanoEditingModeLocal.value) {
    showAddSalaForm.value = false;
  }
};

const handleAddSala = () => {
  if (newSalaName.value.trim()) {
    emit('add-sala', newSalaName.value.trim());
    newSalaName.value = '';
    showAddSalaForm.value = false;
  }
};

const handleStartPlacement = (salaId) => {
  isPlacementMode.value = true;
  showAddPointForm.value = false;
  emit('update:is-mobile-add-point-open', false);
  emit('start-placement-mode', salaId);
};

const handleCancelPlacement = () => {
  isPlacementMode.value = false;
  emit('cancel-placement-mode');
};
</script>

<template>
  <aside class="w-full lg:w-80 xl:w-96 flex-shrink-0 bg-white border-r border-slate-200 flex flex-col overflow-hidden">
    <!-- Bot√≥n Editar Plano - SOLO VISIBLE EN DESKTOP -->
    <div class="hidden lg:block p-4 flex-shrink-0 border-b">
      <button v-if="canEdit" @click="handleTogglePlanoEditing"
              :class="[
                'w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold rounded-md shadow-sm transition-colors',
                isPlanoEditingModeLocal ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-white text-slate-700 border border-slate-300 hover:bg-slate-50'
              ]">
        <PencilSquareIcon class="h-5 w-5" />
        {{ isPlanoEditingModeLocal ? 'Finalizar Edici√≥n Plano' : 'Editar Plano' }}
      </button>
    </div>

    <!-- Formularios de Edici√≥n - SOLO VISIBLE EN DESKTOP -->
    <div class="hidden lg:block p-4 flex-shrink-0 space-y-2">
       <div v-if="canEdit && isPlanoEditingModeLocal" class="p-3 bg-orange-50 border border-orange-200 rounded-lg space-y-3">
          <h3 class="font-bold text-orange-800">Modo Edici√≥n de Plano</h3>
          <form v-if="showAddSalaForm" @submit.prevent="handleAddSala" class="flex gap-2">
              <input v-model="newSalaName" type="text" placeholder="Nombre nueva sala..." class="flex-1 block w-full rounded-md border-slate-300 shadow-sm text-sm">
              <button type="submit" class="p-2 bg-green-600 text-white rounded-md hover:bg-green-700"><CheckCircleIcon class="h-5 w-5"/></button>
              <button @click="showAddSalaForm = false" type="button" class="p-2 bg-red-600 text-white rounded-md hover:bg-red-700"><XCircleIcon class="h-5 w-5"/></button>
          </form>
          <button v-else @click="showAddSalaForm = true" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-600 bg-white rounded-md hover:bg-slate-50 border">
             <PlusIcon class="h-5 w-5" /> A√±adir Sala
          </button>
       </div>

       <div v-if="canEdit && !isPlanoEditingModeLocal">
          <AddPointForm
             v-if="showAddPointForm"
             :salas="salas"
             @save="handleStartPlacement"
             @cancel="showAddPointForm = false"
          />
          <button v-else-if="!isPlacementMode" @click="showAddPointForm = true" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-600 bg-slate-100 rounded-md hover:bg-slate-200">
             <PlusIcon class="h-5 w-5" />
             Agregar Punto Nuevo
          </button>
          <button v-if="isPlacementMode" @click="handleCancelPlacement" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
             <XCircleIcon class="h-5 w-5" />
             Cancelar Colocaci√≥n
          </button>
       </div>
    </div>

    <!-- Formulario m√≥vil de Agregar Punto - SOLO VISIBLE EN M√ìVIL -->
    <div v-if="canEdit && !isPlanoEditingMode && isMobileAddPointOpen" class="lg:hidden p-4 flex-shrink-0 border-b bg-blue-50">
       <AddPointForm
          :salas="salas"
          @save="handleStartPlacement"
          @cancel="emit('update:is-mobile-add-point-open', false)"
       />
    </div>

    <!-- Mensaje de modo edici√≥n en m√≥vil -->
    <div v-if="canEdit && isPlanoEditingMode" class="lg:hidden p-3 bg-orange-50 border-b border-orange-200">
       <p class="text-sm font-medium text-orange-800 text-center">Modo Edici√≥n de Plano activo</p>
    </div>

    <div class="flex-1 overflow-y-auto px-4 pb-4">
      <PointList
        :grouped-points="puntosAgrupados"
        :can-edit="canEdit"
        :all-incidencias="allIncidencias"
        @select-point="$emit('select-point', $event)"
        @update-state="(point, newState) => $emit('update-point-state', point, newState)"
        @delete-new-point="$emit('delete-new-point', $event)"
        @update-point-nomenclatura="(point, newName) => $emit('update-point-nomenclatura', point, newName)"
        :class="{ 'pointer-events-none opacity-50': isPlacementMode || isPlanoEditingMode || isPlanoEditingModeLocal }"
      >
        <template #sala-actions="{ sala }">
          <button v-if="isPlanoEditingMode || isPlanoEditingModeLocal" @click="$emit('start-area-drawing', sala)" class="p-1 text-slate-400 hover:text-blue-600" title="Definir √°rea de la sala">
            <MapIcon class="h-5 w-5" />
          </button>
        </template>
      </PointList>
    </div>
  </aside>
</template>
--- FIN DEL ARCHIVO: src/components/InspectionSidebar.vue ---

--- INICIO DEL ARCHIVO: src/components/AddPointForm.vue ---
<!-- src/components/AddPointForm.vue -->
<script setup>
import { ref } from 'vue';

defineProps({
  salas: {
    type: Array,
    required: true
  }
});

const emit = defineEmits(['save', 'cancel']);

const selectedSalaId = ref(null);

const handleSave = () => {
  if (!selectedSalaId.value) {
    alert("Por favor, selecciona una sala.");
    return;
  }
  emit('save', selectedSalaId.value);
};
</script>

<template>
  <div class="p-2 bg-slate-50 rounded-lg">
    <h4 class="font-bold text-sm mb-2">A√±adir Nuevo Punto</h4>
    <select v-model="selectedSalaId" class="block w-full rounded-md border-slate-300 shadow-sm text-sm mb-2">
      <option :value="null" disabled>Selecciona una sala...</option>
      <option v-for="sala in salas" :key="sala.id" :value="sala.id">{{ sala.nombre }}</option>
    </select>
    <div class="flex gap-2">
      <button @click="$emit('cancel')" class="w-full text-sm py-1 px-2 rounded bg-white border hover:bg-slate-50">Cancelar</button>
      <button @click="handleSave" class="w-full text-sm py-1 px-2 rounded bg-blue-600 text-white hover:bg-blue-700">Guardar</button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/AddPointForm.vue ---

--- INICIO DEL ARCHIVO: src/components/ConfirmModal.vue ---
<!-- src/components/ConfirmModal.vue -->
<script setup>
import { XMarkIcon } from '@heroicons/vue/24/solid';

defineProps({
  isOpen: Boolean,
  title: String,
  message: String,
});

const emit = defineEmits(['confirm', 'cancel']);

const handleConfirm = () => {
  emit('confirm');
};

const handleCancel = () => {
  emit('cancel');
};
</script>

<template>
  <div v-if="isOpen" @click.self="handleCancel" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
      <div class="p-4 border-b flex justify-between items-center">
        <h2 class="text-lg font-bold text-slate-800">{{ title || 'Confirmar' }}</h2>
        <button @click="handleCancel" class="text-slate-400 hover:text-slate-600 text-xl">&times;</button>
      </div>
      <div class="p-4">
        <p class="text-slate-600">{{ message }}</p>
      </div>
      <div class="p-4 border-t flex justify-end gap-2">
        <button @click="handleCancel" class="px-4 py-2 font-semibold text-slate-700 bg-slate-100 rounded-md hover:bg-slate-200">Cancelar</button>
        <button @click="handleConfirm" class="px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">Confirmar</button>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/ConfirmModal.vue ---

--- INICIO DEL ARCHIVO: src/components/Login.vue ---
<!-- src/components/Login.vue -->
<script setup>
import { ref } from 'vue'
import { supabase } from '../supabase'
import { useRouter } from 'vue-router'

const router = useRouter()
const loading = ref(false)
const email = ref('')
const password = ref('')

const handleLogin = async () => {
  try {
    loading.value = true
    const { error } = await supabase.auth.signInWithPassword({
      email: email.value,
      password: password.value,
    })
    if (error) throw error
    router.push('/dashboard')
  } catch (error) {
    alert(error.error_description || error.message)
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <!-- Cambiamos los colores de fondo y texto principales -->
  <div class="flex items-center justify-center min-h-screen bg-gray-100 text-gray-800">
    <!-- El contenedor del formulario ahora es blanco con una sombra sutil -->
    <div class="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
      <h1 class="text-3xl font-bold text-center text-gray-900">Inspecci√≥n de Estanter√≠as</h1>
      <p class="text-center text-gray-600">Inicia sesi√≥n para continuar</p>
      <form @submit.prevent="handleLogin" class="space-y-6">
        <div>
          <label for="email" class="block text-sm font-medium text-gray-700">Email</label>
          <!-- Los inputs ahora tienen un fondo m√°s claro -->
          <input 
            id="email" 
            type="email" 
            v-model="email" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="email"
            required
          />
        </div>
        <div>
          <label for="password" class="block text-sm font-medium text-gray-700">Contrase√±a</label>
          <input 
            id="password" 
            type="password" 
            v-model="password" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="current-password"
            required
          />
        </div>
        <div>
          <button 
            type="submit" 
            :disabled="loading" 
            class="w-full py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            {{ loading ? 'Cargando...' : 'Acceder' }}
          </button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/Login.vue ---

--- INICIO DEL ARCHIVO: src/components/ReloadPWA.vue ---
<!-- src/components/ReloadPWA.vue -->
<script setup>
defineProps({
  offlineReady: Boolean,
  needRefresh: Boolean,
});

const emit = defineEmits(['update-service-worker']);

const updateSW = () => {
  emit('update-service-worker');
};
</script>

<template>
  <div v-if="needRefresh" role="alert" class="fixed right-0 bottom-0 m-4 p-4 border rounded-lg shadow-lg bg-white z-[100]">
    <div class="flex items-start gap-4">
      <div class="flex-1">
        <p class="font-bold">Nueva versi√≥n disponible</p>
        <p class="text-sm">Hay una actualizaci√≥n pendiente. Por favor, recarga la p√°gina.</p>
      </div>
      <button @click="updateSW" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
        Recargar
      </button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/ReloadPWA.vue ---

--- INICIO DEL ARCHIVO: src/components/NomenclatureModal.vue ---
--- INICIO DEL ARCHIVO: src\components\NomenclatureModal.vue ---
<!-- src/components/NomenclatureModal.vue -->
<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
isOpen: Boolean,
salaNombre: String,
suggestedNumber: Number,
existingIdentifiers: { // Renombrado de existingNumbers a existingIdentifiers
type: Array,
default: () => []
}
});

const emit = defineEmits(['save', 'close']);
const pointIdentifier = ref(''); // Renombrado de pointNumber a pointIdentifier
const error = ref('');

watch(() => props.isOpen, (newVal) => {
if (newVal) {
pointIdentifier.value = props.suggestedNumber;
error.value = '';
}
});

const handleSave = () => {
error.value = '';
const identifier = String(pointIdentifier.value).trim();

if (!identifier) {
error.value = 'Por favor, introduce un identificador v√°lido.';
return;
}

// --- INICIO DE LA CORRECCI√ìN: L√≥gica de validaci√≥n flexible ---
// Comprobamos si el identificador exacto (sensible a may√∫sculas/min√∫sculas) ya existe.
if (props.existingIdentifiers.includes(identifier)) {
error.value = `El punto con el identificador "${identifier}" ya existe en esta sala.`;
return;
}
// --- FIN DE LA CORRECCI√ìN ---

emit('save', identifier); // Enviamos el identificador como string
};
</script>
<template>
<div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
<div class="bg-white rounded-lg shadow-xl w-full max-w-sm">
<div class="p-6">
<h2 class="text-lg font-bold text-slate-800">A√±adir Nuevo Punto</h2>
<p class="text-sm text-slate-500 mt-1">
Introduce el identificador para el nuevo punto en la sala <span class="font-semibold">{{ salaNombre }}</span>.
</p>
<div class="mt-4">
<label for="pointIdentifier" class="block text-sm font-medium text-slate-700">Identificador del Punto</label>
<!-- --- INICIO DE LA CORRECCI√ìN: Input de tipo texto --- -->
<input
v-model="pointIdentifier"
type="text"
id="pointIdentifier"
@keyup.enter="handleSave"
class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
>
<!-- --- FIN DE LA CORRECCI√ìN --- -->
<p v-if="error" class="mt-2 text-sm text-red-600">{{ error }}</p>
</div>
</div>
<div class="p-4 bg-slate-50 border-t flex justify-end space-x-3">
<button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
Cancelar
</button>
<button type="button" @click="handleSave" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
Guardar Punto
</button>
</div>
</div>
</div>
</template>
--- FIN DEL ARCHIVO: src/components/NomenclatureModal.vue ---

--- INICIO DEL ARCHIVO: src/components/GlobalStatusIndicator.vue ---
<!-- src/components/GlobalStatusIndicator.vue -->
<script setup>
import { syncQueue, isProcessing } from '../utils/syncQueue';
import { useOnlineStatus } from '../composables/useOnlineStatus';
import { SignalSlashIcon, CloudArrowUpIcon, WifiIcon } from '@heroicons/vue/24/solid';

defineProps({
  mode: {
    type: String,
    default: 'desktop', // 'desktop' or 'mobile'
  }
});

const { isOnline } = useOnlineStatus();
</script>

<template>
  <!-- ======================== MODO M√ìVIL (ICONO COMPACTO) ======================== -->
  <!-- INICIO DE LA CORRECCI√ìN: A√±adido un div contenedor -->
  <div v-if="mode === 'mobile'">
  <!-- FIN DE LA CORRECCI√ìN -->
    <div class="relative flex items-center justify-center w-8 h-8">
      <!-- Offline (M√°xima Prioridad) -->
      <div v-if="!isOnline" title="Est√°s sin conexi√≥n">
        <SignalSlashIcon class="h-6 w-6 text-red-500" />
      </div>
      <!-- Sincronizando -->
      <div v-else-if="isProcessing" title="Sincronizando cambios...">
        <CloudArrowUpIcon class="h-6 w-6 text-blue-500 animate-pulse" />
      </div>
      <!-- Cambios Pendientes -->
      <div v-else-if="syncQueue.length > 0" title="Cambios pendientes de sincronizar">
        <CloudArrowUpIcon class="h-6 w-6 text-amber-500" />
        <span class="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-amber-500 text-white text-[10px] font-bold">
          {{ syncQueue.length }}
        </span>
      </div>
      <!-- Online y Sincronizado -->
      <div v-else title="Conectado y sincronizado">
        <WifiIcon class="h-6 w-6 text-green-500" />
      </div>
    </div>
  </div>

  <!-- ======================== MODO ESCRITORIO (TEXTO DESCRIPTIVO) ======================== -->
  <div v-if="mode === 'desktop'">
    <!-- Indicador de Conexi√≥n -->
    <div 
      :class="['flex items-center justify-center gap-2 p-2 rounded-md text-xs font-bold mb-2', isOnline ? 'bg-green-500/20 text-green-300' : 'bg-red-500/20 text-red-300']">
      <component :is="isOnline ? WifiIcon : SignalSlashIcon" class="h-4 w-4" />
      <span>{{ isOnline ? 'Conectado' : 'Sin Conexi√≥n' }}</span>
    </div>
    <!-- Indicador de Sincronizaci√≥n (solo si hay algo que mostrar) -->
    <div v-if="syncQueue.length > 0 || isProcessing"
         class="flex items-center gap-2 p-2 rounded-md text-xs font-bold bg-blue-500/20 text-blue-300">
      <CloudArrowUpIcon class="h-4 w-4" :class="{ 'animate-pulse': isProcessing }" />
      <span v-if="isProcessing">Sincronizando...</span>
      <span v-else>{{ syncQueue.length }} cambio(s) en cola</span>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/GlobalStatusIndicator.vue ---

--- INICIO DEL ARCHIVO: src/components/MarkAsSentModal.vue ---
<!-- src/components/MarkAsSentModal.vue -->
<script setup>
import { ref, watch } from 'vue';
import { PaperAirplaneIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  inspeccionId: Number,
});

const emit = defineEmits(['close', 'save']);

const formData = ref({
  fecha_envio: '',
  responsable_envio: '',
});

// Cuando el modal se abre, pre-rellenamos la fecha con el d√≠a de hoy
watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    formData.value = {
      fecha_envio: new Date().toISOString().slice(0, 10), // Formato YYYY-MM-DD
      responsable_envio: '',
    };
  }
});

const handleSubmit = () => {
  if (!formData.value.fecha_envio || !formData.value.responsable_envio) {
    alert('Por favor, completa todos los campos.');
    return;
  }
  emit('save', formData.value);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md transform transition-all">
      <div class="p-6 border-b border-slate-200 text-center">
        <div class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
            <PaperAirplaneIcon class="h-6 w-6 text-blue-600" aria-hidden="true" />
        </div>
        <h2 class="mt-4 text-xl font-bold text-slate-800">Confirmar Env√≠o a Cliente</h2>
        <p class="text-sm text-slate-500 mt-1">Registra la fecha y el responsable del env√≠o.</p>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 space-y-4">
          <div>
            <label for="fecha_envio" class="block text-sm font-medium text-slate-600">Fecha de Env√≠o</label>
            <input 
              v-model="formData.fecha_envio" 
              type="date" 
              id="fecha_envio" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
          <div>
            <label for="responsable_envio" class="block text-sm font-medium text-slate-600">Enviado por</label>
            <input 
              v-model="formData.responsable_envio" 
              type="text" 
              id="responsable_envio" 
              placeholder="Nombre del responsable" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
        </div>
        <div class="p-4 bg-slate-50 border-t border-slate-200 flex justify-end space-x-3">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar y Marcar</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/MarkAsSentModal.vue ---

--- INICIO DEL ARCHIVO: src/components/CentroFormModal.vue ---
<!-- src/components/CentroFormModal.vue -->
<script setup>
import { ref, watch, onMounted } from 'vue';
import { supabase } from '../supabase';
import { ArrowUpTrayIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  isOpen: Boolean,
  centro: Object,
});

const emit = defineEmits(['close', 'save']);

const form = ref({});
const isUploadingLogo = ref(false);
const logoInput = ref(null);
const zonas = ref([]);
const provincias = ref([]); // <-- Ahora es reactivo
const selectedLogoFile = ref(null); // Archivo seleccionado antes de guardar
const previewLogoUrl = ref(null); // URL de preview temporal

onMounted(async () => {
  // Cargar las listas desde Supabase cuando el componente se monta
  const { data: zonasData } = await supabase.from('zonas').select('nombre').order('nombre');
  if (zonasData) zonas.value = zonasData.map(z => z.nombre);
  
  // Asumimos que tienes una tabla `provincias` similar, si no, la creamos.
  // Por ahora, lo mantenemos simple. Si no hay tabla, podemos volver a la lista local.
  // const { data: provinciasData } = await supabase.from('provincias').select('nombre').order('nombre');
  // if (provinciasData) provincias.value = provinciasData.map(p => p.nombre);
});

watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    form.value = props.centro ? { ...props.centro } : { nombre: '', direccion: '', responsable_nombre: '', responsable_email: '', provincia: '', zona: '', url_logo_cliente: null };
    // Limpiar archivo y preview al abrir el modal
    selectedLogoFile.value = null;
    if (previewLogoUrl.value) {
      URL.revokeObjectURL(previewLogoUrl.value);
      previewLogoUrl.value = null;
    }
  }
});

const handleLogoSelected = async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  // Si el centro ya existe (modo edici√≥n), subir directamente
  if (form.value.id) {
    isUploadingLogo.value = true;
    const fileName = `cliente_${form.value.id}/${Date.now()}_${file.name}`;
    const { error: uploadError } = await supabase.storage.from('logos-clientes').upload(fileName, file);
    if (uploadError) {
      alert("Error al subir el logo: " + uploadError.message);
      isUploadingLogo.value = false;
      return;
    }
    const { data: { publicUrl } } = supabase.storage.from('logos-clientes').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('centros').update({ url_logo_cliente: publicUrl }).eq('id', form.value.id);
    if (updateError) {
      alert("Error al guardar la URL del logo: " + updateError.message);
    } else {
      form.value.url_logo_cliente = publicUrl;
    }
    isUploadingLogo.value = false;
  } else {
    // Si es un centro nuevo, guardar el archivo para subirlo despu√©s
    selectedLogoFile.value = file;
    // Limpiar preview anterior si existe
    if (previewLogoUrl.value) {
      URL.revokeObjectURL(previewLogoUrl.value);
    }
    // Crear preview temporal
    previewLogoUrl.value = URL.createObjectURL(file);
  }
};

const handleSubmit = () => {
  // Incluir el archivo del logo si fue seleccionado
  const dataToSave = { ...form.value };
  if (selectedLogoFile.value) {
    dataToSave._logoFile = selectedLogoFile.value;
  }
  emit('save', dataToSave);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
      <div class="p-6 border-b">
        <h2 class="text-2xl font-bold text-slate-800">{{ centro ? 'Editar Centro' : 'Agregar Nuevo Centro' }}</h2>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
          <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="md:col-span-2">
              <label for="nombre" class="block text-sm font-medium text-slate-600">Nombre del Centro</label>
              <input v-model="form.nombre" type="text" id="nombre" required class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div class="md:col-span-2">
              <label for="direccion" class="block text-sm font-medium text-slate-600">Direcci√≥n</label>
              <input v-model="form.direccion" type="text" id="direccion" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_nombre" class="block text-sm font-medium text-slate-600">Nombre del Responsable</label>
              <input v-model="form.responsable_nombre" type="text" id="responsable_nombre" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_email" class="block text-sm font-medium text-slate-600">Email del Responsable</label>
              <input v-model="form.responsable_email" type="email" id="responsable_email" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="provincia" class="block text-sm font-medium text-slate-600">Provincia</label>
              <input v-model="form.provincia" type="text" id="provincia" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="zona" class="block text-sm font-medium text-slate-600">Zona</label>
              <select v-model="form.zona" id="zona" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <option disabled value="">Selecciona una zona</option>
                <option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
              </select>
            </div>
          </div>
          
          <div class="md:col-span-1">
             <input type="file" ref="logoInput" @change="handleLogoSelected" accept="image/*" class="hidden">
             <label class="block text-sm font-medium text-slate-600 mb-1">Logo del Cliente</label>
             <div class="aspect-video bg-slate-100 rounded-md flex items-center justify-center border-2 border-dashed">
                <img v-if="previewLogoUrl || form.url_logo_cliente" :src="previewLogoUrl || form.url_logo_cliente" class="object-contain w-full h-full p-2">
                <div v-else class="text-center text-slate-500 p-4">Sin logo</div>
             </div>
             <button
                type="button"
                @click="logoInput.click()"
                :disabled="isUploadingLogo"
                class="mt-2 w-full flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold rounded-md transition-colors
                       disabled:bg-slate-200 disabled:text-slate-500 disabled:cursor-not-allowed
                       text-slate-700 bg-white border border-slate-300 hover:bg-slate-50"
              >
               <ArrowUpTrayIcon class="h-4 w-4" />
               {{ isUploadingLogo ? 'Subiendo...' : ((previewLogoUrl || form.url_logo_cliente) ? 'Cambiar Logo' : 'Subir Logo') }}
             </button>
             <p v-if="!form.id && selectedLogoFile" class="text-xs text-green-600 mt-1 text-center">Logo seleccionado. Se subir√° al guardar.</p>
          </div>
        </div>
        <div class="p-6 bg-slate-50 border-t flex justify-end space-x-4">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar Cambios</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/CentroFormModal.vue ---

--- INICIO DEL ARCHIVO: src/components/GrupoVisitaEditable.vue ---
<!-- src/components/GrupoVisitaEditable.vue -->
<script setup>
import { ref, nextTick } from 'vue';
import { PencilIcon, CheckIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  value: [String, Number],
  inspeccionId: Number
});

const emit = defineEmits(['save']);

const isEditing = ref(false);
const localValue = ref(props.value);
const inputRef = ref(null);

const startEditing = () => {
  if (!props.inspeccionId) return; // No se puede editar si no hay inspecci√≥n
  localValue.value = props.value;
  isEditing.value = true;
  nextTick(() => {
    inputRef.value?.focus();
  });
};

const saveEdit = () => {
  if (localValue.value !== props.value) {
    emit('save', {
      inspeccionId: props.inspeccionId,
      newValue: localValue.value
    });
  }
  isEditing.value = false;
};
</script>

<template>
  <div class="flex items-center justify-center group">
    <div v-if="!isEditing" @click="startEditing" class="cursor-pointer min-h-[2rem] flex items-center justify-center px-2">
      <span v-if="value">{{ value }}</span>
      <span v-else class="text-slate-400 italic text-xs">N/A</span>
      <PencilIcon v-if="inspeccionId" class="h-3 w-3 ml-2 text-slate-400 opacity-0 group-hover:opacity-100 transition-opacity" />
    </div>
    <div v-else class="flex items-center gap-1">
      <input
        ref="inputRef"
        v-model="localValue"
        type="text"
        @keyup.enter="saveEdit"
        @keyup.esc="isEditing = false"
        @blur="saveEdit"
        class="w-20 text-center text-sm p-1 border-blue-400 ring-1 ring-blue-400 rounded-md"
      />
      <button @click="saveEdit" class="p-1 text-green-600 hover:bg-green-100 rounded">
        <CheckIcon class="h-4 w-4" />
      </button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/GrupoVisitaEditable.vue ---

--- INICIO DEL ARCHIVO: src/components/SkeletonLoader.vue ---
<!-- src/components/SkeletonLoader.vue -->
<template>
  <div class="w-full h-full bg-slate-200 rounded-md animate-pulse"></div>
</template>
--- FIN DEL ARCHIVO: src/components/SkeletonLoader.vue ---

--- INICIO DEL ARCHIVO: src/components/PlanoBadge.vue ---
<!-- src/components/PlanoBadge.vue -->
<template>
  <div
    class="w-full h-full p-1 flex flex-col items-center rounded-lg shadow-lg cursor-move font-sans"
  >
    <!-- Cabecera con Punto y Estado -->
    <div class="text-center">
      <div class="font-bold text-sm text-gray-800 leading-tight">{{ pointNumber }}</div>
      <div v-if="stateText" class="font-bold text-[10px] leading-tight text-blue-600 uppercase break-words">
        {{ stateText }}
      </div>
    </div>
    
    <hr class="w-11/12 my-1 border-t border-gray-200">
    
    <!-- Contenedor del sem√°foro -->
    <div class="flex-1 w-full flex justify-center items-center">
      <!-- Fila de c√≠rculos con espaciado expl√≠cito -->
      <div class="flex items-center">
        <!-- ===== INICIO DE LA SOLUCI√ìN FINAL ===== -->
        <div 
          v-for="(item, index) in semaphoreItems" 
          :key="item.label"
          :class="['w-5 h-5 rounded-full flex-shrink-0 flex items-center justify-center', { 'mx-1': index === 1 }]"
          :style="{ backgroundColor: item.color }"
          :title="`${item.count} incidencias de tipo ${item.label}`"
        >
          <span class="text-white font-bold text-[10px] leading-none">
            {{ item.count }}
          </span>
        </div>
        <!-- ===== FIN DE LA SOLUCI√ìN FINAL ===== -->
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, watch } from 'vue';

const props = defineProps({
  pointData: Object
});

const pointNumber = computed(() => props.pointData.nomenclatura.split('-').pop() || '?');

const stateText = computed(() => {
  if (props.pointData.estado === 'nuevo') return 'NUEVA';
  if (props.pointData.estado === 'suprimido') return 'SUPRIMIDA';
  if (props.pointData.detalle_modificacion === 'aumentado') return 'AUMENTADA';
  if (props.pointData.detalle_modificacion === 'disminuido') return 'DISMINUIDA';
  return null;
});

const semaphoreItems = computed(() => {
  const counts = props.pointData?.counts || { verde: 0, ambar: 0, rojo: 0 };
  console.log('PlanoBadge semaphore data for point', props.pointData?.nomenclatura, ':', counts);
  return [
    { label: 'verde', color: '#22C55E', count: counts.verde || 0 },
    { label: 'ambar', color: '#F59E0B', count: counts.ambar || 0 },
    { label: 'rojo', color: '#EF4444', count: counts.rojo || 0 },
  ];
});

// Watch for changes in pointData to debug reactivity
watch(() => props.pointData, (newData, oldData) => {
  console.log('PlanoBadge pointData changed:', {
    point: newData?.nomenclatura,
    oldCounts: oldData?.counts,
    newCounts: newData?.counts
  });
}, { deep: true, immediate: true });
</script>
--- FIN DEL ARCHIVO: src/components/PlanoBadge.vue ---

--- INICIO DEL ARCHIVO: src/components/Notification.vue ---
<!-- src/components/Notification.vue -->
<script setup>
import { CheckCircleIcon, XCircleIcon, ExclamationTriangleIcon, InformationCircleIcon } from '@heroicons/vue/24/solid';

defineProps({
  show: Boolean,
  message: String,
  type: {
    type: String,
    default: 'success', // 'success', 'error', 'warning', 'info'
  },
});
</script>

<template>
  <div
    aria-live="assertive"
    class="pointer-events-none fixed inset-0 flex items-end px-4 py-6 sm:items-start sm:p-6 z-[100]"
  >
    <div class="flex w-full flex-col items-center space-y-4 sm:items-end">
      <transition
        enter-active-class="transform ease-out duration-300 transition"
        enter-from-class="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
        enter-to-class="translate-y-0 opacity-100 sm:translate-x-0"
        leave-active-class="transition ease-in duration-100"
        leave-from-class="opacity-100"
        leave-to-class="opacity-0"
      >
        <div
          v-if="show"
          class="pointer-events-auto w-full max-w-sm overflow-hidden rounded-lg bg-white shadow-lg ring-1 ring-black ring-opacity-5"
        >
          <div class="p-4">
            <div class="flex items-start">
              <div class="flex-shrink-0">
                <CheckCircleIcon v-if="type === 'success'" class="h-6 w-6 text-green-400" aria-hidden="true" />
                <XCircleIcon v-if="type === 'error'" class="h-6 w-6 text-red-400" aria-hidden="true" />
                <ExclamationTriangleIcon v-if="type === 'warning'" class="h-6 w-6 text-yellow-400" aria-hidden="true" />
                <InformationCircleIcon v-if="type === 'info'" class="h-6 w-6 text-blue-400" aria-hidden="true" />
              </div>
              <div class="ml-3 w-0 flex-1 pt-0.5">
                <p class="text-sm font-medium text-gray-900">
                  {{ type === 'success' ? '√âxito' : type === 'error' ? 'Error' : type === 'warning' ? 'Advertencia' : 'Informaci√≥n' }}
                </p>
                <p class="mt-1 text-sm text-gray-500">
                  {{ message }}
                </p>
              </div>
            </div>
          </div>
        </div>
      </transition>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/Notification.vue ---

--- INICIO DEL ARCHIVO: src/components/InspectionListItem.vue ---
<!-- src/components/InspectionListItem.vue -->
<script setup>
import { ref, computed } from 'vue';
import { supabase } from '../supabase';
import {
EyeIcon,
TrashIcon,
PaperAirplaneIcon,
ArchiveBoxIcon,
MapIcon,
ArrowDownCircleIcon,
ArrowUturnLeftIcon,
UserIcon,
ChevronDownIcon
} from '@heroicons/vue/24/outline';
import { useRouter } from 'vue-router';

const props = defineProps({
inspeccion: {
type: Object,
required: true
},
isProcessing: Boolean,
});

const emit = defineEmits(['mark-as-sent', 'reopen', 'delete', 'date-updated']);

const router = useRouter();
const isExpanded = ref(false);
const isEditingDate = ref(false);
const newDate = ref(props.inspeccion.fecha_inspeccion);

const estadoInfo = computed(() => {
const estado = props.inspeccion.estado;
switch (estado) {
case 'en_progreso': return { text: 'En Progreso', class: 'bg-blue-100 text-blue-800' };
case 'finalizada': return { text: 'Pendiente de Env√≠o', class: 'bg-orange-100 text-orange-800' };
case 'pendiente_subsanacion': return { text: 'Pendiente de Cierre', class: 'bg-yellow-100 text-yellow-800' };
case 'cerrada': return { text: 'Cerrada', class: 'bg-green-100 text-green-800' };
default: return { text: estado, class: 'bg-slate-100 text-slate-800' };
}
});

const toggleDetails = () => {
isExpanded.value = !isExpanded.value;
if (isExpanded.value) {
// La carga de detalles se dispara desde el padre
}
};

// --- INICIO DE LA SOLUCI√ìN PROFESIONAL: Cache Busting ---
// Esta funci√≥n ahora se encarga de a√±adir un par√°metro √∫nico a la URL
// para forzar al navegador y al Service Worker a descargar la versi√≥n m√°s reciente del archivo.
const openArchivedPdf = (url) => {
  if (!url) {
    console.warn('El informe PDF para esta inspecci√≥n a√∫n no ha sido generado o archivado.');
    return;
  }
  
  try {
    // 1. Creamos un objeto URL para manipularla f√°cilmente.
    const urlObject = new URL(url);
    
    // 2. A√±adimos un par√°metro de b√∫squeda 't' con el timestamp actual.
    // Esto hace que la URL sea √∫nica en cada clic, "rompiendo" la cach√©.
    urlObject.searchParams.set('t', Date.now());
    
    // 3. Abrimos la nueva URL cache-busted en una nueva pesta√±a.
    window.open(urlObject.toString(), '_blank');

  } catch (error) {
    console.error("URL del PDF inv√°lida, abriendo directamente:", error);
    // Como fallback, si la URL es inv√°lida, intentamos abrirla tal cual.
    window.open(url, '_blank');
  }
};
// --- FIN DE LA SOLUCI√ìN PROFESIONAL ---

const startEditingDate = () => {
newDate.value = props.inspeccion.fecha_inspeccion;
isEditingDate.value = true;
};

const saveDate = async () => {
if (newDate.value === props.inspeccion.fecha_inspeccion) {
isEditingDate.value = false;
return;
}

const { error } = await supabase
.from('inspecciones')
.update({ fecha_inspeccion: newDate.value })
.eq('id', props.inspeccion.id);

if (error) {
alert('Error al actualizar la fecha: ' + error.message);
} else {
emit('date-updated', { id: props.inspeccion.id, newDate: newDate.value });
}
isEditingDate.value = false;
};
</script>
<template>
<div class="bg-white rounded-xl shadow-sm border border-slate-200 transition-all">
<div class="p-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 items-center">
  <div class="space-y-2 group cursor-pointer" @click="startEditingDate">
    <div>
      <p class="text-xs font-semibold text-slate-500">Fecha Inspecci√≥n</p>
      <div v-if="!isEditingDate" class="font-semibold text-slate-800">
        {{ new Date(inspeccion.fecha_inspeccion + 'T00:00:00').toLocaleDateString() }}
      </div>
      <input 
        v-else
        type="date"
        v-model="newDate"
        @blur="saveDate"
        @keyup.enter="saveDate"
        @click.stop
        class="p-1 rounded-md border-slate-300 shadow-sm text-sm"
      />
    </div>
    <div class="flex items-center gap-2">
      <UserIcon class="h-4 w-4 text-slate-400" />
      <span class="text-sm text-slate-600">{{ inspeccion.tecnico_nombre }}</span>
    </div>
  </div>
  
  <div class="space-y-2">
     <div>
       <p class="text-xs font-semibold text-slate-500">Estado</p>
       <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium capitalize" :class="estadoInfo.class">
          {{ estadoInfo.text }}
       </span>
     </div>
     <div class="flex items-center gap-x-3" title="Incidencias: Leves / Moderadas / Graves">
        <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-green-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.totalCounts.verde }}</span></div>
        <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-amber-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.totalCounts.ambar }}</span></div>
        <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-red-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.totalCounts.rojo }}</span></div>
    </div>
  </div>

  <div class="lg:col-span-2 flex justify-start lg:justify-end items-center flex-wrap gap-2">
    <button v-if="inspeccion.estado === 'finalizada'" @click="$emit('mark-as-sent', inspeccion)" :disabled="isProcessing" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-blue-700 bg-blue-50 hover:bg-blue-100 border border-blue-200 disabled:opacity-50">
      <PaperAirplaneIcon class="h-4 w-4" /> Marcar Env√≠o
    </button>
    
    <router-link v-if="inspeccion.estado === 'pendiente_subsanacion'" :to="`/inspecciones/${inspeccion.id}/cierre`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-purple-700 bg-purple-50 hover:bg-purple-100 border border-purple-200">
      <ArchiveBoxIcon class="h-4 w-4" /> Cierre
    </router-link>
    
    <router-link :to="`/inspecciones/${inspeccion.id}/plano-preview`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-teal-700 bg-teal-50 hover:bg-teal-100 border border-teal-200">
        <MapIcon class="h-4 w-4"/>Plano
    </router-link>

    <button @click="openArchivedPdf(inspeccion.url_pdf_informe_inicial)" :disabled="!inspeccion.url_pdf_informe_inicial" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-slate-600 bg-slate-100 hover:bg-slate-200 border border-slate-200 disabled:opacity-50 disabled:cursor-not-allowed">
      <ArrowDownCircleIcon class="h-4 w-4" /> Inf. Inicial
    </button>

    <button v-if="inspeccion.estado === 'cerrada'" @click="openArchivedPdf(inspeccion.url_pdf_informe_final)" :disabled="!inspeccion.url_pdf_informe_final" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-green-700 bg-green-100 hover:bg-green-200 border border-green-200 disabled:opacity-50 disabled:cursor-not-allowed">
      <ArrowDownCircleIcon class="h-4 w-4" /> Inf. Cierre
    </button>

    <div class="flex items-center gap-1 border-l pl-2 ml-1">
      <router-link :to="`/inspecciones/${inspeccion.id}`" class="p-2 text-slate-500 hover:text-blue-600" title="Ver/Editar Inspecci√≥n"><EyeIcon class="h-5 w-5" /></router-link>
      <button v-if="inspeccion.estado !== 'en_progreso'" @click="$emit('reopen', inspeccion)" :disabled="isProcessing" class="p-2 text-slate-500 hover:text-orange-600 disabled:opacity-50" title="Reabrir Inspecci√≥n">
          <ArrowUturnLeftIcon class="h-5 w-5" />
      </button>
      <button @click="$emit('delete', inspeccion.id)" class="p-2 text-slate-500 hover:text-red-600" title="Borrar Inspecci√≥n"><TrashIcon class="h-5 w-5" /></button>
    </div>
  </div>
</div>

<div class="px-4 pb-2 text-center">
  <button @click="toggleDetails" class="w-full text-xs font-semibold text-slate-500 hover:text-blue-600 flex items-center justify-center gap-1 py-1 border-t border-slate-200">
    <span>{{ isExpanded ? 'Ocultar Detalles' : 'Mostrar Detalles' }}</span>
    <ChevronDownIcon class="h-4 w-4 transition-transform" :class="{'rotate-180': isExpanded}" />
  </button>
</div>

<div v-if="isExpanded" class="border-t border-slate-200 p-4 bg-slate-50/50">
  <div class="space-y-3">
    <div v-if="inspeccion.details.length === 0" class="text-center text-sm text-slate-500 py-4">
        No hay puntos con incidencias en esta inspecci√≥n.
    </div>
    <div v-for="sala in inspeccion.details" :key="sala.id" class="bg-white p-3 rounded-md border">
      <div class="flex justify-between items-center mb-2">
        <h4 class="font-bold text-slate-800">{{ sala.nombre }}</h4>
        <div class="flex items-center gap-x-3" title="Incidencias: Leves / Moderadas / Graves">
          <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-green-500"></span><span class="font-bold text-sm text-slate-700">{{ sala.counts.verde }}</span></div>
          <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-amber-500"></span><span class="font-bold text-sm text-slate-700">{{ sala.counts.ambar }}</span></div>
          <div class="flex items-center gap-1.5"><span class="h-2.5 w-2.5 rounded-full bg-red-500"></span><span class="font-bold text-sm text-slate-700">{{ sala.counts.rojo }}</span></div>
        </div>
      </div>
      <ul class="divide-y divide-slate-100">
        <li v-for="punto in sala.puntos" :key="punto.id" class="py-1.5 flex justify-between items-center text-sm">
          <span class="text-slate-600">{{ punto.nomenclatura }}</span>
           <div class="flex items-center gap-x-3">
            <div class="flex items-center gap-1.5 w-8 justify-end"><span class="h-2 w-2 rounded-full bg-green-500"></span><span class="font-medium text-xs text-slate-700">{{ punto.counts.verde }}</span></div>
            <div class="flex items-center gap-1.5 w-8 justify-end"><span class="h-2 w-2 rounded-full bg-amber-500"></span><span class="font-medium text-xs text-slate-700">{{ punto.counts.ambar }}</span></div>
            <div class="flex items-center gap-1.5 w-8 justify-end"><span class="h-2 w-2 rounded-full bg-red-500"></span><span class="font-medium text-xs text-slate-700">{{ punto.counts.rojo }}</span></div>
          </div>
        </li>
      </ul>
    </div>
  </div>
</div>
</div>
</template>
--- FIN DEL ARCHIVO: src/components/InspectionListItem.vue ---

--- INICIO DEL ARCHIVO: src/components/InteractiveMap.vue ---
<!-- src/components/InteractiveMap.vue -->
<script setup>
import { ref, watch, onMounted, onUnmounted, nextTick } from 'vue';

const props = defineProps({
  imageUrl: { type: String, required: true },
  points: { type: Array, default: () => [] },
  salas: { type: Array, default: () => [] },
  isReadOnly: { type: Boolean, default: false },
  isPlacementMode: { type: Boolean, default: false },
  isAreaDrawingMode: { type: Boolean, default: false },
  allIncidencias: { type: Array, default: () => [] }
});

const emit = defineEmits(['add-point', 'delete-point', 'update-point-position', 'point-click', 'area-drawn', 'drawing-cancelled', 'image-error']);

const overlayRef = ref(null);
const draggedPointId = ref(null);
const drawingPoints = ref([]);
const mousePosition = ref({ x: 0, y: 0 });
const imageRect = ref({ left: 0, top: 0, width: 0, height: 0 });
const resizeObserver = ref(null);

// ===== INICIO DE LA CORRECCI√ìN: L√≥gica de carga de imagen robusta =====
const imageLoaded = ref(false);

const updateDimensions = () => {
  if (!overlayRef.value || !imageLoaded.value) {
    return;
  }
  const containerEl = overlayRef.value;
  // Buscamos la imagen por su clase dentro del componente
  const imgEl = containerEl.querySelector('img.plano-image');

  if (!imgEl || !imgEl.naturalWidth) return;

  const containerRatio = containerEl.clientWidth / containerEl.clientHeight;
  const imageRatio = imgEl.naturalWidth / imgEl.naturalHeight;
  let imgW, imgH, imgX, imgY;

  if (imageRatio > containerRatio) {
    imgW = containerEl.clientWidth;
    imgH = imgW / imageRatio;
    imgX = 0;
    imgY = (containerEl.clientHeight - imgH) / 2;
  } else {
    imgH = containerEl.clientHeight;
    imgW = imgH * imageRatio;
    imgY = 0;
    imgX = (containerEl.clientWidth - imgW) / 2;
  }

  imageRect.value = {
    left: imgX,
    top: imgY,
    width: imgW,
    height: imgH
  };
  console.log('Image dimensions updated:', imageRect.value);
};

// Esta funci√≥n se llamar√° cuando la imagen termine de cargar
const onImageLoad = () => {
  imageLoaded.value = true;
  // Usamos nextTick para asegurar que el DOM est√° actualizado antes de medir
  nextTick(() => {
    updateDimensions();
  });
};

const handleImageError = () => {
  console.error('Error loading image from Supabase:', props.imageUrl);
  emit('image-error');
};

// Si la URL de la imagen cambia, reseteamos el estado de carga
watch(() => props.imageUrl, () => {
  imageLoaded.value = false;
});
// ===== FIN DE LA CORRECCI√ìN =====


const toSvgPoints = (pointsArray) => {
  if (!pointsArray || pointsArray.length === 0 || !imageRect.value.width || !imageRect.value.height) return "";
  return pointsArray.map(p => `${p.x * imageRect.value.width + imageRect.value.left},${p.y * imageRect.value.height + imageRect.value.top}`).join(' ');
};

const handleMapClick = (event) => {
  if (props.isReadOnly || !overlayRef.value || !imageRect.value.width || !imageRect.value.height) {
    return;
  }

  const overlayRect = overlayRef.value.getBoundingClientRect();
  const x = (event.clientX - overlayRect.left - imageRect.value.left) / imageRect.value.width;
  const y = (event.clientY - overlayRect.top - imageRect.value.top) / imageRect.value.height;

  if (props.isAreaDrawingMode) {
    if (drawingPoints.value.length > 2) {
      const firstPoint = drawingPoints.value[0];
      const distance = Math.sqrt(Math.pow((x - firstPoint.x), 2) + Math.pow((y - firstPoint.y), 2));
      if (distance < 0.02) {
        emit('area-drawn', drawingPoints.value);
        drawingPoints.value = [];
        return;
      }
    }
    drawingPoints.value.push({ x, y });
  } else if (props.isPlacementMode) {
    emit('add-point', { x, y });
  }
};

const handleMouseMove = (event) => {
    if (!props.isAreaDrawingMode || !overlayRef.value) return;
    const overlayRect = overlayRef.value.getBoundingClientRect();
    mousePosition.value.x = event.clientX - overlayRect.left;
    mousePosition.value.y = event.clientY - overlayRect.top;
};

const handleKeydown = (e) => {
    if (e.key === 'Escape' && props.isAreaDrawingMode) {
        drawingPoints.value = [];
        emit('drawing-cancelled');
    }
};

onMounted(() => {
  window.addEventListener('keydown', handleKeydown);
  if (overlayRef.value) {
    resizeObserver.value = new ResizeObserver(() => {
      updateDimensions();
    });
    resizeObserver.value.observe(overlayRef.value);
  }
});
onUnmounted(() => {
  window.removeEventListener('keydown', handleKeydown);
  if (resizeObserver.value && overlayRef.value) {
    resizeObserver.value.unobserve(overlayRef.value);
  }
});

const getSalaColor = (salaId) => {
  const sala = props.salas.find(s => s.id === salaId);
  return sala ? sala.color : '#9CA3AF';
};

const startDrag = (point, event) => {
  if (props.isReadOnly) return;
  event.preventDefault();
  draggedPointId.value = point.id;
};

const onDrag = (event) => {
  if (props.isReadOnly || draggedPointId.value === null || !overlayRef.value || !imageRect.value.width || !imageRect.value.height) return;
  event.preventDefault();
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (!point) return;
  const overlayRect = overlayRef.value.getBoundingClientRect();
  point.coordenada_x = (event.clientX - overlayRect.left - imageRect.value.left) / imageRect.value.width;
  point.coordenada_y = (event.clientY - overlayRect.top - imageRect.value.top) / imageRect.value.height;
};

const stopDrag = () => {
  if (draggedPointId.value === null) return;
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (point) {
    emit('update-point-position', point);
  }
  draggedPointId.value = null;
};

const handleDeleteClick = (point) => {
  emit('delete-point', point);
};

const handlePointClick = (point) => {
  if (props.isPlacementMode || props.isAreaDrawingMode) return;
  emit('point-click', point);
};

// Get incident badge data for a point (highest severity and count)
function getPointIncidentBadge(puntoId) {
  const incidents = props.allIncidencias.filter(inc => inc.punto_inspeccionado_id === puntoId);
  if (incidents.length === 0) return null;

  const hasRojo = incidents.some(inc => inc.gravedad === 'rojo');
  const hasAmbar = incidents.some(inc => inc.gravedad === 'ambar');

  return {
    count: incidents.length,
    color: hasRojo ? '#EF4444' : hasAmbar ? '#F59E0B' : '#22C55E',
    severity: hasRojo ? 'rojo' : hasAmbar ? 'ambar' : 'verde',
    shouldPulse: hasRojo // Pulse effect for critical incidents
  };
}
</script>

<template>
  <div
    class="relative w-full h-full"
    @mousemove="onDrag"
    @mouseup="stopDrag"
    @mouseleave="stopDrag"
  >
    <!-- ===== CORRECCI√ìN: El overlay ahora contiene la imagen para controlar su carga ===== -->
    <div
      ref="overlayRef"
      class="absolute inset-0"
      :class="{ 'cursor-crosshair': isPlacementMode || isAreaDrawingMode }"
      style="z-index: 20;"
      @click="handleMapClick"
      @mousemove="handleMouseMove"
    >
      <img 
        :src="imageUrl" 
        @load="onImageLoad" 
        @error="handleImageError" 
        class="plano-image w-full h-full object-contain pointer-events-none" 
        alt="Plano del centro"
      >
      
      <!-- Mostramos el contenido SVG y los puntos solo cuando la imagen se ha cargado -->
      <template v-if="imageLoaded">
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none">
          <template v-for="sala in salas" :key="`sala-area-${sala.id}`">
            <polygon
              v-if="sala.area_puntos"
              :points="toSvgPoints(sala.area_puntos)"
              :style="{ fill: `${getSalaColor(sala.id)}33`, stroke: getSalaColor(sala.id), strokeWidth: '2px' }"
            />
          </template>

          <g v-if="isAreaDrawingMode && overlayRef">
            <polyline
              :points="toSvgPoints(drawingPoints)"
              style="fill: none; stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <line
              v-if="drawingPoints.length > 0"
              :x1="drawingPoints[drawingPoints.length - 1].x * imageRect.width + imageRect.left"
              :y1="drawingPoints[drawingPoints.length - 1].y * imageRect.height + imageRect.top"
              :x2="mousePosition.x"
              :y2="mousePosition.y"
              style="stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <circle
              v-for="(point, index) in drawingPoints"
              :key="`drawing-point-${index}`"
              :cx="point.x * imageRect.width + imageRect.left"
              :cy="point.y * imageRect.height + imageRect.top"
              r="5"
              :class="index === 0 ? 'fill-green-500 stroke-white' : 'fill-blue-500 stroke-white'"
              style="stroke-width: 2px;"
            />
          </g>
        </svg>

        <div
           v-for="point in points"
           :key="point.id"
           class="absolute w-8 h-8 -translate-x-1/2 -translate-y-1/2 border-2 border-white rounded-full flex items-center justify-center text-white text-xs font-bold group shadow-lg pointer-events-auto"
           :class="{
             'cursor-grab active:cursor-grabbing': !isReadOnly,
             'cursor-pointer hover:scale-110 transition-transform': isReadOnly
           }"
           :style="{
             left: (point.coordenada_x * imageRect.width + imageRect.left) + 'px',
             top: (point.coordenada_y * imageRect.height + imageRect.top) + 'px',
             backgroundColor: point.color || getSalaColor(point.sala_id)
           }"
           @mousedown.stop="startDrag(point, $event)"
           @click.stop="handlePointClick(point)"
         >
          {{ point.nomenclatura.split('-').pop() || '?' }}

          <!-- Incident count badge -->
          <div
            v-if="getPointIncidentBadge(point.id)"
            class="absolute -top-1 -right-1 w-4 h-4 rounded-full flex items-center justify-center text-[9px] font-bold text-white shadow-lg"
            :class="{ 'animate-pulse': getPointIncidentBadge(point.id).shouldPulse }"
            :style="{ backgroundColor: getPointIncidentBadge(point.id).color }"
          >
            {{ getPointIncidentBadge(point.id).count }}
          </div>

          <button
            v-if="!isReadOnly && (point.estado === 'nuevo' || point.estado === undefined)"
            @click.stop="handleDeleteClick(point)"
            class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 text-white rounded-full text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
            title="Borrar punto"
          >X</button>
        </div>
      </template>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/InteractiveMap.vue ---

--- INICIO DEL ARCHIVO: src/assets/vue.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
--- FIN DEL ARCHIVO: src/assets/vue.svg ---

--- INICIO DEL ARCHIVO: src/views/CentrosListView.vue ---
<!-- src/views/CentrosListView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import {
PlusIcon,
PencilIcon,
ArchiveBoxIcon,
DocumentDuplicateIcon,
MagnifyingGlassIcon,
CalendarDaysIcon,
DocumentChartBarIcon
} from '@heroicons/vue/24/solid';
import CentroFormModal from '../components/CentroFormModal.vue';
import SkeletonLoader from '../components/SkeletonLoader.vue';

const centros = ref([]);
const loading = ref(true);
const isModalOpen = ref(false);
const selectedCentro = ref(null);
const filterZona = ref('');
const searchTerm = ref('');
const zonas = ref([]); // <-- Ahora es reactivo

const getZonaColor = (zona) => {
const colors = {
'Norte': 'bg-sky-100 text-sky-800', 'Levante Norte': 'bg-sky-100 text-sky-800', 'Noroeste': 'bg-sky-100 text-sky-800',
'Sur': 'bg-amber-100 text-amber-800', 'Levante Sur': 'bg-amber-100 text-amber-800', 'Suroeste': 'bg-amber-100 text-amber-800',
'Sureste': 'bg-orange-100 text-orange-800',
'Extremadura-Cord': 'bg-rose-100 text-rose-800',
'Madrid Oeste': 'bg-indigo-100 text-indigo-800', 'Madrid Este y Arag√≥n': 'bg-indigo-100 text-indigo-800',
'Centro': 'bg-slate-100 text-slate-800',
'Catalu√±a Norte': 'bg-teal-100 text-teal-800', 'Catalu√±a Sur': 'bg-teal-100 text-teal-800',
'Castilla Le√≥n': 'bg-lime-100 text-lime-800',
'Baleares-Canarias': 'bg-cyan-100 text-cyan-800',
};
return colors[zona] || 'bg-gray-100 text-gray-800';
};

const filteredCentros = computed(() => {
let results = centros.value;
if (filterZona.value) {
results = results.filter(c => c.zona === filterZona.value);
}
if (searchTerm.value.trim()) {
const searchLower = searchTerm.value.toLowerCase();
results = results.filter(c => c.nombre.toLowerCase().includes(searchLower));
}
return results;
});

const openCreateModal = () => {
selectedCentro.value = null;
isModalOpen.value = true;
};

const openEditModal = (centro) => {
selectedCentro.value = centro;
isModalOpen.value = true;
};

// ===== CAMBIO REALIZADO: L√≥gica de guardado simplificada y corregida =====
const handleSaveCentro = async (centroData) => {
// Copiamos los datos para no modificar el objeto original
const dataToSave = { ...centroData };

// --- INICIO DE LA CORRECCI√ìN ---
// Estas propiedades son calculadas en el cliente y no existen en la tabla 'centros'.
// Debemos eliminarlas antes de intentar guardar los datos en Supabase para evitar el error.
delete dataToSave.numero_informes;
delete dataToSave.ultima_revision;

// Extraer el archivo del logo si existe (propiedad especial)
const logoFile = dataToSave._logoFile;
delete dataToSave._logoFile;
// --- FIN DE LA CORRECCI√ìN ---

let error;
let centroId = dataToSave.id;

if (dataToSave.id) {
// --- L√ìGICA DE ACTUALIZACI√ìN ---
const { id, ...updateData } = dataToSave; // Separamos el id del resto de los datos
const { error: updateError } = await supabase
.from('centros')
.update(updateData)
.eq('id', id);
error = updateError;
} else {
// --- L√ìGICA DE CREACI√ìN ---
delete dataToSave.id; // Nos aseguramos de que no haya un id (aunque sea null)
const { data: insertData, error: insertError } = await supabase
.from('centros')
.insert(dataToSave)
.select()
.single();
error = insertError;

if (!error && insertData) {
centroId = insertData.id;

// Si hay un logo seleccionado, subirlo ahora que tenemos el ID
if (logoFile) {
const fileName = `cliente_${centroId}/${Date.now()}_${logoFile.name}`;
const { error: uploadError } = await supabase.storage
.from('logos-clientes')
.upload(fileName, logoFile);

if (!uploadError) {
const { data: { publicUrl } } = supabase.storage
.from('logos-clientes')
.getPublicUrl(fileName);

// Actualizar el centro con la URL del logo
await supabase.from('centros')
.update({ url_logo_cliente: publicUrl })
.eq('id', centroId);
}
}
}
}

if (error) {
alert(error.message);
} else {
isModalOpen.value = false;
await fetchCentros(); // Recargamos la lista para ver los cambios
}
};

const fetchCentros = async () => {
loading.value = true;
const { data, error } = await supabase
.from('centros')
.select('*, url_logo_cliente')
.order('nombre');

if (error) {
centros.value = [];
} else if(data) {
const centrosConInspecciones = await Promise.all(data.map(async (centro) => {
const { data: inspecciones, error: inspError } = await supabase
.from('inspecciones')
.select('fecha_inspeccion')
.eq('centro_id', centro.id);

let numero_informes = 0;
let ultima_revision = null;

if (!inspError && inspecciones && inspecciones.length > 0) {
numero_informes = inspecciones.length;
const fechas = inspecciones.map(i => new Date(i.fecha_inspeccion)).sort((a, b) => b - a);
ultima_revision = fechas[0].toLocaleDateString('es-ES');
}

return {
...centro,
numero_informes,
ultima_revision,
};
}));
centros.value = centrosConInspecciones;
}

const { data: zonasData } = await supabase.from('zonas').select('nombre').order('nombre');
if (zonasData) zonas.value = zonasData.map(z => z.nombre);

loading.value = false;
};

onMounted(fetchCentros);
</script>
<template>
<div class="p-4 md:p-8">
<div class="flex flex-col md:flex-row justify-between md:items-center mb-6 gap-4">
<h1 class="text-3xl md:text-4xl font-bold text-slate-800">Maestro de Centros</h1>
<div class="flex items-center gap-x-2 w-full md:w-auto">
<div class="relative flex-grow">
<div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
<MagnifyingGlassIcon class="h-5 w-5 text-slate-400" />
</div>
<input
v-model="searchTerm"
type="search"
placeholder="Buscar..."
class="block w-full rounded-md border-slate-300 py-2 pl-10 text-sm shadow-sm focus:border-blue-500 focus:ring-blue-500"
>
</div>
<select v-model="filterZona" class="rounded-md border-slate-300 shadow-sm text-sm py-2">
<option value="">Todas las Zonas</option>
<option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
</select>
<button @click="openCreateModal" class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm flex-shrink-0">
<PlusIcon class="h-5 w-5" />
<span class="hidden sm:inline">Agregar Centro</span>
</button>
</div>
</div>
<div v-if="loading" class="space-y-4">
  <div v-for="i in 5" :key="i" class="bg-white rounded-xl shadow-sm border border-slate-200 p-4 h-24">
    <SkeletonLoader />
  </div>
</div>

<div v-else class="space-y-4">
  <div v-if="filteredCentros.length === 0" class="p-8 text-center text-slate-500 bg-white rounded-xl shadow-sm border">
    No se han encontrado centros que coincidan con los filtros.
  </div>
  
  <div v-for="centro in filteredCentros" :key="centro.id" class="bg-white rounded-xl shadow-sm border border-slate-200 p-4 transition-all hover:border-blue-400 hover:shadow-md">
    <div class="grid grid-cols-6 md:grid-cols-12 gap-y-4 md:gap-x-6 items-center">
      <div class="col-span-6 md:col-span-4 flex items-center gap-4">
        <div class="flex-shrink-0 w-12 h-12 bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden border">
          <img v-if="centro.url_logo_cliente" :src="centro.url_logo_cliente" class="object-contain h-full w-full" loading="lazy">
          <span v-else class="text-slate-400 text-xs font-semibold">Logo</span>
        </div>
        <div>
          <p class="text-lg font-bold text-slate-900">{{ centro.nombre }}</p>
          <p class="text-sm text-slate-500">{{ centro.direccion }}</p>
        </div>
      </div>
      
      <div class="col-span-3 md:col-span-3 text-sm text-slate-600 space-y-1">
         <div class="flex items-center gap-2">
            <DocumentChartBarIcon class="h-5 w-5 text-slate-400"/>
            <span>Informes: <span class="font-bold text-slate-800">{{ centro.numero_informes }}</span></span>
          </div>
          <div v-if="centro.ultima_revision" class="flex items-center gap-2">
            <CalendarDaysIcon class="h-5 w-5 text-slate-400" />
            <span>√öltima: <span class="font-semibold text-slate-800">{{ centro.ultima_revision }}</span></span>
          </div>
      </div>

      <div class="col-span-3 md:col-span-2">
        <span :class="['inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium', getZonaColor(centro.zona)]">
          {{ centro.zona }}
        </span>
      </div>
      
      <div class="col-span-6 md:col-span-3 flex items-center justify-start md:justify-end flex-wrap gap-2">
        <button @click="openEditModal(centro)" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <PencilIcon class="h-4 w-4" /> Editar
        </button>
        <router-link :to="`/centros/${centro.id}/historial`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <ArchiveBoxIcon class="h-4 w-4" /> Historial
        </router-link>
        <router-link :to="`/centros/${centro.id}/versiones`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
          <DocumentDuplicateIcon class="h-4 w-4" /> Planos
        </router-link>
      </div>
    </div>
  </div>
</div>

<CentroFormModal :is-open="isModalOpen" :centro="selectedCentro" @close="isModalOpen = false" @save="handleSaveCentro" />
</div>
</template>
--- FIN DEL ARCHIVO: src/views/CentrosListView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroHistorialView.vue ---
<!-- src/views/CentroHistorialView.vue -->
<script setup>
import { ref, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { useInspections } from '../composables/useInspections';
import InspectionListItem from '../components/InspectionListItem.vue';
import MarkAsSentModal from '../components/MarkAsSentModal.vue';

const showNotification = inject('showNotification');
const showConfirm = inject('showConfirm');
const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const {
  loading,
  loadingMore,
  centro,
  inspecciones,
  availableYears,
  hasMorePages,
  loadMore,
  loadInspectionDetails,
  updateInspectionInList,
  removeInspectionFromList
} = useInspections(centroId);

const isProcessing = ref(null);
const isSentModalOpen = ref(false);
const selectedInspeccion = ref(null);
const selectedYear = ref(null);

const filteredInspecciones = computed(() => {
  if (selectedYear.value === null) {
    return inspecciones.value;
  }
  return inspecciones.value.filter(inspeccion => {
    return new Date(inspeccion.fecha_inspeccion).getFullYear() === selectedYear.value;
  });
});

const deleteB2Files = async (urls) => {
  const fileUrls = urls.filter(url => url && url.includes('backblazeb2.com'));
  if (fileUrls.length === 0) {
    return true; // No hay nada que borrar
  }

  showNotification(`Borrando ${fileUrls.length} informe(s) de B2...`, 'info');

  const deletePromises = fileUrls.map(fileUrl => 
    supabase.functions.invoke('delete-b2-file', {
      body: { fileUrl },
    })
  );

  const results = await Promise.all(deletePromises);
  const failedDeletes = results.filter(res => res.error);

  if (failedDeletes.length > 0) {
    console.error('Errores al borrar archivos de B2:', failedDeletes);
    showNotification(`Error al borrar ${failedDeletes.length} archivo(s) de B2. Revisa la consola.`, 'error');
  } else {
    showNotification('Informe(s) borrado(s) de B2 con √©xito.', 'success');
  }
  
  return true;
};

const openSentModal = (inspeccion) => {
  selectedInspeccion.value = inspeccion;
  isSentModalOpen.value = true;
};

const handleMarkAsSent = async (formData) => {
  if (!selectedInspeccion.value) return;
  
  isProcessing.value = selectedInspeccion.value.id;
  isSentModalOpen.value = false;

  try {
    const { data, error } = await supabase
      .from('inspecciones')
      .update({ 
        fecha_envio_cliente: formData.fecha_envio, 
        responsable_envio_cliente: formData.responsable_envio,
        estado: 'pendiente_subsanacion'
      })
      .eq('id', selectedInspeccion.value.id)
      .select()
      .single();

    if (error) throw error;
    
    // Invalidamos la cach√© de localStorage para forzar la recarga de datos frescos.
    localStorage.removeItem(`inspections_${centroId}`);

    updateInspectionInList(data);
    showNotification('Registro de env√≠o guardado con √©xito.', 'success');
  } catch (error) {
    showNotification('Error al registrar el env√≠o: ' + error.message, 'error');
  } finally {
    isProcessing.value = null;
  }
};

const reabrirInspeccion = async (inspeccion) => {
  const confirmed = await showConfirm('Reabrir Inspecci√≥n', `¬øEst√°s seguro de que quieres reabrir la inspecci√≥n del ${new Date(inspeccion.fecha_inspeccion).toLocaleDateString()}? El PDF archivado ser√° invalidado y eliminado de B2.`);
  if (!confirmed) return;
  
  isProcessing.value = inspeccion.id;
  
  try {
    await deleteB2Files([inspeccion.url_pdf_informe_inicial, inspeccion.url_pdf_informe_final]);

    const { data, error } = await supabase
      .from('inspecciones')
      .update({
        estado: 'en_progreso',
        url_pdf_informe_inicial: null,
        url_pdf_informe_final: null
      })
      .eq('id', inspeccion.id)
      .select()
      .single();

    if (error) throw error;
    
    // Invalidamos la cach√© de localStorage para forzar la recarga de datos frescos.
    localStorage.removeItem(`inspections_${centroId}`);

    updateInspectionInList(data);
    showNotification('Inspecci√≥n reabierta. Ahora puedes editarla de nuevo.', 'success');
  } catch (error) {
    showNotification('Error al reabrir la inspecci√≥n: ' + error.message, 'error');
  } finally {
    isProcessing.value = null;
  }
}

const handleDelete = async (inspeccionId) => {
  const confirmed = await showConfirm('Borrar Inspecci√≥n', '¬øEst√°s seguro? Esta acci√≥n es permanente y eliminar√° todos los datos y archivos asociados.');
  if (!confirmed) return;

  isProcessing.value = inspeccionId;
  
  try {
    const inspeccion = inspecciones.value.find(i => i.id === inspeccionId);
    if (!inspeccion) throw new Error("No se encontr√≥ la inspecci√≥n para borrar sus archivos.");

    await deleteB2Files([inspeccion.url_pdf_informe_inicial, inspeccion.url_pdf_informe_final]);

    showNotification('Borrando fotos, por favor espera...', 'info');
    const { error: functionError } = await supabase.functions.invoke('delete-inspection-files', {
      body: { inspeccion_id: inspeccionId },
    });
    if (functionError) {
      const continueDelete = await showConfirm('Error', `No se pudieron borrar las fotos: ${functionError.message}. ¬øContinuar borrando los datos?`);
      if (!continueDelete) { isProcessing.value = null; return; }
    }
    
    showNotification('Borrando datos de la base de datos...', 'info');
    const { error: rpcError } = await supabase.rpc('delete_inspection_data', {
      inspeccion_id_param: inspeccionId
    });
    if (rpcError) throw rpcError;

    // Invalidamos la cach√© de localStorage para forzar la recarga de datos frescos.
    localStorage.removeItem(`inspections_${centroId}`);

    removeInspectionFromList(inspeccionId);
    showNotification('Inspecci√≥n borrada con √©xito.', 'success');

  } catch (error) {
    showNotification('Ocurri√≥ un error al borrar la inspecci√≥n: ' + error.message, 'error');
  } finally {
    isProcessing.value = null;
  }
};


const handleDateUpdated = ({ id, newDate }) => {
  const inspeccion = inspecciones.value.find(i => i.id === id);
  if (inspeccion) {
    inspeccion.fecha_inspeccion = newDate;
  }
};
</script>

<template>
  <div class="p-4 md:p-8">
    <div v-if="loading" class="text-center p-10">Cargando historial...</div>
    <div v-else-if="centro">
      <div class="flex flex-col md:flex-row justify-between md:items-center mb-4 gap-4">
        <div>
          <h1 class="text-3xl md:text-4xl font-bold text-slate-800">Historial de Inspecciones</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <button @click="router.push('/centros')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50 self-start md:self-center">Volver</button>
      </div>

      <div v-if="availableYears.length > 0" class="mb-6 pb-4 border-b border-slate-200">
        <h3 class="text-sm font-semibold text-slate-500 mb-2">Filtrar por a√±o:</h3>
        <div class="flex flex-wrap gap-2">
          <button 
            @click="selectedYear = null"
            :class="['px-3 py-1 text-sm font-semibold rounded-full transition-colors', selectedYear === null ? 'bg-blue-600 text-white shadow' : 'bg-slate-200 text-slate-700 hover:bg-slate-300']">
            Todos
          </button>
          <button 
            v-for="year in availableYears" 
            :key="year"
            @click="selectedYear = year"
            :class="['px-3 py-1 text-sm font-semibold rounded-full transition-colors', selectedYear === year ? 'bg-blue-600 text-white shadow' : 'bg-slate-200 text-slate-700 hover:bg-slate-300']">
            {{ year }}
          </button>
        </div>
      </div>

      <div class="space-y-4">
        <div v-if="filteredInspecciones.length === 0" class="p-8 text-center text-slate-500 bg-white rounded-xl shadow-sm border">
          No hay inspecciones para el a√±o seleccionado.
        </div>
        
        <InspectionListItem
          v-for="inspeccion in filteredInspecciones"
          :key="inspeccion.id"
          :inspeccion="inspeccion"
          :is-processing="isProcessing === inspeccion.id"
          @mouseenter="loadInspectionDetails(inspeccion.id)"
          @mark-as-sent="openSentModal"
          @reopen="reabrirInspeccion"
          @delete="handleDelete"
          @date-updated="handleDateUpdated"
        />

        <div v-if="hasMorePages && !loadingMore" class="text-center py-4">
          <button @click="loadMore" class="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 font-semibold">
            Cargar m√°s inspecciones
          </button>
        </div>
        <div v-if="loadingMore" class="text-center py-4">
          <div class="inline-flex items-center gap-2 text-slate-600">
            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            Cargando m√°s inspecciones...
          </div>
        </div>
      </div>
    </div>
    <MarkAsSentModal :is-open="isSentModalOpen" :inspeccion-id="selectedInspeccion?.id" @close="isSentModalOpen = false" @save="handleMarkAsSent" />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroHistorialView.vue ---

--- INICIO DEL ARCHIVO: src/views/CierreInformeView.vue ---
<!-- src/views/CierreInformeView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';
import { generateTextReport } from '../utils/pdf';
import { ArrowUpTrayIcon, CheckCircleIcon, TrashIcon } from '@heroicons/vue/24/solid';

const showNotification = inject('showNotification');
const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const isFinalizing = ref(false);
const inspeccion = ref(null);
const incidencias = ref([]);
const isUploading = ref(null);
const dragOverIncidenceId = ref(null);

onMounted(async () => {
  loading.value = true;
  const { data: inspectionData } = await supabase.from('inspecciones').select('*, centros(nombre, id)').eq('id', inspeccionId).single();
  inspeccion.value = inspectionData;
  const { data: incidenciasData } = await supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId).neq('item_checklist', 2).order('item_checklist', { ascending: true });
  incidencias.value = incidenciasData || [];
  loading.value = false;
});

const getItemText = (itemId) => {
  const item = checklistItems.find(i => i.id === itemId);
  return item ? `${item.id}. ${item.text}` : 'Item desconocido';
};

const onDragOver = (event, incidenceId) => {
  event.preventDefault();
  dragOverIncidenceId.value = incidenceId;
};

const onDragLeave = (event) => {
  event.preventDefault();
  dragOverIncidenceId.value = null;
};

const onDrop = (event, incidencia) => {
  event.preventDefault();
  dragOverIncidenceId.value = null;
  const files = event.dataTransfer.files;
  if (files.length === 0) return;
  if (files.length > 1) {
    showNotification('Solo se permite subir una foto a la vez.', 'error');
    return;
  }
  const file = files[0];
  handleFileUpload(file, incidencia);
};
const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;
  handleFileUpload(file, incidencia);
};

const handleFileUpload = async (file, incidencia) => {
  // Validations
  if (!file.type.startsWith('image/')) {
    showNotification('Solo se permiten archivos de imagen.', 'error');
    return;
  }
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    showNotification('El archivo es demasiado grande. M√°ximo 10MB.', 'error');
    return;
  }

  isUploading.value = incidencia.id;

  try {
    // Compress image if it's large
    let fileToUpload = file;
    const originalSize = file.size;

    if (file.size > 500 * 1024) { // Compress if larger than 500KB
      showNotification('Comprimiendo imagen...', 'info');

      // Use canvas API for compression
      const compressedFile = await compressImage(file);
      fileToUpload = compressedFile;

      const compressionRatio = ((originalSize - compressedFile.size) / originalSize * 100).toFixed(1);
      if (compressionRatio > 5) {
        showNotification(`Imagen comprimida: ${compressionRatio}% de reducci√≥n`, 'success');
      }
    }

    // Cambiamos el nombre de la carpeta para mantener consistencia
    const fileName = `cierre_informe_${inspeccionId}/incidencia_${incidencia.id}/${Date.now()}_${file.name}`;
    const { error: uploadError } = await supabase.storage.from('incidencias').upload(fileName, fileToUpload, { upsert: true });
    if (uploadError) {
      showNotification("Error al subir la foto: " + uploadError.message, 'error');
      isUploading.value = null;
      return;
    }
    const { data: { publicUrl } } = supabase.storage.from('incidencias').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('incidencias').update({ url_foto_despues: publicUrl }).eq('id', incidencia.id);
    if (updateError) {
      showNotification("Error al guardar la URL: " + updateError.message, 'error');
    } else {
      incidencia.url_foto_despues = publicUrl;
      showNotification('Foto subida correctamente.', 'success');
    }
    isUploading.value = null;
  } catch (error) {
    console.error('Error processing image:', error);
    showNotification('Error al procesar la imagen: ' + error.message, 'error');
    isUploading.value = null;
  }
};

// Compress image using Canvas API
const compressImage = (file) => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    img.onload = () => {
      // Calculate new dimensions (max 1024px on longest side for smaller files)
      let { width, height } = img;
      const maxDimension = 1024;

      if (width > height) {
        if (width > maxDimension) {
          height = (height * maxDimension) / width;
          width = maxDimension;
        }
      } else {
        if (height > maxDimension) {
          width = (width * maxDimension) / height;
          height = maxDimension;
        }
      }

      canvas.width = width;
      canvas.height = height;

      // Draw and compress with lower quality for much smaller files
      ctx.drawImage(img, 0, 0, width, height);

      canvas.toBlob((blob) => {
        if (blob) {
          // Create a new file with the compressed blob
          const compressedFile = new File([blob], file.name, {
            type: 'image/jpeg',
            lastModified: Date.now()
          });
          resolve(compressedFile);
        } else {
          reject(new Error('Failed to compress image'));
        }
      }, 'image/jpeg', 0.6); // 60% quality for smaller file sizes
    };

    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
};

const deletePhoto = async (incidencia) => {
  if (!incidencia.url_foto_despues) return;

  if (!confirm('¬øEst√°s seguro de que quieres eliminar esta foto de correcci√≥n?')) {
    return;
  }

  try {
    // Extract file path from URL
    const url = new URL(incidencia.url_foto_despues);
    const pathParts = url.pathname.split('/');
    // Find the index after 'incidencias' bucket
    const bucketIndex = pathParts.findIndex(part => part === 'incidencias');
    const filePath = pathParts.slice(bucketIndex + 1).join('/');

    // Delete from storage
    const { error: storageError } = await supabase.storage.from('incidencias').remove([filePath]);
    if (storageError) {
      console.error('Storage deletion error:', storageError);
      showNotification('Advertencia: Error al eliminar del almacenamiento, pero se actualiz√≥ la base de datos.', 'warning');
      // Continue with DB update even if storage deletion fails
    }

    // Update database
    const { error: dbError } = await supabase.from('incidencias').update({ url_foto_despues: null }).eq('id', incidencia.id);
    if (dbError) {
      showNotification('Error al actualizar la base de datos: ' + dbError.message, 'error');
      return;
    }

    // Update local state
    incidencia.url_foto_despues = null;
    showNotification('Foto eliminada correctamente.', 'success');
  } catch (error) {
    console.error('Error deleting photo:', error);
    showNotification('Error al eliminar la foto: ' + error.message, 'error');
  }
};

const todasSubsanadas = computed(() => {
  if (incidencias.value.length === 0) return true;
  return incidencias.value.every(inc => !!inc.url_foto_despues);
});

function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      const dataUrl = reader.result;
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    reader.readAsDataURL(blob);
  });
}

const finalizarInforme = async () => {
  if (!confirm('¬øEst√°s seguro de que quieres generar el Informe de Cierre, archivarlo y cerrar esta inspecci√≥n?')) {
      return;
  }
  isFinalizing.value = true;
  try {
    // Llamamos a generateTextReport con el tipo 'remediation' que internamente genera el informe de cierre
    const report = await generateTextReport(inspeccionId, 'remediation', 'blob');
    if (!report || !report.blob) throw new Error("La generaci√≥n del PDF de Cierre fall√≥.");

    const base64File = await blobToBase64(report.blob);

    const centroId = inspeccion.value.centros.id;
    const fileNameWithId = `${inspeccionId}-${report.fileName}`;
    const finalFileName = `centro_${centroId}/${fileNameWithId}`;

    const { data, error: invokeError } = await supabase.functions.invoke('upload-pdf-to-b2', {
      body: { 
        file: base64File,
        fileName: finalFileName,
        contentType: 'application/pdf'
      }
    });

    if (invokeError) throw new Error(`Error al contactar con la funci√≥n Edge: ${invokeError.message}.`);
    if (data.error) throw new Error(data.error);
    if (!data.publicUrl) throw new Error('La funci√≥n Edge no devolvi√≥ una URL v√°lida.');
    
    const publicUrl = data.publicUrl;
    
    const { error: updateError } = await supabase.from('inspecciones').update({ estado: 'cerrada', url_pdf_informe_final: publicUrl }).eq('id', inspeccionId);
    if (updateError) throw updateError;
    
    showNotification('Inspecci√≥n cerrada y archivada con √©xito.');
    router.push(`/centros/${inspeccion.value.centros.id}/historial`);
  } catch (error) {
    console.error("Error al finalizar el informe de cierre:", error);
    showNotification('Ocurri√≥ un error al finalizar: ' + error.message, 'error');
  } finally {
    isFinalizing.value = false;
  }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex items-center justify-center">Cargando datos del informe...</div>
    <div v-else-if="inspeccion" class="flex-1 flex flex-col min-h-0">
      <header class="flex-shrink-0 px-4 sm:px-8 pt-6 sm:pt-8 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 class="text-2xl sm:text-3xl font-bold text-slate-800">Generar Informe de Cierre</h1>
            <p class="text-lg text-slate-600 mt-1">{{ inspeccion.centros.nombre }}</p>
            <p class="text-sm text-slate-500 mt-1">Inspecci√≥n del {{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</p>
          </div>
          <div class="flex gap-4 w-full sm:w-auto">
            <button @click="router.go(-1)" class="flex-1 sm:flex-none px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Volver</button>
            <button @click="finalizarInforme" :disabled="!todasSubsanadas || isFinalizing" class="flex-1 sm:flex-none flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
              <CheckCircleIcon class="h-5 w-5" />
              {{ isFinalizing ? 'Finalizando...' : 'Finalizar y Cerrar' }}
            </button>
          </div>
        </div>
      </header>
      <main class="flex-1 overflow-y-auto p-4 sm:p-8">
        <div class="space-y-6 max-w-7xl mx-auto">
          <div v-if="incidencias.length === 0" class="bg-white p-8 rounded-lg shadow-sm text-center">
              <h3 class="text-lg font-medium text-slate-700">¬°No hay incidencias que corregir!</h3>
              <p class="text-slate-500">Esta inspecci√≥n no tiene incidencias que requieran una foto de correcci√≥n. Puedes cerrarla directamente.</p>
          </div>
          <div v-for="incidencia in incidencias" :key="incidencia.id" class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 class="font-bold text-lg text-slate-800 border-b pb-3 mb-4">{{ getItemText(incidencia.item_checklist) }}</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">ANTES (Incidencia Original)</p>
                <div class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden">
                  <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="w-full h-full object-contain">
                  <p v-else class="text-slate-500 text-sm p-4">No se adjunt√≥ foto de la incidencia.</p>
                </div>
                <div v-if="incidencia.observaciones" class="mt-3 text-sm bg-slate-50 p-3 rounded-md">
                  <strong>Observaciones:</strong> {{ incidencia.observaciones }}
                </div>
              </div>
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">DESPU√âS (Evidencia de Correcci√≥n)</p>
                <div
                  class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden relative group transition-colors"
                  :class="{ 'bg-blue-200 border-2 border-blue-400 border-dashed': dragOverIncidenceId === incidencia.id }"
                  @dragover="onDragOver($event, incidencia.id)"
                  @dragleave="onDragLeave"
                  @drop="onDrop($event, incidencia)"
                >
                  <img v-if="incidencia.url_foto_despues" :src="incidencia.url_foto_despues" class="w-full h-full object-contain">
                  <div v-else-if="isUploading === incidencia.id" class="text-center text-slate-600">Subiendo foto...</div>
                  <div v-else class="text-center">
                    <p v-if="dragOverIncidenceId === incidencia.id" class="text-sm text-slate-600">Suelta la foto aqu√≠</p>
                    <label v-else :for="'fileInput-' + incidencia.id" class="cursor-pointer flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                      <ArrowUpTrayIcon class="h-4 w-4" />
                      Subir Foto
                    </label>
                    <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id" accept="image/*">
                  </div>
                   <div v-if="incidencia.url_foto_despues" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                     <div class="flex gap-4">
                       <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInputChange-' + incidencia.id" accept="image/*">
                       <label :for="'fileInputChange-' + incidencia.id" class="cursor-pointer text-white font-semibold">Cambiar Foto</label>
                       <button @click="deletePhoto(incidencia)" class="text-white font-semibold hover:text-red-300 flex items-center gap-1">
                         <TrashIcon class="h-4 w-4" />
                         Eliminar
                       </button>
                     </div>
                   </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CierreInformeView.vue ---

--- INICIO DEL ARCHIVO: src/views/InspeccionDetailView.vue ---
<!-- src/views/InspeccionDetailView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import ChecklistModal from '../components/ChecklistModal.vue';
import InspectionSidebar from '../components/InspectionSidebar.vue';
import GlobalStatusIndicator from '../components/GlobalStatusIndicator.vue';
import { CheckCircleIcon, InformationCircleIcon, MapIcon, PlusIcon, PencilSquareIcon, ArrowLeftIcon, ListBulletIcon, Bars3Icon } from '@heroicons/vue/24/solid';
import { generateTextReport } from '../utils/pdf';
import SkeletonLoader from '../components/SkeletonLoader.vue';
import { addToQueue, processQueue, syncQueue, waitForQueueToEmpty } from '../utils/syncQueue';

const showNotification = inject('showNotification');
const showConfirm = inject('showConfirm');
const toggleSidebar = inject('toggleSidebar', null);
const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const isFinalizing = ref(false);
const inspeccion = ref(null);
const centro = ref(null);
const version = ref(null);
const salas = ref([]);
const puntosMaestros = ref([]);
const puntosInspeccionados = ref([]);
const isModalOpen = ref(false);
const selectedPunto = ref(null);
const allIncidencias = ref([]);
const allCustomFields = ref([]);
const isPlacementMode = ref(false);
const newPointSalaId = ref(null);
const isAreaDrawingMode = ref(false);
const salaParaDibujar = ref(null);
const isPlanoEditingMode = ref(false);
const isMobileAddPointOpen = ref(false);
const showMapInMobile = ref(false);

const canEditInspection = computed(() => {
  return inspeccion.value?.estado === 'en_progreso';
});

// --- INICIO DE LA CORRECCI√ìN: Nueva propiedad computada para la validaci√≥n ---
const existingIdentifiersInSala = computed(() => {
  if (!selectedPunto.value) return [];
  
  // 1. Encontrar el punto maestro correspondiente al punto de inspecci√≥n seleccionado.
  const puntoMaestroSeleccionado = puntosMaestros.value.find(pm => pm.id === selectedPunto.value.punto_maestro_id);
  if (!puntoMaestroSeleccionado) return [];

  const salaId = puntoMaestroSeleccionado.sala_id;

  // 2. Obtener todos los puntos maestros de esa misma sala.
  return puntosMaestros.value
    .filter(pm => 
      // Que pertenezcan a la misma sala
      pm.sala_id === salaId && 
      // Y que no sea el punto que estamos editando actualmente
      pm.id !== puntoMaestroSeleccionado.id
    )
    .map(pm => pm.nomenclatura.split('-').pop() || ''); // 3. Extraer solo el identificador final (ej: "10", "Picking-A").
});
// --- FIN DE LA CORRECCI√ìN ---


const refreshInspectedPoints = async () => {
  if (!navigator.onLine) {
    return;
  }
  const { data: updatedPoints, error: pointsError } = await supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId);
  if (pointsError) {
    showNotification('Error al refrescar los datos de los puntos.', 'error');
  } else {
    puntosInspeccionados.value = updatedPoints || [];
  }
  
  const { data: updatedIncidencias, error: incidenciasError } = await supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId);
  if (incidenciasError) {
      showNotification('Error al refrescar las incidencias.', 'error');
  } else {
      allIncidencias.value = updatedIncidencias || [];
  }
};

const loadAllData = async () => {
  loading.value = true;
  
  const { data: inspectionData, error: inspectionError } = await supabase
    .from('inspecciones')
    .select('*, centros(*), versiones_plano(*)')
    .eq('id', inspeccionId)
    .single();

  if (inspectionError || !inspectionData) {
    showNotification('Error cr√≠tico: No se pudo cargar la inspecci√≥n.', 'error');
    loading.value = false;
    return;
  }
  
  inspeccion.value = inspectionData;
  centro.value = inspectionData.centros;
  version.value = inspectionData.versiones_plano;

  if (!version.value) {
      showNotification('Error: La inspecci√≥n no tiene una versi√≥n de plano asociada.', 'error');
      loading.value = false;
      return;
  }
  
  const [salasRes, puntosMaestrosRes, puntosInspeccionadosRes, incidenciasRes, customFieldsRes] = await Promise.all([
    supabase.from('salas').select('*').eq('version_id', version.value.id).order('nombre'),
    supabase.from('puntos_maestros').select('*').eq('version_id', version.value.id),
    supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId),
    supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId),
    supabase.from('checklist_custom_fields').select('*').order('point_id, id')
  ]);
  
  salas.value = salasRes.data || [];
  puntosMaestros.value = puntosMaestrosRes.data || [];
  puntosInspeccionados.value = puntosInspeccionadosRes.data || [];
  allIncidencias.value = incidenciasRes.data || [];
  allCustomFields.value = customFieldsRes.data || [];

  await initializeInspectionPoints();

  loading.value = false;
};

const initializeInspectionPoints = async () => {
  if (canEditInspection.value && puntosInspeccionados.value.length === 0 && puntosMaestros.value.length > 0) {
    if (!navigator.onLine) {
        showNotification("Se necesita conexi√≥n a internet para iniciar una inspecci√≥n por primera vez.", "warning", 5000);
        return;
    }
    const pointsToCreate = puntosMaestros.value.map(pm => ({
      inspeccion_id: inspeccionId, punto_maestro_id: pm.id, nomenclatura: pm.nomenclatura,
      coordenada_x: pm.coordenada_x, coordenada_y: pm.coordenada_y,
      estado: 'existente', tiene_placa_caracteristicas: true
    }));
    if (pointsToCreate.length > 0) {
      const { data: newPoints, error } = await supabase.from('puntos_inspeccionados').insert(pointsToCreate).select();
      if (newPoints) {
        puntosInspeccionados.value = newPoints;
      }
      if(error) {
        showNotification('Error al inicializar los puntos de la inspecci√≥n.', 'error');
      }
    }
  }
};

onMounted(loadAllData);

const getSalaColor = (salaId) => salas.value.find(s => s.id === salaId)?.color || '#9CA3AF';

const puntosParaMostrar = computed(() => {
  return puntosInspeccionados.value.map(pi => {
    const maestro = puntosMaestros.value.find(pm => pm.id === pi.punto_maestro_id);
    return { ...pi, sala_id: maestro?.sala_id, color: getSalaColor(maestro?.sala_id) };
  });
});

const puntosAgrupadosPorSala = computed(() => {
  return salas.value.map(sala => ({
    ...sala,
    puntos: puntosParaMostrar.value
      .filter(p => p.sala_id === sala.id)
      .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}))
  })).filter(g => g.puntos.length > 0 || g.isNew);
});

const incidenciasDelPuntoSeleccionado = computed(() => {
    if (!selectedPunto.value) return [];
    return allIncidencias.value.filter(inc => inc.punto_inspeccionado_id === selectedPunto.value.id);
});

const handleIncidenciasUpdate = (nuevasIncidenciasDelPunto) => {
  if (!selectedPunto.value) return;

  const otrasIncidencias = allIncidencias.value.filter(
    inc => inc.punto_inspeccionado_id !== selectedPunto.value.id
  );

  allIncidencias.value = [...otrasIncidencias, ...nuevasIncidenciasDelPunto];
};

const createNewPointAt = async (coords, salaId) => {
  const salaSeleccionada = salas.value.find(s => s.id === salaId);
  const puntosDeLaSala = puntosMaestros.value.filter(p => p.sala_id === salaId);
  const ultimoNumero = Math.max(0, ...puntosDeLaSala.map(p => {
      const num = parseInt(p.nomenclatura.split('-').pop());
      return isNaN(num) ? 0 : num;
  }));
  const nuevaNomenclatura = `${salaSeleccionada.nombre}-${ultimoNumero + 1}`;

  const tempMaestroId = `temp_maestro_${Date.now()}`;
  const nuevoPuntoMaestro = {
    id: tempMaestroId, version_id: version.value.id, sala_id: salaId, 
    nomenclatura: nuevaNomenclatura, coordenada_x: coords.x, coordenada_y: coords.y
  };
  const tempInspeccionadoId = `temp_inspeccionado_${Date.now()}`;
  const nuevoPuntoIns = {
    id: tempInspeccionadoId, inspeccion_id: inspeccionId, punto_maestro_id: tempMaestroId,
    nomenclatura: nuevaNomenclatura, coordenada_x: coords.x, coordenada_y: coords.y,
    estado: 'nuevo', tiene_placa_caracteristicas: true
  };

  puntosMaestros.value.push(nuevoPuntoMaestro);
  puntosInspeccionados.value.push(nuevoPuntoIns);

  const { id: idM, ...payloadM } = nuevoPuntoMaestro;
  addToQueue({ table: 'puntos_maestros', type: 'insert', tempId: tempMaestroId, payload: payloadM });

  const { id: idI, ...payloadI } = nuevoPuntoIns;
  addToQueue({ table: 'puntos_inspeccionados', type: 'insert', tempId: tempInspeccionadoId, payload: payloadI });

  const tempIncidenciaId = `temp_incidencia_${Date.now()}`;
  const nuevaIncidencia = {
      id: tempIncidenciaId, inspeccion_id: inspeccionId, punto_inspeccionado_id: tempInspeccionadoId,
      item_checklist: 3, gravedad: 'ambar', observaciones: 'Alineaci√≥n de nueva implantaci√≥n.'
  };
  allIncidencias.value.push(nuevaIncidencia);

  const { id: idInc, ...payloadInc } = nuevaIncidencia;
  addToQueue({ table: 'incidencias', type: 'insert', tempId: tempIncidenciaId, payload: payloadInc });

  showNotification(`Punto ${nuevaNomenclatura} a√±adido localmente.`, 'success', 1500);
};

const openChecklistFor = (punto) => {
  if (isPlacementMode.value || isAreaDrawingMode.value) return;
  selectedPunto.value = punto; 
  isModalOpen.value = true;
};
const updatePuntoEstado = async (punto, nuevoEstado) => {
  const puntoEnArray = puntosInspeccionados.value.find(p => p.id === punto.id);
  if(puntoEnArray) puntoEnArray.estado = nuevoEstado;
  addToQueue({
      table: 'puntos_inspeccionados', type: 'update', id: punto.id, payload: { estado: nuevoEstado }
  });
};
const handleDeleteNewPoint = async (punto) => {
  if (!canEditInspection.value) return;
  if(!navigator.onLine){ showNotification("Necesitas conexi√≥n para borrar un punto.", "warning"); return; }
  if (confirm(`¬øEst√°s seguro de que quieres borrar permanentemente el punto "${punto.nomenclatura}"?`)) {
      const { error: inspError } = await supabase.from('puntos_inspeccionados').delete().eq('id', punto.id);
      if (inspError) { showNotification("Error al borrar el punto de la inspecci√≥n: " + inspError.message, 'error'); return; }
      const { error: maestroError } = await supabase.from('puntos_maestros').delete().eq('id', punto.punto_maestro_id);
      if (maestroError) { showNotification("Advertencia: No se pudo borrar el punto del plano maestro.", 'error'); }
      puntosInspeccionados.value = puntosInspeccionados.value.filter(p => p.id !== punto.id);
      puntosMaestros.value = puntosMaestros.value.filter(p => p.id !== punto.punto_maestro_id);
      allIncidencias.value = allIncidencias.value.filter(i => i.punto_inspeccionado_id !== punto.id);
      showNotification(`Punto ${punto.nomenclatura} borrado con √©xito.`);
  }
};
const handleTogglePlanoEditing = (isActive) => {
  isPlanoEditingMode.value = isActive;
  if (!isActive) {
    isAreaDrawingMode.value = false;
    salaParaDibujar.value = null;
  }
};

// Funci√≥n para manejar el toggle desde el header m√≥vil
const toggleMobilePlanoEditing = () => {
  isPlanoEditingMode.value = !isPlanoEditingMode.value;
  handleTogglePlanoEditing(isPlanoEditingMode.value);
};

// Funci√≥n para hacer toggle del mapa en m√≥vil
const toggleMapInMobile = () => {
  showMapInMobile.value = !showMapInMobile.value;
  // Si estamos mostrando el mapa, desactivamos el modo de agregar puntos
  if (showMapInMobile.value) {
    isMobileAddPointOpen.value = false;
  }
};
const handleAddSala = async (name) => {
    if(!navigator.onLine){ showNotification("Necesitas conexi√≥n para a√±adir salas.", "warning"); return; }
    const { data: newSala, error } = await supabase.from('salas').insert({ version_id: version.value.id, nombre: name, color: '#808080' }).select().single();
    if (error) { showNotification('Error al crear la sala: ' + error.message, 'error'); return; }
    newSala.isNew = true;
    salas.value.push(newSala);
    salas.value.sort((a,b) => a.nombre.localeCompare(b.nombre));
    showNotification(`Sala "${name}" creada en el plano.`, 'success');
    handleStartAreaDrawing(newSala);
};
const handleStartAreaDrawing = (sala) => {
    salaParaDibujar.value = sala;
    isAreaDrawingMode.value = true;
    showNotification(`Modo dibujo activado para "${sala.nombre}". Haz clic en el mapa para definir su √°rea.`, 'success', 4000);
};
const handleAreaDrawn = (points) => {
    const salaInArray = salas.value.find(s => s.id === salaParaDibujar.value.id);
    if (salaInArray) salaInArray.area_puntos = points;
    addToQueue({ table: 'salas', type: 'update', id: salaParaDibujar.value.id, payload: { area_puntos: points } });
    showNotification(`√Årea de "${salaParaDibujar.value.nombre}" guardada localmente.`, 'success');
    isAreaDrawingMode.value = false;
    salaParaDibujar.value = null;
};
const handleDrawingCancelled = () => {
    isAreaDrawingMode.value = false;
    salaParaDibujar.value = null;
    showNotification('Dibujo cancelado.', 'success', 2000);
};
const handleStartPlacementMode = (salaId) => {
  isPlacementMode.value = true;
  newPointSalaId.value = salaId;
};
const handleCancelPlacementMode = () => {
  isPlacementMode.value = false;
  newPointSalaId.value = null;
};
const handleMapClick = (coords) => {
  if (isPlacementMode.value) { createNewPointAt(coords, newPointSalaId.value); }
};

// --- INICIO DE LA CORRECCI√ìN: Funci√≥n simplificada sin validaci√≥n ---
const handleUpdatePointNomenclatura = async (puntoMaestro, newNomenclature) => {
    // La validaci√≥n ahora ocurre dentro del modal, por lo que aqu√≠ simplemente confiamos y procedemos.
    const puntoInspeccionado = puntosInspeccionados.value.find(pi => pi.punto_maestro_id === puntoMaestro.id);
    if (!puntoInspeccionado) { 
      showNotification('Error interno: no se encontr√≥ el punto de inspecci√≥n correspondiente.', 'error'); 
      return; 
    }

    // Actualizamos el estado local para reflejar el cambio inmediatamente en la UI.
    const maestro = puntosMaestros.value.find(p => p.id === puntoMaestro.id);
    if (maestro) maestro.nomenclatura = newNomenclature;
    if (puntoInspeccionado) puntoInspeccionado.nomenclatura = newNomenclature;

    // Encolamos las acciones para sincronizarlas con la base de datos.
    addToQueue({ table: 'puntos_maestros', type: 'update', id: puntoMaestro.id, payload: { nomenclatura: newNomenclature } });
    addToQueue({ table: 'puntos_inspeccionados', type: 'update', id: puntoInspeccionado.id, payload: { nomenclatura: newNomenclature } });
    
    showNotification('Nombre del punto actualizado localmente.', 'success');
};
// --- FIN DE LA CORRECCI√ìN ---

function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      const dataUrl = reader.result;
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    reader.readAsDataURL(blob);
  });
}
const finalizarInspeccion = async () => {
    if(!navigator.onLine){ showNotification("Necesitas conexi√≥n para finalizar y generar el PDF.", "error"); return; }
    const confirmed = await showConfirm('Finalizar Inspecci√≥n', '¬øEst√°s seguro de que quieres finalizar esta inspecci√≥n? Se generar√° y archivar√° el informe PDF, y la inspecci√≥n quedar√° bloqueada.');
    if (!confirmed) return;
    isFinalizing.value = true;
    try {
        // Wait for sync queue to be processed before generating PDF
        if (syncQueue.value.length > 0) {
            showNotification(`Sincronizando ${syncQueue.value.length} cambios pendientes...`, 'info', 3000);

            try {
                // Trigger queue processing
                await processQueue();
                // Wait for queue to be completely empty
                await waitForQueueToEmpty();
                showNotification('Sincronizaci√≥n completa', 'success', 2000);
            } catch (syncError) {
                console.error('Error during sync:', syncError);
                const continueAnyway = await showConfirm(
                    'Error de sincronizaci√≥n',
                    `No se pudieron sincronizar todos los cambios: ${syncError.message}\n\n¬øDeseas continuar de todos modos? El PDF podr√≠a no incluir todos los cambios offline.`
                );
                if (!continueAnyway) {
                    isFinalizing.value = false;
                    return;
                }
            }
        }

        const report = await generateTextReport(inspeccionId, 'initial', 'blob');
        if (!report || !report.blob) throw new Error("La generaci√≥n del PDF fall√≥.");
        const base64File = await blobToBase64(report.blob);
        const centroId = centro.value.id;
        const fileNameWithId = `${inspeccionId}-${report.fileName}`;
        const finalFileName = `centro_${centroId}/${fileNameWithId}`;
        const { data, error: invokeError } = await supabase.functions.invoke('upload-pdf-to-b2', { body: { file: base64File, fileName: finalFileName, contentType: 'application/pdf' } });
        if (invokeError) throw new Error(`Error al contactar con la funci√≥n Edge: ${invokeError.message}.`);
        if (data.error) throw new Error(`Error en el servidor al subir el archivo: ${data.error}`);
        if (!data.publicUrl) throw new Error('La funci√≥n Edge no devolvi√≥ una URL v√°lida.');
        const publicUrl = data.publicUrl;
        const { error: updateError } = await supabase.from('inspecciones').update({ estado: 'finalizada', url_pdf_informe_inicial: publicUrl }).eq('id', inspeccionId);
        if (updateError) throw updateError;
        const CACHE_KEY = `inspections_${centro.value.id}`;
        localStorage.removeItem(CACHE_KEY);
        showNotification('Inspecci√≥n finalizada y archivada con √©xito.');
        router.push(`/centros/${centro.value.id}/historial`);
    } catch (error) {
        console.error("Error completo al finalizar la inspecci√≥n:", error);
        showNotification('Ocurri√≥ un error al finalizar y archivar: ' + error.message, 'error');
    } finally {
        isFinalizing.value = false;
    }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex flex-col lg:flex-row overflow-hidden">
      <header class="flex-shrink-0 px-4 md:px-8 pt-6 pb-4 bg-slate-100/80 border-b border-slate-200 z-10">
         <div class="flex flex-col md:flex-row justify-between items-start gap-4">
            <div class="flex-1 space-y-2">
               <SkeletonLoader class="h-8 w-3/4" />
               <SkeletonLoader class="h-5 w-1/2" />
            </div>
            <div class="w-full md:w-auto">
               <SkeletonLoader class="h-10 w-48" />
            </div>
         </div>
      </header>
      <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">
         <aside class="w-full lg:w-80 xl:w-96 flex-shrink-0 bg-white border-r border-slate-200 p-4 space-y-4">
            <SkeletonLoader class="h-10 w-full" />
            <div class="space-y-2 pt-4">
               <SkeletonLoader v-for="i in 5" :key="i" class="h-12 w-full" />
            </div>
         </aside>
         <main class="flex-1 bg-slate-100 min-w-0 h-1/2 lg:h-full p-4">
            <SkeletonLoader class="h-full w-full" />
         </main>
      </div>
    </div>
    
    <div v-else-if="inspeccion && centro && version" class="flex-1 flex flex-col min-h-0">
      <!-- ============ HEADER M√ìVIL COMPACTO (visible solo < lg) ============ -->
      <header class="lg:hidden flex-shrink-0 px-3 py-2 bg-white border-b border-slate-200 z-10">
        <div class="flex items-center justify-between gap-2">
          <!-- Bot√≥n hamburguesa para el men√∫ lateral -->
          <button
            v-if="toggleSidebar"
            @click="toggleSidebar"
            class="p-2 rounded-md bg-slate-100 text-slate-600 hover:bg-slate-200 transition-colors"
            title="Abrir Men√∫"
            aria-label="Abrir Men√∫">
            <Bars3Icon class="h-5 w-5" />
          </button>

          <!-- Indicador de conexi√≥n -->
          <GlobalStatusIndicator mode="mobile" />

          <!-- Botones de acci√≥n compactos -->
          <div class="flex items-center gap-1">
            <!-- Bot√≥n Editar Plano -->
            <button
              v-if="canEditInspection"
              @click="toggleMobilePlanoEditing"
              :class="[
                'p-2 rounded-md transition-colors',
                isPlanoEditingMode ? 'bg-orange-500 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              ]"
              :title="isPlanoEditingMode ? 'Finalizar Edici√≥n' : 'Editar Plano'"
              :aria-label="isPlanoEditingMode ? 'Finalizar Edici√≥n' : 'Editar Plano'">
              <PencilSquareIcon class="h-5 w-5" />
            </button>

            <!-- Bot√≥n Agregar Punto -->
            <button
              v-if="canEditInspection && !isPlanoEditingMode"
              @click="isMobileAddPointOpen = !isMobileAddPointOpen"
              :class="[
                'p-2 rounded-md transition-colors',
                isMobileAddPointOpen ? 'bg-blue-500 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              ]"
              title="Agregar Punto"
              aria-label="Agregar Punto">
              <PlusIcon class="h-5 w-5" />
            </button>

            <!-- Bot√≥n Ver Plano / Ver Lista -->
            <button
              @click="toggleMapInMobile"
              :class="[
                'p-2 rounded-md transition-colors',
                showMapInMobile ? 'bg-blue-500 text-white' : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              ]"
              :title="showMapInMobile ? 'Ver Lista' : 'Ver Plano'"
              :aria-label="showMapInMobile ? 'Ver Lista' : 'Ver Plano'">
              <component :is="showMapInMobile ? ListBulletIcon : MapIcon" class="h-5 w-5" />
            </button>

            <!-- Bot√≥n Finalizar o Volver -->
            <button
              v-if="canEditInspection"
              @click="finalizarInspeccion"
              :disabled="isFinalizing"
              class="p-2 rounded-md bg-green-600 text-white hover:bg-green-700 disabled:bg-slate-400 transition-colors"
              title="Finalizar Inspecci√≥n"
              :aria-label="isFinalizing ? 'Finalizando...' : 'Finalizar Inspecci√≥n'">
              <CheckCircleIcon class="h-5 w-5" />
            </button>
            <button
              v-else
              @click="router.push(`/centros/${centro.id}/historial`)"
              class="p-2 rounded-md bg-slate-100 text-slate-600 hover:bg-slate-200 transition-colors"
              title="Volver al Historial"
              aria-label="Volver al Historial">
              <ArrowLeftIcon class="h-5 w-5" />
            </button>
          </div>
        </div>

        <!-- Aviso de solo lectura compacto (m√≥vil) -->
        <div v-if="!canEditInspection" class="mt-2 flex items-center gap-2 text-xs font-medium text-orange-700 bg-orange-50 border border-orange-200 rounded px-2 py-1">
          <InformationCircleIcon class="h-4 w-4 flex-shrink-0" />
          <span>Solo lectura</span>
        </div>
      </header>

      <!-- ============ HEADER DESKTOP COMPLETO (visible solo >= lg) ============ -->
      <header class="hidden lg:flex flex-shrink-0 px-4 md:px-8 pt-6 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4 w-full">
          <div class="flex-1">
            <h1 class="text-2xl md:text-3xl font-bold text-slate-800 mb-1">Inspecci√≥n: {{ centro.nombre }}</h1>
            <p class="text-slate-500 text-sm">
              T√©cnico: <span class="font-medium">{{ inspeccion.tecnico_nombre }}</span> |
              Fecha: <span class="font-medium">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</span> |
              Plano: <strong class="text-blue-600">{{ version.nombre }}</strong>
            </p>
            <div v-if="!canEditInspection" class="mt-2 flex items-center gap-2 text-sm font-semibold text-orange-700 bg-orange-100 border border-orange-200 rounded-md p-2 max-w-md">
                <InformationCircleIcon class="h-5 w-5 flex-shrink-0" />
                <span>Esta inspecci√≥n est√° bloqueada (modo solo lectura).</span>
            </div>
          </div>
          <div class="w-full md:w-auto flex items-center flex-col sm:flex-row gap-2">
            <button v-if="canEditInspection" @click="finalizarInspeccion" :disabled="isFinalizing" class="w-full sm:w-auto flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 shadow-sm disabled:bg-slate-400">
              <CheckCircleIcon class="h-5 w-5" />
              {{ isFinalizing ? 'Finalizando...' : 'Finalizar Inspecci√≥n' }}
            </button>
            <button v-else @click="router.push(`/centros/${centro.id}/historial`)" class="w-full sm:w-auto flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
              Volver al Historial
            </button>
          </div>
        </div>
      </header>
      
      <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">

        <InspectionSidebar
          :class="[
            'lg:block',
            showMapInMobile ? 'hidden' : 'block'
          ]"
          :can-edit="canEditInspection"
          :salas="salas"
          :puntos-agrupados="puntosAgrupadosPorSala"
          :all-incidencias="allIncidencias"
          :is-plano-editing-mode="isPlanoEditingMode"
          :is-mobile-add-point-open="isMobileAddPointOpen"
          @toggle-plano-editing="handleTogglePlanoEditing"
          @add-sala="handleAddSala"
          @start-area-drawing="handleStartAreaDrawing"
          @start-placement-mode="handleStartPlacementMode"
          @cancel-placement-mode="handleCancelPlacementMode"
          @select-point="openChecklistFor"
          @update-point-state="updatePuntoEstado"
          @delete-new-point="handleDeleteNewPoint"
          @update-point-nomenclatura="handleUpdatePointNomenclatura"
          @update:is-mobile-add-point-open="isMobileAddPointOpen = $event"
        />

        <main
          :class="[
            'flex-1 bg-slate-100 min-w-0 lg:h-full overflow-auto',
            showMapInMobile ? 'block' : 'hidden lg:block'
          ]"
        >
          <InteractiveMap
            v-if="!loading && version?.url_imagen_plano"
            :key="inspeccionId"
            :image-url="version.url_imagen_plano"
            :points="puntosParaMostrar.filter(p => p.estado !== 'suprimido')"
            :salas="salas"
            :all-incidencias="allIncidencias"
            :is-read-only="!canEditInspection || (!isPlacementMode && !isAreaDrawingMode)"
            :is-placement-mode="isPlacementMode"
            :is-area-drawing-mode="isAreaDrawingMode"
            @point-click="openChecklistFor"
            @add-point="handleMapClick"
            @delete-point="handleDeleteNewPoint"
            @area-drawn="handleAreaDrawn"
            @drawing-cancelled="handleDrawingCancelled"
          />
        </main>
      </div>
    </div>
    
    <div v-else class="flex-1 flex items-center justify-center text-red-500">No se encontraron datos v√°lidos para esta inspecci√≥n.</div>

    <ChecklistModal 
      v-if="isModalOpen"
      :is-open="isModalOpen" 
      :punto="selectedPunto"
      :inspeccion-id="inspeccionId"
      :initial-incidencias="incidenciasDelPuntoSeleccionado"
      :available-custom-fields="allCustomFields"
      :existing-identifiers-in-sala="existingIdentifiersInSala"
      @close="isModalOpen = false" 
      @save="refreshInspectedPoints"
      @update-nomenclatura="handleUpdatePointNomenclatura"
      @update:incidencias="handleIncidenciasUpdate"
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/InspeccionDetailView.vue ---

--- INICIO DEL ARCHIVO: src/views/DashboardView.vue ---
<!-- src/views/DashboardView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
import { 
  BuildingStorefrontIcon, 
  ClockIcon,
  PaperAirplaneIcon,
  CheckBadgeIcon,
  ArchiveBoxIcon
} from '@heroicons/vue/24/outline';
import { Line } from 'vue-chartjs';
import { Chart as ChartJS, Title, Tooltip, Legend, LineElement, PointElement, CategoryScale, LinearScale } from 'chart.js';
import SkeletonLoader from '../components/SkeletonLoader.vue';

ChartJS.register(Title, Tooltip, Legend, LineElement, PointElement, CategoryScale, LinearScale);

const loading = ref(true);
const centros = ref([]);
const resumenInspecciones = ref([]);
const router = useRouter();

// Modal states
const showModal = ref(false);
const selectedStatus = ref(null);

const statusLabels = {
  centros: 'Centros',
  en_progreso: 'En Progreso',
  pendientes_envio: 'Pendientes de Env√≠o',
  pendientes_cierre: 'Pendientes de Cierre',
  cerradas: 'Cerradas'
};

// ===== INICIO DE LA CORRECCI√ìN: Funci√≥n robusta para parsear fechas =====
function parseDate(dateString) {
  if (!dateString) return null;
  // A√±adimos 'T00:00:00' para asegurar que se interprete como la medianoche en la zona horaria local,
  // evitando problemas de desplazamiento de un d√≠a.
  return new Date(`${dateString}T00:00:00`);
}
// ===== FIN DE LA CORRECCI√ìN =====


onMounted(async () => {
  loading.value = true;
  const [centrosRes, resumenRes] = await Promise.all([
    supabase.from('centros').select('id, nombre'),
    supabase.from('vista_resumen_inspecciones').select('*')
  ]);
  
  centros.value = centrosRes.data || [];
  
  // ===== INICIO DE LA CORRECCI√ìN: Procesamos las fechas al recibir los datos =====
  if (resumenRes.data) {
    resumenInspecciones.value = resumenRes.data.map(inspeccion => ({
      ...inspeccion,
      fecha_inspeccion_obj: parseDate(inspeccion.fecha_inspeccion),
      fecha_envio_cliente_obj: parseDate(inspeccion.fecha_envio_cliente),
    }));
  } else {
    resumenInspecciones.value = [];
  }
  // ===== FIN DE LA CORRECCI√ìN =====
  
  loading.value = false;
});

const totalCentros = computed(() => centros.value.length);
const inspeccionesEnProgreso = computed(() => resumenInspecciones.value.filter(i => i.estado === 'en_progreso').length);
const inspeccionesPendientesEnvio = computed(() => resumenInspecciones.value.filter(i => i.estado === 'finalizada').length);
const inspeccionesPendientesCierre = computed(() => resumenInspecciones.value.filter(i => i.estado === 'pendiente_subsanacion').length);
const inspeccionesCerradas = computed(() => resumenInspecciones.value.filter(i => i.estado === 'cerrada').length);


const actividadMensual = computed(() => {
    const meses = {};
    const hoy = new Date();
    
    for (let i = 11; i >= 0; i--) {
        const d = new Date(hoy.getFullYear(), hoy.getMonth() - i, 1);
        const clave = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`; // 'YYYY-MM'
        const etiqueta = d.toLocaleString('es-ES', { month: 'short', year: '2-digit' });
        meses[clave] = { etiqueta, iniciales: 0, cierres: 0 };
    }
    
    // ===== INICIO DE LA CORRECCI√ìN: Usamos las fechas ya procesadas =====
    resumenInspecciones.value.forEach(inspeccion => {
        if (inspeccion.fecha_inspeccion_obj) {
            const fecha = inspeccion.fecha_inspeccion_obj;
            const claveMesInicial = `${fecha.getFullYear()}-${String(fecha.getMonth() + 1).padStart(2, '0')}`;
            if (meses[claveMesInicial]) {
                meses[claveMesInicial].iniciales++;
            }
        }
        
        if (inspeccion.estado === 'cerrada' && inspeccion.fecha_envio_cliente_obj) {
             const fecha = inspeccion.fecha_envio_cliente_obj;
             const claveMesCierre = `${fecha.getFullYear()}-${String(fecha.getMonth() + 1).padStart(2, '0')}`;
             if (meses[claveMesCierre]) {
                meses[claveMesCierre].cierres++;
            }
        }
    });
    // ===== FIN DE LA CORRECCI√ìN =====
    
    return Object.values(meses);
});

const monthlyChartData = computed(() => ({
  labels: actividadMensual.value.map(m => m.etiqueta),
  datasets: [
    { 
      label: 'Informes Iniciales', 
      backgroundColor: '#3B82F6', 
      borderColor: '#3B82F6', 
      data: actividadMensual.value.map(m => m.iniciales), 
      tension: 0.2 
    },
    { 
      label: 'Informes de Cierre', 
      backgroundColor: '#22C55E', 
      borderColor: '#22C55E', 
      data: actividadMensual.value.map(m => m.cierres), 
      tension: 0.2 
    }
  ]
}));

const monthlyChartOptions = {
  responsive: true, maintainAspectRatio: false,
  plugins: { legend: { position: 'top' } },
  scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
};

const centrosConMasRojas = computed(() => {
  const centrosConteo = {};
  resumenInspecciones.value.filter(i => i.incidencias_rojas > 0 && i.estado !== 'cerrada').forEach(i => {
    if (!centrosConteo[i.centro_id]) centrosConteo[i.centro_id] = { id: i.centro_id, nombre: i.centro_nombre, rojas: 0 };
    centrosConteo[i.centro_id].rojas += i.incidencias_rojas;
  });
  return Object.values(centrosConteo).sort((a, b) => b.rojas - a.rojas).slice(0, 5);
});

const accionesPendientes = computed(() => {
    return resumenInspecciones.value
        .filter(i => i.estado === 'finalizada')
        // Usamos la fecha procesada para ordenar
        .sort((a, b) => a.fecha_inspeccion_obj - b.fecha_inspeccion_obj);
});

const modalItems = computed(() => {
  if (!selectedStatus.value) return [];
  return resumenInspecciones.value.filter(i => {
    switch(selectedStatus.value) {
      case 'en_progreso': return i.estado === 'en_progreso';
      case 'pendientes_envio': return i.estado === 'finalizada';
      case 'pendientes_cierre': return i.estado === 'pendiente_subsanacion';
      default: return false;
    }
  });
});

const openModal = (status) => {
  selectedStatus.value = status;
  showModal.value = true;
};

const closeModal = () => {
  showModal.value = false;
  selectedStatus.value = null;
};
</script>

<template>
  <div class="h-full overflow-y-auto p-4 sm:p-8 bg-slate-50">
    <h1 class="text-3xl md:text-4xl font-bold text-slate-800 mb-6">Cuadro de Mando</h1>
    
    <div v-if="loading" class="space-y-6">
      <!-- Skeleton for Stats -->
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        <div v-for="i in 5" :key="i" class="bg-white p-4 rounded-xl shadow-sm border border-slate-200 h-24"><SkeletonLoader/></div>
      </div>
      <!-- Skeleton for Main Content -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-sm border border-slate-200 h-96"><SkeletonLoader/></div>
        <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-sm border border-slate-200 h-96"><SkeletonLoader/></div>
      </div>
    </div>
    
    <div v-else class="space-y-6">
      <section>
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
          <div class="bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3">
            <div class="bg-blue-100 p-3 rounded-lg"><BuildingStorefrontIcon class="h-6 w-6 text-blue-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ totalCentros }}</p><p class="text-slate-500 text-sm font-semibold">Centros</p></div>
          </div>
          <div @click="openModal('en_progreso')" class="cursor-pointer bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3 hover:shadow-md transition-shadow">
            <div class="bg-yellow-100 p-3 rounded-lg"><ClockIcon class="h-6 w-6 text-yellow-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesEnProgreso }}</p><p class="text-slate-500 text-sm font-semibold">En Progreso</p></div>
          </div>
          <div @click="openModal('pendientes_envio')" class="cursor-pointer bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3 hover:shadow-md transition-shadow">
            <div class="bg-purple-100 p-3 rounded-lg"><PaperAirplaneIcon class="h-6 w-6 text-purple-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesPendientesEnvio }}</p><p class="text-slate-500 text-sm font-semibold">Pend. Env√≠o</p></div>
          </div>
          <div @click="openModal('pendientes_cierre')" class="cursor-pointer bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3 hover:shadow-md transition-shadow">
            <div class="bg-orange-100 p-3 rounded-lg"><ArchiveBoxIcon class="h-6 w-6 text-orange-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesPendientesCierre }}</p><p class="text-slate-500 text-sm font-semibold">Pend. Cierre</p></div>
          </div>
          <div class="col-span-2 md:col-span-1 lg:col-span-1 bg-gradient-to-br from-white to-slate-50 p-4 rounded-xl shadow-sm border border-slate-200 flex items-center gap-3">
            <div class="bg-green-100 p-3 rounded-lg"><CheckBadgeIcon class="h-6 w-6 text-green-600" /></div>
            <div><p class="text-2xl font-bold text-slate-800">{{ inspeccionesCerradas }}</p><p class="text-slate-500 text-sm font-semibold">Cerradas</p></div>
          </div>
        </div>
      </section>
      
      <section class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="lg:col-span-2 bg-white p-4 sm:p-6 rounded-xl shadow-sm border border-slate-200">
           <h2 class="text-lg font-bold text-slate-800 mb-4">Actividad Mensual</h2>
           <div class="h-80">
              <Line :data="monthlyChartData" :options="monthlyChartOptions" />
           </div>
        </div>

        <div class="lg:col-span-1 bg-white p-4 sm:p-6 rounded-xl shadow-sm border border-slate-200 flex flex-col">
          <h2 class="text-lg font-bold text-slate-800 mb-4 flex-shrink-0">Puntos Cr√≠ticos Activos</h2>
          <ul v-if="centrosConMasRojas.length > 0" class="divide-y divide-slate-100">
            <li v-for="centro in centrosConMasRojas" :key="centro.id" class="py-3 flex justify-between items-center group">
              <div>
                <p class="font-semibold text-slate-800 group-hover:text-blue-600">{{ centro.nombre }}</p>
                <p class="text-sm text-slate-500 flex items-center"><span class="h-2.5 w-2.5 rounded-full bg-red-500 mr-2"></span><span class="font-bold text-red-600">{{ centro.rojas }}</span>&nbsp;incidencias graves</p>
              </div>
              <router-link :to="`/centros/${centro.id}/historial`" class="opacity-0 group-hover:opacity-100 px-3 py-1 text-sm font-semibold text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 transition-opacity">Revisar</router-link>
            </li>
          </ul>
          <div v-else class="flex-1 flex flex-col items-center justify-center text-center text-slate-500 p-4">
            <span class="text-2xl mb-2">üéâ</span><p class="font-semibold">¬°Todo en orden!</p><p class="text-sm">No hay incidencias graves activas.</p>
          </div>
        </div>
      </section>

      <section class="bg-white p-4 sm:p-6 rounded-xl shadow-sm border border-slate-200">
        <h2 class="text-lg font-bold text-slate-800 mb-4">Acciones Pendientes (Enviar a Cliente)</h2>
         <div class="overflow-x-auto">
          <table class="min-w-full divide-y divide-slate-200">
             <thead class="bg-slate-50">
              <tr>
                <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Centro</th>
                <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider hidden sm:table-cell">Fecha Finalizaci√≥n</th>
                <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider hidden md:table-cell">T√©cnico</th>
                <th class="relative px-4 py-3"><span class="sr-only">Acci√≥n</span></th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-slate-200">
              <tr v-if="accionesPendientes.length === 0">
                  <td colspan="4" class="px-4 py-8 text-center text-slate-500">No hay acciones pendientes. ¬°Buen trabajo!</td>
              </tr>
              <tr v-for="inspeccion in accionesPendientes" :key="inspeccion.inspeccion_id" class="hover:bg-slate-50">
                <td class="px-4 py-4 whitespace-nowrap font-semibold text-slate-800 text-sm">
                  {{ inspeccion.centro_nombre }}
                  <div class="sm:hidden text-xs text-slate-500 font-normal">{{ inspeccion.fecha_inspeccion_obj.toLocaleDateString('es-ES') }}</div>
                </td>
                <td class="px-4 py-4 whitespace-nowrap text-slate-600 hidden sm:table-cell text-sm">{{ inspeccion.fecha_inspeccion_obj.toLocaleDateString('es-ES') }}</td>
                <td class="px-4 py-4 whitespace-nowrap text-slate-600 hidden md:table-cell text-sm">{{ inspeccion.tecnico_nombre }}</td>
                <td class="px-4 py-4 whitespace-nowrap text-right text-sm font-medium">
                  <router-link :to="`/centros/${inspeccion.centro_id}/historial`" class="font-semibold text-purple-600 hover:text-purple-800">Gestionar</router-link>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </div>

    <!-- Modal for status details -->
    <div v-if="showModal" @click.self="closeModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 z-50">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <div class="p-6">
          <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-slate-800">{{ statusLabels[selectedStatus] }}</h3>
            <button @click="closeModal" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
          </div>

          <div>
            <div v-if="modalItems.length === 0" class="text-slate-500 text-center p-8">No hay inspecciones en este estado.</div>
            <div v-else class="overflow-x-auto">
              <table class="min-w-full divide-y divide-slate-200">
                <thead class="bg-slate-50">
                  <tr>
                    <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Centro</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Fecha Inspecci√≥n</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider hidden md:table-cell">T√©cnico</th>
                    <th class="relative px-4 py-3"><span class="sr-only">Acci√≥n</span></th>
                  </tr>
                </thead>
                <tbody class="bg-white divide-y divide-slate-200">
                  <tr v-for="inspeccion in modalItems" :key="inspeccion.inspeccion_id" class="hover:bg-slate-50">
                    <td class="px-4 py-4 whitespace-nowrap font-semibold text-slate-800 text-sm">{{ inspeccion.centro_nombre }}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-slate-600 text-sm">{{ inspeccion.fecha_inspeccion_obj.toLocaleDateString('es-ES') }}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-slate-600 hidden md:table-cell text-sm">{{ inspeccion.tecnico_nombre }}</td>
                    <td class="px-4 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <router-link :to="`/centros/${inspeccion.centro_id}/historial`" class="font-semibold text-blue-600 hover:text-blue-800">Ver Detalles</router-link>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/DashboardView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroVersionsView.vue ---
<!-- src/views/CentroVersionsView.vue -->
<script setup>
import { ref, onMounted, inject, nextTick, onUnmounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { PlusIcon, PencilIcon, CheckCircleIcon, ArchiveBoxIcon, CheckIcon } from '@heroicons/vue/24/solid';
import { addToQueue } from '../utils/syncQueue';

const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const loading = ref(true);
const centro = ref(null);
const versiones = ref([]);
const newVersionName = ref('');

// Inline editing state
const editingVersionId = ref(null);
const tempVersionName = ref('');

// Inject notification system
const showNotification = inject('showNotification');

const fetchVersions = async () => {
  loading.value = true;
  const { data: centroData } = await supabase.from('centros').select('nombre').eq('id', centroId).single();
  centro.value = centroData;

  const { data: versionsData } = await supabase
    .from('versiones_plano')
    .select('*')
    .eq('centro_id', centroId)
    .order('fecha_creacion', { ascending: false });
  versiones.value = versionsData || [];
  loading.value = false;
};

const createNewVersion = async () => {
    if (!newVersionName.value.trim()) {
        alert('Por favor, introduce un nombre para la nueva versi√≥n.');
        return;
    }

    // Llamamos a una funci√≥n RPC de Supabase que se encarga de la l√≥gica de duplicaci√≥n
    // Esta funci√≥n deber√≠a:
    // 1. Poner a `false` la `es_activa` de la versi√≥n activa actual.
    // 2. Crear la nueva versi√≥n con `es_activa = true`.
    // 3. Duplicar las salas y puntos de la versi√≥n anterior a la nueva.
    // 4. Devolver el ID de la nueva versi√≥n.
    const { data, error } = await supabase.rpc('crear_nueva_version_plano', {
        centro_id_param: centroId,
        nuevo_nombre_param: newVersionName.value.trim()
    });

    if (error) {
        alert('Error al crear la nueva versi√≥n: ' + error.message);
        console.error(error);
    } else {
        alert('Nueva versi√≥n creada con √©xito.');
        newVersionName.value = '';
        await fetchVersions();
        // Opcionalmente, redirigir directamente a la configuraci√≥n de la nueva versi√≥n
        if (data) {
           router.push(`/versiones/${data}/configurar`);
        }
    }
};

// Inline editing functions
const startEditingName = (version) => {
  editingVersionId.value = version.id;
  tempVersionName.value = version.nombre;
  nextTick(() => {
    // Find the input element by its data attribute
    const inputElement = document.querySelector(`input[data-version-id="${version.id}"]`);
    if (inputElement) {
      inputElement.focus();
      inputElement.select(); // Also select all text for easier editing
    }
  });
};

const cancelEditingName = () => {
  editingVersionId.value = null;
  tempVersionName.value = '';
};

const saveVersionName = async (versionId) => {
  const newName = tempVersionName.value.trim();

  // Validation
  if (!newName) {
    showNotification('El nombre de la versi√≥n no puede estar vac√≠o.', 'error');
    return;
  }

  if (newName.length > 100) {
    showNotification('El nombre es demasiado largo (m√°ximo 100 caracteres).', 'error');
    return;
  }

  try {
    // Use sync queue for offline support
    addToQueue({
      table: 'versiones_plano',
      type: 'update',
      id: versionId,
      payload: { nombre: newName }
    });

    // Update local state immediately
    const version = versiones.value.find(v => v.id === versionId);
    if (version) {
      version.nombre = newName;
    }

    showNotification('Nombre de versi√≥n actualizado correctamente.', 'success');
    cancelEditingName();
  } catch (error) {
    console.error('Error updating version name:', error);
    showNotification('Error al actualizar el nombre: ' + error.message, 'error');
  }
};

// Handle clicking outside to cancel edit
const handleClickOutside = (event) => {
  if (editingVersionId.value === null) {
    return; // Not editing, nothing to do
  }

  // Check if click target is the pencil button itself
  const pencilButton = event.target.closest('button[title="Editar nombre"]');
  if (pencilButton) {
    return; // Ignore clicks on the pencil button
  }

  const editContainer = document.querySelector('.version-name-edit-container');
  if (editContainer && !editContainer.contains(event.target)) {
    cancelEditingName();
  }
};

onMounted(() => {
  fetchVersions();
  document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
});
</script>

<template>
  <div class="p-8">
    <div v-if="loading">Cargando versiones...</div>
    <div v-else-if="centro">
      <div class="flex justify-between items-center mb-8">
        <div>
          <h1 class="text-4xl font-bold text-slate-800">Versiones del Plano</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <router-link to="/centros" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">
          Volver a Centros
        </router-link>
      </div>

      <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 mb-8 max-w-3xl mx-auto">
        <h2 class="text-2xl font-bold text-slate-800 mb-4">Crear Nueva Versi√≥n</h2>
        <p class="text-slate-500 mb-4">
          Crea una nueva versi√≥n para modificar el plano, a√±adir o quitar salas y puntos. Se copiar√° la configuraci√≥n de la √∫ltima versi√≥n activa.
        </p>
        <form @submit.prevent="createNewVersion" class="flex flex-col sm:flex-row gap-4">
          <input 
            v-model="newVersionName" 
            type="text" 
            placeholder="Ej: Reforma Almac√©n 2026" 
            required
            class="flex-1 block w-full rounded-md border-slate-300 shadow-sm"
          >
          <button 
            type="submit"
            class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm"
          >
            <PlusIcon class="h-5 w-5" />
            Crear Versi√≥n
          </button>
        </form>
      </div>

      <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
        <ul class="divide-y divide-slate-200">
          <li v-if="versiones.length === 0" class="p-8 text-center text-slate-500">
            No se han encontrado versiones para este centro. Crea la primera.
          </li>
          <li v-for="version in versiones" :key="version.id" class="p-4 grid grid-cols-1 md:grid-cols-4 gap-4 items-center">
            <div class="md:col-span-1">
              <!-- Editable version name -->
              <div class="flex items-center gap-2 group version-name-edit-container">
                <!-- Edit mode -->
                <div v-if="editingVersionId === version.id" class="flex items-center gap-1 flex-1">
                  <input
                    :data-version-id="version.id"
                    v-model="tempVersionName"
                    type="text"
                    @keyup.enter="saveVersionName(version.id)"
                    @keyup.esc="cancelEditingName"
                    class="font-semibold text-slate-800 text-lg px-2 py-1 border-2 border-blue-400 rounded-md focus:ring-2 focus:ring-blue-400 focus:outline-none flex-1"
                    maxlength="100"
                  />
                  <button
                    @mousedown.prevent="saveVersionName(version.id)"
                    class="p-1.5 text-green-600 hover:bg-green-100 rounded-md transition-colors"
                    title="Guardar"
                  >
                    <CheckIcon class="h-5 w-5" />
                  </button>
                </div>

                <!-- View mode -->
                <div v-else class="flex items-center gap-2 flex-1">
                  <p class="font-semibold text-slate-800 text-lg">{{ version.nombre }}</p>
                  <button
                    @click="startEditingName(version)"
                    class="p-1 text-slate-400 hover:text-blue-600 opacity-0 group-hover:opacity-100 transition-opacity"
                    title="Editar nombre"
                  >
                    <PencilIcon class="h-4 w-4" />
                  </button>
                </div>
              </div>
              <p class="text-sm text-slate-500">Creada: {{ new Date(version.fecha_creacion).toLocaleDateString() }}</p>
            </div>
            <div class="md:col-span-1">
              <span v-if="version.es_activa" class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <CheckCircleIcon class="h-4 w-4" />
                Versi√≥n Activa
              </span>
              <span v-else class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-600">
                <ArchiveBoxIcon class="h-4 w-4" />
                Archivada
              </span>
            </div>
            <div class="md:col-span-2 flex justify-end items-center gap-2">
              <router-link :to="`/versiones/${version.id}/configurar`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
                <PencilIcon class="h-4 w-4" />
                Configurar Plano
              </router-link>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroVersionsView.vue ---

--- INICIO DEL ARCHIVO: src/views/AdminView.vue ---
<!-- src/views/AdminView.vue -->
<script setup>
import { ref, onMounted, inject, computed, watch } from 'vue';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';

const showNotification = inject('showNotification');
const defaults = ref([]);
const customFields = ref([]);
const loading = ref(true);
const saving = ref(false);
const companyAssets = ref({ logo: null, signature: null });

// Modal states
const showPointModal = ref(false);
const showFieldModal = ref(false);
const editingField = ref(null);
const selectedPoint = ref(null);
const currentPointId = ref(null);
const fieldForm = ref({
  field_name: '',
  field_type: 'text',
  required: false,
  options: []
});

const gravedadOptions = [
  { label: 'Verde', value: 'verde' },
  { label: 'Ambar', value: 'ambar' },
  { label: 'Rojo', value: 'rojo' },
];

const fieldTypes = [
  { label: 'Texto', value: 'text' },
  { label: 'Selecci√≥n M√∫ltiple', value: 'select' },
  { label: 'N√∫mero', value: 'number' }
];

const pointsWithFields = computed(() => {
  const fieldsMap = new Map();
  customFields.value.forEach(field => {
    if (!fieldsMap.has(field.point_id)) fieldsMap.set(field.point_id, []);
    fieldsMap.get(field.point_id).push(field);
  });

  return defaults.value.map(point => ({
    ...point,
    fields: fieldsMap.get(point.id) || []
  }));
});

const updateDefaults = () => {
  if (selectedPoint.value) {
    const index = defaults.value.findIndex(d => d.id === selectedPoint.value.id);
    if (index !== -1) {
      defaults.value[index].default_severity = selectedPoint.value.default_severity;
    }
  }
};

watch(() => selectedPoint.value?.default_severity, (newVal, oldVal) => {
  if (newVal && newVal !== oldVal) {
    updateDefaults();
    saveDefaults();
  }
});

const loadData = async () => {
  loading.value = true;
  const [defaultsRes, fieldsRes, assetsRes] = await Promise.all([
    supabase.from('checklist_defaults').select('*').order('point_id'),
    supabase.from('checklist_custom_fields').select('*').order('point_id, id'),
    supabase.from('company_assets').select('*')
  ]);

  if (defaultsRes.error) {
    showNotification('Error al cargar gravedades: ' + defaultsRes.error.message, 'error');
  } else {
    const defaultsMap = new Map(defaultsRes.data.map(d => [d.point_id, d]));
    defaults.value = checklistItems.map(item => ({
      ...item,
      default_severity: defaultsMap.get(item.id)?.default_severity || 'ambar'
    }));
  }

  if (fieldsRes.error) {
    showNotification('Error al cargar campos personalizados: ' + fieldsRes.error.message, 'error');
  } else {
    customFields.value = fieldsRes.data;
  }

  if (assetsRes.error) {
    console.error('Error loading assets:', assetsRes.error);
  } else {
    const assetsMap = new Map(assetsRes.data.map(a => [a.asset_type, a.url]));
    companyAssets.value = {
      logo: assetsMap.get('header_logo'),
      signature: assetsMap.get('signature_logo')
    };
  }

  loading.value = false;
};

const validateFile = (file, maxSize, allowedTypes) => {
  if (!file) return 'No se seleccion√≥ archivo';
  if (file.size > maxSize) return `Archivo demasiado grande (m√°x. ${maxSize / 1024}KB)`;
  if (!allowedTypes.includes(file.type)) return `Tipo de archivo no permitido (${allowedTypes.join(', ')})`;
  return null;
};

const handleLogoUpload = async (event) => {
  const file = event.target.files[0];
  const error = validateFile(file, 500 * 1024, ['image/png', 'image/jpeg', 'image/svg+xml']);
  if (error) {
    showNotification(error, 'error');
    return;
  }

  const fileName = `logo_${Date.now()}.${file.name.split('.').pop()}`;
  const { error: uploadError } = await supabase.storage.from('logos').upload(fileName, file);
  if (uploadError) {
    showNotification('Error al subir logo: ' + uploadError.message, 'error');
    return;
  }

  const { data: { publicUrl } } = supabase.storage.from('logos').getPublicUrl(fileName);
  const { error: dbError } = await supabase.from('company_assets').upsert({ asset_type: 'header_logo', url: publicUrl });
  if (dbError) {
    showNotification('Error al guardar logo: ' + dbError.message, 'error');
  } else {
    companyAssets.value.logo = publicUrl;
    showNotification('Logo actualizado correctamente', 'success');
  }
};

const handleSignatureUpload = async (event) => {
  const file = event.target.files[0];
  const error = validateFile(file, 200 * 1024, ['image/png', 'image/jpeg']);
  if (error) {
    showNotification(error, 'error');
    return;
  }

  const fileName = `signature_${Date.now()}.${file.name.split('.').pop()}`;
  const { error: uploadError } = await supabase.storage.from('logos').upload(fileName, file);
  if (uploadError) {
    showNotification('Error al subir firma: ' + uploadError.message, 'error');
    return;
  }

  const { data: { publicUrl } } = supabase.storage.from('logos').getPublicUrl(fileName);
  const { error: dbError } = await supabase.from('company_assets').upsert({ asset_type: 'signature_logo', url: publicUrl });
  if (dbError) {
    showNotification('Error al guardar firma: ' + dbError.message, 'error');
  } else {
    companyAssets.value.signature = publicUrl;
    showNotification('Firma actualizada correctamente', 'success');
  }
};

const saveDefaults = async () => {
  saving.value = true;
  const updates = defaults.value.map(item => ({
    point_id: item.id,
    default_severity: item.default_severity
  }));

  const { error } = await supabase
    .from('checklist_defaults')
    .upsert(updates, { onConflict: 'point_id' });

  if (error) {
    showNotification('Error al guardar gravedades: ' + error.message, 'error');
  } else {
    showNotification('Gravedades guardadas correctamente.', 'success');
  }
  saving.value = false;
};

const openPointModal = (point) => {
  selectedPoint.value = { ...point };
  showPointModal.value = true;
};

const closePointModal = () => {
  showPointModal.value = false;
  selectedPoint.value = null;
};

const openFieldModal = (pointId, field = null) => {
  currentPointId.value = pointId;
  editingField.value = field;
  if (field) {
    fieldForm.value = { ...field };
  } else {
    fieldForm.value = { field_name: '', field_type: 'text', required: false, options: [] };
  }
  showFieldModal.value = true;
};

const closeFieldModal = () => {
  showFieldModal.value = false;
  editingField.value = null;
  currentPointId.value = null;
};

const saveField = async () => {
  if (!fieldForm.value.field_name.trim()) {
    showNotification('El nombre del campo es obligatorio.', 'warning');
    return;
  }

  const fieldData = {
    point_id: currentPointId.value,
    ...fieldForm.value,
    options: fieldForm.value.field_type === 'select' ? fieldForm.value.options : []
  };

  const { error } = editingField.value
    ? await supabase.from('checklist_custom_fields').update(fieldData).eq('id', editingField.value.id)
    : await supabase.from('checklist_custom_fields').insert(fieldData);

  if (error) {
    showNotification('Error al guardar campo: ' + error.message, 'error');
  } else {
    showNotification('Campo guardado correctamente.', 'success');
    await loadData();
    // Update selectedPoint fields
    if (selectedPoint.value) {
      selectedPoint.value.fields = customFields.value.filter(f => f.point_id === selectedPoint.value.id);
    }
    closeFieldModal();
  }
};

const deleteField = async (fieldId) => {
  const { error } = await supabase.from('checklist_custom_fields').delete().eq('id', fieldId);
  if (error) {
    showNotification('Error al eliminar campo: ' + error.message, 'error');
  } else {
    showNotification('Campo eliminado.', 'success');
    await loadData();
    // Update selectedPoint fields
    if (selectedPoint.value) {
      selectedPoint.value.fields = customFields.value.filter(f => f.point_id === selectedPoint.value.id);
    }
  }
};

const addOption = () => {
  fieldForm.value.options.push('');
};

const removeOption = (index) => {
  fieldForm.value.options.splice(index, 1);
};

onMounted(loadData);
</script>

<template>
  <div class="p-8">
    <h1 class="text-4xl font-bold text-slate-800 mb-8">Administraci√≥n de Checklist</h1>

    <div v-if="loading" class="text-center p-10">Cargando configuraciones...</div>
    <div v-else class="space-y-8">
      <!-- Configuraci√≥n de Logos y Firmas -->
      <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
        <h2 class="text-xl font-semibold text-slate-800 mb-4">Configuraci√≥n de Logos y Firmas</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Logo de ARSEL -->
          <div class="border border-slate-200 rounded-lg p-4">
            <h3 class="font-medium text-slate-800 mb-3">Logo de ARSEL</h3>
            <div class="mb-4">
              <img v-if="companyAssets.logo" :src="companyAssets.logo" alt="Logo ARSEL" class="max-w-full h-16 object-contain border border-slate-300 rounded">
              <div v-else class="w-full h-16 border-2 border-dashed border-slate-300 rounded flex items-center justify-center text-slate-500">
                No hay logo configurado
              </div>
            </div>
            <input type="file" ref="logoInput" @change="handleLogoUpload" accept="image/png,image/jpeg,image/svg+xml" class="hidden">
            <button @click="$refs.logoInput.click()" class="w-full px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
              Cambiar Logo
            </button>
          </div>

          <!-- Firma de ARSEL -->
          <div class="border border-slate-200 rounded-lg p-4">
            <h3 class="font-medium text-slate-800 mb-3">Firma de ARSEL</h3>
            <div class="mb-4">
              <img v-if="companyAssets.signature" :src="companyAssets.signature" alt="Firma ARSEL" class="max-w-full h-16 object-contain border border-slate-300 rounded">
              <div v-else class="w-full h-16 border-2 border-dashed border-slate-300 rounded flex items-center justify-center text-slate-500">
                No hay firma configurada
              </div>
            </div>
            <input type="file" ref="signatureInput" @change="handleSignatureUpload" accept="image/png,image/jpeg" class="hidden">
            <button @click="$refs.signatureInput.click()" class="w-full px-4 py-2 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
              Cambiar Firma
            </button>
          </div>
        </div>
      </div>

      <!-- Lista de Puntos del Checklist -->
      <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
        <h2 class="text-xl font-semibold text-slate-800 mb-4">Puntos del Checklist</h2>
        <div class="space-y-3">
          <div
            v-for="point in pointsWithFields"
            :key="point.id"
            @click="openPointModal(point)"
            class="flex items-center justify-between p-4 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition-colors"
          >
            <div class="flex items-center gap-4">
              <div class="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-sm"
                   :class="{
                     'bg-green-500': point.default_severity === 'verde',
                     'bg-amber-500': point.default_severity === 'ambar',
                     'bg-red-500': point.default_severity === 'rojo'
                   }">
                {{ point.id }}
              </div>
              <div>
                <p class="font-medium text-slate-800">{{ point.text }}</p>
                <p class="text-sm text-slate-600">{{ point.fields.length }} campos personalizados</p>
              </div>
            </div>
            <div class="text-right">
              <p class="text-xs text-slate-500">Gravedad predeterminada</p>
              <p class="font-medium" :class="{
                'text-green-600': point.default_severity === 'verde',
                'text-amber-600': point.default_severity === 'ambar',
                'text-red-600': point.default_severity === 'rojo'
              }">
                {{ gravedadOptions.find(o => o.value === point.default_severity)?.label }}
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Bot√≥n de Guardar -->
      <div class="text-center">
        <button
          @click="saveDefaults"
          :disabled="saving"
          class="px-8 py-3 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-slate-400"
        >
          {{ saving ? 'Guardando...' : 'Guardar Todos los Cambios' }}
        </button>
      </div>
    </div>

    <!-- Modal para gestionar punto -->
    <div v-if="showPointModal" @click.self="closePointModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 z-50">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div class="p-6">
          <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-slate-800">
              Punto {{ selectedPoint?.id }}: {{ selectedPoint?.text }}
            </h3>
            <button @click="closePointModal" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
          </div>

          <!-- Gravedad Predeterminada -->
          <div class="mb-6">
            <h4 class="text-lg font-semibold text-slate-800 mb-3">Gravedad Predeterminada</h4>
            <select
              v-model="selectedPoint.default_severity"
              class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
              <option v-for="opt in gravedadOptions" :key="opt.value" :value="opt.value">
                {{ opt.label }}
              </option>
            </select>
          </div>

          <!-- Campos Personalizados -->
          <div>
            <div class="flex justify-between items-center mb-4">
              <h4 class="text-lg font-semibold text-slate-800">Campos Personalizados</h4>
              <button
                @click="openFieldModal(selectedPoint.id)"
                class="px-4 py-2 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700"
              >
                Agregar Campo
              </button>
            </div>

            <div v-if="selectedPoint.fields.length === 0" class="text-slate-500 text-sm p-4 bg-slate-50 rounded-md">
              No hay campos personalizados configurados para este punto.
            </div>
            <div v-else class="space-y-3">
              <div v-for="field in selectedPoint.fields" :key="field.id" class="flex justify-between items-center p-4 bg-slate-50 rounded-md">
                <div>
                  <p class="font-medium text-slate-800">{{ field.field_name }}</p>
                  <p class="text-sm text-slate-600">
                    {{ fieldTypes.find(t => t.value === field.field_type)?.label }}
                    {{ field.required ? '(Obligatorio)' : '(Opcional)' }}
                  </p>
                </div>
                <div class="flex gap-2">
                  <button @click="openFieldModal(selectedPoint.id, field)" class="px-3 py-1 text-sm text-blue-600 hover:bg-blue-100 rounded">Editar</button>
                  <button @click="deleteField(field.id)" class="px-3 py-1 text-sm text-red-600 hover:bg-red-100 rounded">Eliminar</button>
                </div>
              </div>
            </div>
          </div>

          <div class="flex justify-end gap-3 mt-6 pt-6 border-t">
            <button @click="closePointModal" class="px-4 py-2 text-slate-700 bg-slate-100 rounded-md hover:bg-slate-200">Cerrar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal para editar campos -->
    <div v-if="showFieldModal" @click.self="closeFieldModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4 z-50">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
        <div class="p-6">
          <h3 class="text-lg font-bold text-slate-800 mb-4">{{ editingField ? 'Editar Campo' : 'Nuevo Campo' }}</h3>

          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-1">Nombre del Campo</label>
              <input
                v-model="fieldForm.field_name"
                type="text"
                class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                placeholder="Ej: Bastidor, Larguero..."
              >
            </div>

            <div>
              <label class="block text-sm font-medium text-slate-700 mb-1">Tipo de Campo</label>
              <select
                v-model="fieldForm.field_type"
                class="w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              >
                <option v-for="type in fieldTypes" :key="type.value" :value="type.value">
                  {{ type.label }}
                </option>
              </select>
            </div>

            <div v-if="fieldForm.field_type === 'select'" class="space-y-2">
              <label class="block text-sm font-medium text-slate-700">Opciones</label>
              <div v-for="(option, index) in fieldForm.options" :key="index" class="flex gap-2">
                <input
                  v-model="fieldForm.options[index]"
                  type="text"
                  class="flex-1 rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  placeholder="Opci√≥n..."
                >
                <button @click="removeOption(index)" class="px-2 py-1 text-red-600 hover:bg-red-100 rounded">√ó</button>
              </div>
              <button @click="addOption" class="text-sm text-blue-600 hover:underline">+ Agregar Opci√≥n</button>
            </div>

            <div class="flex items-center">
              <input
                v-model="fieldForm.required"
                type="checkbox"
                class="rounded border-slate-300 text-blue-600 focus:ring-blue-500"
              >
              <label class="ml-2 text-sm text-slate-700">Campo obligatorio</label>
            </div>
          </div>

          <div class="flex justify-end gap-3 mt-6">
            <button @click="closeFieldModal" class="px-4 py-2 text-slate-700 bg-slate-100 rounded-md hover:bg-slate-200">Cancelar</button>
            <button @click="saveField" class="px-4 py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/AdminView.vue ---

--- INICIO DEL ARCHIVO: src/views/PlanoPreviewView.vue ---
<!-- src/views/PlanoPreviewView.vue -->
<script setup>
import { ref, onMounted, nextTick } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { fetchReportData } from '../utils/pdf/pdf-data';
import { calculatePlanoLayout } from '../utils/plano-layout';
import { generatePlanPdf } from '../utils/pdf';
import PlanoBadge from '../components/PlanoBadge.vue';
import { ArrowDownTrayIcon, ArrowUturnLeftIcon, ArrowPathIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const layoutReady = ref(false);
const errorState = ref(null);
const reportData = ref(null);
const labels = ref([]);
const planoContainer = ref(null);
const mapDimensions = ref({ x: 0, y: 0, width: 1, height: 1 });
const isGenerating = ref(false);

const draggedLabel = ref(null);
const dragOffset = ref({ x: 0, y: 0 });

const BADGE_WIDTH_RATIO = 0.04; // El ancho del badge ser√° el 4% del ancho del plano
const BADGE_ASPECT_RATIO = 45 / 55; // Altura / Ancho

const loadData = async () => {
  reportData.value = await fetchReportData(inspeccionId, { optimizePlan: false });

  if (!reportData.value || !reportData.value.planoBase64) {
    errorState.value = "No se pudieron cargar los datos o el plano de la inspecci√≥n.";
    loading.value = false;
    return;
  }
  loading.value = false;
  await nextTick();
  prepareLayout();
};

onMounted(loadData);

const prepareLayout = () => {
  const containerEl = planoContainer.value;
  if (!containerEl) {
    errorState.value = "Error: El contenedor del plano no se encontr√≥ en el DOM.";
    return;
  }
  
  const img = new Image();
  img.onload = () => {
    const containerRatio = containerEl.clientWidth / containerEl.clientHeight;
    const imageRatio = img.width / img.height;
    let imgW, imgH, imgX, imgY;

    if (imageRatio > containerRatio) {
      imgW = containerEl.clientWidth;
      imgH = imgW / imageRatio;
      imgX = 0;
      imgY = (containerEl.clientHeight - imgH) / 2;
    } else {
      imgH = containerEl.clientHeight;
      imgW = imgH * imageRatio;
      imgY = 0;
      imgX = (containerEl.clientWidth - imgW) / 2;
    }
    mapDimensions.value = { x: imgX, y: imgY, width: imgW, height: imgH };

    const allPoints = reportData.value.puntosInspeccionadosData.map(punto => {
      const maestro = reportData.value.puntosMaestrosData.find(pm => pm.id === punto.punto_maestro_id);
      if (!maestro) return null;
      return {
        ...punto,
        nomenclatura: maestro.nomenclatura,
        // Coordenadas relativas (0 a 1) respecto al plano
        relativeX: punto.coordenada_x,
        relativeY: punto.coordenada_y,
        counts: reportData.value.incidenceCounts.get(punto.id) || { verde: 0, ambar: 0, rojo: 0 }
      };
    }).filter(Boolean);
    
    // El layout ahora trabaja con coordenadas relativas
    labels.value = calculatePlanoLayout(allPoints, { width: img.width, height: img.height }, BADGE_WIDTH_RATIO);
    layoutReady.value = true;
  };
  
  img.onerror = () => { errorState.value = "No se pudo cargar la imagen del plano."; }
  img.src = reportData.value.planoBase64;
};

const handleGeneratePdf = async () => {
    isGenerating.value = true;
    try {
      const img = new Image();
      img.src = reportData.value.planoBase64;
      await new Promise(resolve => img.onload = resolve);

      const originalDimensions = {
          width: img.width,
          height: img.height
      };
      // Pasamos las etiquetas con coordenadas relativas y las dimensiones originales
      await generatePlanPdf(inspeccionId, labels.value, originalDimensions);
    } catch (error) {
        console.error("Error al generar el PDF del plano:", error);
        alert("Hubo un error al generar el plano. Revisa la consola.");
    } finally {
        isGenerating.value = false;
    }
};

const onMouseDown = (label, event) => {
  draggedLabel.value = label;
  const containerRect = planoContainer.value.getBoundingClientRect();
  const badgeWidthPx = mapDimensions.value.width * BADGE_WIDTH_RATIO;
  const badgeHeightPx = badgeWidthPx * BADGE_ASPECT_RATIO;
  
  const currentLeftPx = label.position.x * mapDimensions.value.width + mapDimensions.value.x - (badgeWidthPx / 2);
  const currentTopPx = label.position.y * mapDimensions.value.height + mapDimensions.value.y - (badgeHeightPx / 2);
  
  dragOffset.value = {
    x: event.clientX - containerRect.left - currentLeftPx,
    y: event.clientY - containerRect.top - currentTopPx
  };
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
};

const onMouseMove = (event) => {
  if (!draggedLabel.value) return;
  const containerRect = planoContainer.value.getBoundingClientRect();
  const badgeWidthPx = mapDimensions.value.width * BADGE_WIDTH_RATIO;
  const badgeHeightPx = badgeWidthPx * BADGE_ASPECT_RATIO;

  const newLeftPx = event.clientX - containerRect.left - dragOffset.value.x;
  const newTopPx = event.clientY - containerRect.top - dragOffset.value.y;
  
  draggedLabel.value.position.x = (newLeftPx + (badgeWidthPx / 2) - mapDimensions.value.x) / mapDimensions.value.width;
  draggedLabel.value.position.y = (newTopPx + (badgeHeightPx / 2) - mapDimensions.value.y) / mapDimensions.value.height;
};

const onMouseUp = () => {
  draggedLabel.value = null;
  window.removeEventListener('mousemove', onMouseMove);
  window.removeEventListener('mouseup', onMouseUp);
};
</script>

<template>
  <div class="h-screen w-screen bg-slate-800 flex flex-col">
    <header class="w-full bg-white shadow-md p-3 flex justify-between items-center z-20 flex-shrink-0">
      <div class="text-slate-700">
        <h1 class="font-bold">Editor de Plano</h1>
        <p v-if="reportData" class="text-sm text-slate-500">{{ reportData.inspectionData.centros.nombre }}</p>
      </div>
      <div class="flex items-center gap-4">
        <button @click="router.go(-1)" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <ArrowUturnLeftIcon class="h-4 w-4" /> Volver
        </button>
        <button @click="prepareLayout" :disabled="loading" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold bg-white border border-slate-300 rounded-md hover:bg-slate-50 disabled:opacity-50">
          <ArrowPathIcon class="h-4 w-4" /> Actualizar
        </button>
        <button @click="handleGeneratePdf" :disabled="isGenerating || !layoutReady" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-slate-400">
          <ArrowDownTrayIcon class="h-4 w-4" />
          {{ isGenerating ? 'Generando...' : 'Generar PDF' }}
        </button>
      </div>
    </header>

    <main class="flex-1 p-4 overflow-hidden">
      <div v-if="loading" class="h-full w-full flex items-center justify-center text-white">Cargando previsualizaci√≥n...</div>
      <div v-else-if="errorState" class="h-full w-full flex items-center justify-center text-red-300 bg-red-900/50 p-4 text-center rounded-md">{{ errorState }}</div>
      
      <div v-else ref="planoContainer" class="relative h-full w-full bg-white select-none">
        
        <img
          :src="reportData.planoBase64"
          class="absolute pointer-events-none"
          :style="{ 
            left: `${mapDimensions.x}px`, top: `${mapDimensions.y}px`,
            width: `${mapDimensions.width}px`, height: `${mapDimensions.height}px`
          }"
        >
        
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
          <g v-for="label in labels" :key="'line-' + label.pointData.id">
            <line
              :x1="label.pointData.relativeX * mapDimensions.width + mapDimensions.x"
              :y1="label.pointData.relativeY * mapDimensions.height + mapDimensions.y"
              :x2="label.position.x * mapDimensions.width + mapDimensions.x"
              :y2="label.position.y * mapDimensions.height + mapDimensions.y"
              stroke="#94a3b8"
              stroke-width="1"
            />
          </g>
        </svg>
        
        <div
          v-for="label in labels"
          :key="'badge-' + label.pointData.id"
          v-show="layoutReady"
          @mousedown.prevent="onMouseDown(label, $event)"
          class="z-20 absolute"
          :style="{
            width: `${mapDimensions.width * BADGE_WIDTH_RATIO}px`,
            height: `${mapDimensions.width * BADGE_WIDTH_RATIO * BADGE_ASPECT_RATIO}px`,
            left: `${label.position.x * mapDimensions.width + mapDimensions.x - (mapDimensions.width * BADGE_WIDTH_RATIO / 2)}px`,
            top: `${label.position.y * mapDimensions.height + mapDimensions.y - (mapDimensions.width * BADGE_WIDTH_RATIO * BADGE_ASPECT_RATIO / 2)}px`,
          }"
        >
            <PlanoBadge :pointData="label.pointData" />
        </div>
      </div>
    </main>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/PlanoPreviewView.vue ---

--- INICIO DEL ARCHIVO: src/views/InspeccionesListView.vue ---
<!-- src/views/InspeccionesListView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRouter } from 'vue-router';
import { supabase } from '../supabase';

const router = useRouter();
const showNotification = inject('showNotification');
const centros = ref([]);
const loading = ref(true);
const isStarting = ref(false);
const searchTerm = ref('');
const tecnicoNombre = ref('');
const fechaInspeccion = ref(new Date().toISOString().slice(0, 10));

const filteredCentros = computed(() => {
  if (!searchTerm.value) return centros.value;
  return centros.value.filter(centro =>
    centro.nombre.toLowerCase().includes(searchTerm.value.toLowerCase())
  );
});

// === INICIO DE LA L√ìGICA CORREGIDA ===
const startInspection = async (centroId) => {
  if (!tecnicoNombre.value.trim()) {
    showNotification('Por favor, introduce el nombre del t√©cnico para continuar.', 'warning');
    return;
  }
  if (!fechaInspeccion.value) {
    showNotification('Por favor, selecciona una fecha de inspecci√≥n.', 'warning');
    return;
  }
  const today = new Date().toISOString().slice(0, 10);
  if (fechaInspeccion.value > today) {
    showNotification('La fecha de inspecci√≥n no puede ser futura.', 'warning');
    return;
  }
  isStarting.value = true;

  // 1. Buscar la VERSI√ìN ACTIVA para el centro seleccionado.
  const { data: activeVersion, error: versionError } = await supabase
    .from('versiones_plano')
    .select('id')
    .eq('centro_id', centroId)
    .eq('es_activa', true)
    .single();

  if (versionError || !activeVersion) {
    showNotification('Error: Este centro no tiene una versi√≥n de plano activa. Por favor, config√∫ralo en el Maestro de Centros.', 'error');
    console.error("Error buscando versi√≥n activa:", versionError);
    isStarting.value = false;
    return;
  }
  const versionId = activeVersion.id;

  // 2. Buscar si ya existe una inspecci√≥n en progreso para este centro
  let { data: inspection, error: findError } = await supabase
    .from('inspecciones')
    .select('id')
    .eq('centro_id', centroId)
    .eq('estado', 'en_progreso')
    .maybeSingle();

  if (findError) {
    showNotification('Error buscando inspecci√≥n existente: ' + findError.message, 'error');
    isStarting.value = false;
    return;
  }

  // 3. Si no existe, crear una nueva asoci√°ndola a la versi√≥n activa
  if (!inspection) {
    const { data: newInspection, error: createError } = await supabase
      .from('inspecciones')
      .insert({
        centro_id: centroId,
        version_id: versionId, // <-- Guardamos la versi√≥n correcta
        estado: 'en_progreso',
        tecnico_nombre: tecnicoNombre.value.trim(),
        fecha_inspeccion: fechaInspeccion.value
      })
      .select('id')
      .single();

    if (createError) {
      showNotification('Error creando inspecci√≥n: ' + createError.message, 'error');
      isStarting.value = false;
      return;
    }
    inspection = newInspection;
  } else {
    // Si ya exist√≠a, la actualizamos para asegurarnos de que usa la √∫ltima versi√≥n activa
     await supabase.from('inspecciones').update({
       tecnico_nombre: tecnicoNombre.value.trim(),
       fecha_inspeccion: fechaInspeccion.value,
       version_id: versionId // <-- Actualizamos tambi√©n la versi√≥n
     }).eq('id', inspection.id);
  }

  // 4. Navegar a la p√°gina de detalle
  router.push(`/inspecciones/${inspection.id}`);
};
// === FIN DE LA L√ìGICA CORREGIDA ===

onMounted(async () => {
  loading.value = true;
  const { data } = await supabase.from('centros').select('id, nombre').order('nombre');
  if (data) centros.value = data;
  loading.value = false;
});
</script>

<template>
  <div class="p-8">
    <h1 class="text-4xl font-bold text-slate-800 mb-8">Iniciar Inspecci√≥n</h1>
    <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 max-w-3xl mx-auto">
      
      <div class="mb-6">
        <label for="tecnico" class="block text-sm font-medium text-slate-700 mb-1">Nombre del T√©cnico</label>
        <input
          v-model="tecnicoNombre"
          id="tecnico"
          type="text"
          placeholder="Escribe tu nombre..."
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>

      <div class="mb-6">
        <label for="fecha" class="block text-sm font-medium text-slate-700 mb-1">Fecha de Inspecci√≥n</label>
        <input
          v-model="fechaInspeccion"
          id="fecha"
          type="date"
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>

      <div>
        <label for="search" class="block text-sm font-medium text-slate-700 mb-1">Buscar y Seleccionar Centro</label>
        <input 
          v-model="searchTerm" 
          id="search" 
          type="search" 
          placeholder="Escribe para buscar un centro..." 
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>
      
      <div class="mt-4 max-h-60 overflow-y-auto border rounded-md">
        <div v-if="loading" class="p-4 text-center text-slate-500">Cargando centros...</div>
        <ul v-else-if="filteredCentros.length > 0">
          <li v-for="centro in filteredCentros" :key="centro.id" class="border-b last:border-b-0">
            <button 
              @click="startInspection(centro.id)" 
              :disabled="isStarting"
              class="w-full text-left p-4 hover:bg-blue-50 transition-colors disabled:bg-slate-100 disabled:cursor-wait"
            >
              {{ centro.nombre }}
            </button>
          </li>
        </ul>
        <div v-else class="p-4 text-center text-slate-500">No se encontraron centros.</div>
      </div>

    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/InspeccionesListView.vue ---

--- INICIO DEL ARCHIVO: src/views/GestionView.vue ---
<!-- src/views/GestionView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
import SkeletonLoader from '../components/SkeletonLoader.vue';
import GrupoVisitaEditable from '../components/GrupoVisitaEditable.vue';
// ===== CAMBIO 1: Importamos la nueva funci√≥n para generar Excel =====
import { generateGestionExcel } from '../utils/excel/excel-module-gestion';
import { ArrowPathIcon, MagnifyingGlassIcon, ArrowDownTrayIcon } from '@heroicons/vue/24/solid';

const showNotification = inject('showNotification');
const router = useRouter();

const loading = ref(true);
const refreshing = ref(false);
const isGeneratingExcel = ref(false); // Renombramos la variable de estado
const resumenData = ref([]);
const searchTerm = ref('');

const filteredData = computed(() => {
  if (!searchTerm.value) {
    return resumenData.value;
  }
  const searchLower = searchTerm.value.toLowerCase();
  return resumenData.value.filter(item => 
    item.centro_nombre.toLowerCase().includes(searchLower)
  );
});

const estadoInfo = (estado) => {
  switch (estado) {
    case 'en_progreso': return { text: 'En Progreso', class: 'bg-blue-100 text-blue-800' };
    case 'finalizada': return { text: 'Pend. Env√≠o', class: 'bg-orange-100 text-orange-800' };
    case 'pendiente_subsanacion': return { text: 'Pend. Cierre', class: 'bg-yellow-100 text-yellow-800' };
    case 'cerrada': return { text: 'Cerrada', class: 'bg-green-100 text-green-800' };
    default: return { text: 'Sin Inspecci√≥n', class: 'bg-slate-100 text-slate-600' };
  }
};

const fetchData = async () => {
  const { data, error } = await supabase
    .from('vista_gestion_centros')
    .select('*');
  
  if (error) {
    showNotification(`Error al cargar los datos: ${error.message}`, 'error');
    console.error(error);
    return [];
  }
  return data;
};

const refreshView = async () => {
  refreshing.value = true;
  const { error: rpcError } = await supabase.rpc('refrescar_vista_gestion');
  if (rpcError) {
    showNotification(`Error al refrescar los datos: ${rpcError.message}`, 'error');
  } else {
    resumenData.value = await fetchData();
    showNotification('Datos actualizados correctamente.', 'success');
  }
  refreshing.value = false;
};

const handleSaveGrupo = async ({ inspeccionId, newValue }) => {
  const { error } = await supabase
    .from('inspecciones')
    .update({ grupo_visita: newValue })
    .eq('id', inspeccionId);

  if (error) {
    showNotification('Error al guardar el grupo: ' + error.message, 'error');
  } else {
    const item = resumenData.value.find(i => i.inspeccion_id === inspeccionId);
    if (item) item.grupo_visita = newValue;
    showNotification('Grupo de visita guardado.', 'success', 2000);
  }
};

// ===== CAMBIO 2: La funci√≥n ahora llama al generador de Excel =====
const handleDownloadExcel = async () => {
  isGeneratingExcel.value = true;
  showNotification('Generando archivo XLSX, por favor espera...', 'info');
  try {
    await generateGestionExcel(filteredData.value);
  } catch (error) {
    showNotification('Hubo un error al generar el archivo Excel.', 'error');
  } finally {
    isGeneratingExcel.value = false;
  }
};

onMounted(async () => {
  loading.value = true;
  resumenData.value = await fetchData();
  loading.value = false;
});

</script>

<template>
  <div class="p-4 md:p-8">
    <div class="flex flex-col md:flex-row justify-between md:items-center mb-6 gap-4">
      <h1 class="text-3xl md:text-4xl font-bold text-slate-800">Panel de Gesti√≥n Anual</h1>
      
      <div class="flex items-center gap-x-2 w-full md:w-auto">
        <div class="relative flex-grow">
          <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
            <MagnifyingGlassIcon class="h-5 w-5 text-slate-400" />
          </div>
          <input 
            v-model="searchTerm"
            type="search"
            placeholder="Buscar centro..."
            class="block w-full rounded-md border-slate-300 py-2 pl-10 text-sm shadow-sm focus:border-blue-500 focus:ring-blue-500"
          >
        </div>
        <button @click="refreshView" :disabled="refreshing || isGeneratingExcel" class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm flex-shrink-0 disabled:bg-slate-400">
          <ArrowPathIcon class="h-5 w-5" :class="{'animate-spin': refreshing}" />
          <span class="hidden sm:inline">Actualizar</span>
        </button>
        <!-- ===== CAMBIO 3: El bot√≥n ahora llama a la funci√≥n de Excel y tiene un texto m√°s claro ===== -->
        <button @click="handleDownloadExcel" :disabled="refreshing || isGeneratingExcel" class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 shadow-sm flex-shrink-0 disabled:bg-slate-400">
          <ArrowDownTrayIcon class="h-5 w-5" />
          <span class="hidden sm:inline">Descargar XLSX</span>
        </button>
      </div>

    </div>

    <div v-if="loading" class="space-y-2">
      <div v-for="i in 10" :key="i" class="bg-white rounded-lg shadow-sm border border-slate-200 h-16"><SkeletonLoader/></div>
    </div>

    <div v-else class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-x-auto">
      <table class="min-w-full divide-y divide-slate-200 text-sm">
        <thead class="bg-slate-50">
          <tr>
            <th class="sticky left-0 bg-slate-50 px-4 py-3 text-left font-semibold text-slate-600">Centro</th>
            <th class="px-4 py-3 text-left font-semibold text-slate-600">Regi√≥n</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">√öltima Inspecci√≥n</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Grupo Visita</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Estado Informe</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Cambios Alineaciones</th>
            <th class="px-4 py-3 text-center font-semibold text-slate-600">Faltan Fichas</th>
            <th colspan="3" class="px-4 py-3 text-center font-semibold text-slate-600 border-l border-r">Da√±os</th>
            <th class="px-4 py-3 text-left font-semibold text-slate-600"></th>
          </tr>
          <tr class="bg-slate-100">
             <th colspan="7"></th>
             <th class="w-16 text-center font-medium text-xs text-green-700 bg-green-100 py-1">V</th>
             <th class="w-16 text-center font-medium text-xs text-amber-700 bg-amber-100 py-1">A</th>
             <th class="w-16 text-center font-medium text-xs text-red-700 bg-red-100 py-1 border-r">R</th>
             <th></th>
          </tr>
        </thead>
        <tbody class="divide-y divide-slate-200">
          <tr v-for="item in filteredData" :key="item.centro_id" class="hover:bg-slate-50">
            <td class="sticky left-0 bg-white hover:bg-slate-50 px-4 py-3 font-semibold text-slate-800 whitespace-nowrap">
              <router-link :to="`/centros/${item.centro_id}/historial`" class="hover:underline text-blue-700">
                {{ item.centro_nombre }}
              </router-link>
            </td>
            <td class="px-4 py-3 text-slate-600 whitespace-nowrap">{{ item.region }}</td>
            <td class="px-4 py-3 text-center text-slate-600 whitespace-nowrap">
              {{ item.fecha_inspeccion ? new Date(item.fecha_inspeccion + 'T00:00:00').toLocaleDateString() : '-' }}
            </td>
            <td class="px-4 py-3 text-center text-slate-800">
              <GrupoVisitaEditable :value="item.grupo_visita" :inspeccion-id="item.inspeccion_id" @save="handleSaveGrupo" />
            </td>
            <td class="px-4 py-3 text-center">
              <span :class="['inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium', estadoInfo(item.estado_informe).class]">
                {{ estadoInfo(item.estado_informe).text }}
              </span>
            </td>
            <td class="px-4 py-3 text-center font-medium text-slate-800">{{ item.cambios_en_alineaciones }}</td>
            <td class="px-4 py-3 text-center font-medium" :class="item.faltan_fichas ? 'text-red-600' : 'text-slate-800'">
              {{ item.faltan_fichas ? 'SI' : 'NO' }}
            </td>
            <td class="px-4 py-3 text-center font-bold text-green-600 bg-green-50/50">{{ item.danos_verdes }}</td>
            <td class="px-4 py-3 text-center font-bold text-amber-600 bg-amber-50/50">{{ item.danos_ambares }}</td>
            <td class="px-4 py-3 text-center font-bold text-red-600 bg-red-50/50 border-r">{{ item.danos_rojos }}</td>
            <td class="px-4 py-3 text-center">
              <router-link :to="`/centros/${item.centro_id}/historial`" class="font-semibold text-blue-600 hover:text-blue-800">
                Ver
              </router-link>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/GestionView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroConfigView.vue ---
<!-- src/views/CentroConfigView.vue -->
<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import { ArrowPathIcon, ArrowUpTrayIcon, PlusIcon, TrashIcon, MapIcon, XCircleIcon, PencilIcon, CheckCircleIcon, InformationCircleIcon, BackspaceIcon } from '@heroicons/vue/24/solid';
import NomenclatureModal from '../components/NomenclatureModal.vue';

const route = useRoute();
const router = useRouter();
const versionId = route.params.id;

const loading = ref(true);
const version = ref(null);
const centro = ref(null);
const puntos = ref([]);
const salas = ref([]);
const activeSalaId = ref(null);
const newSalaName = ref('');
const fileInput = ref(null);

const isDrawingMode = ref(false);
const isPointEditingMode = ref(false);
const isSavingArea = ref(false);
const channel = ref(null);
const activeSala = computed(() => salas.value.find(s => s.id === activeSalaId.value));

const isNomenclatureModalOpen = ref(false);
const newPointCoords = ref(null);

const existingIdentifiersInActiveSala = computed(() => {
    if (!activeSalaId.value) return [];
    return puntos.value
        .filter(p => p.sala_id === activeSalaId.value)
        .map(p => p.nomenclatura.split('-').pop() || '');
});

// --- INICIO DE LA CORRECCI√ìN: L√≥gica de sugerencia de n√∫mero robusta ---
const suggestedNextNumber = computed(() => {
    if (!activeSalaId.value) return 1;

    // 1. Filtramos los identificadores para quedarnos solo con aquellos
    //    que son representaciones de n√∫meros enteros puros.
    const numericIdentifiers = existingIdentifiersInActiveSala.value
        .filter(id => {
            const num = parseInt(id, 10);
            // La condici√≥n clave: un identificador es puramente num√©rico si al convertirlo a n√∫mero
            // y luego de vuelta a string, es id√©ntico al original.
            // "1" -> parseInt -> 1 -> String -> "1". ('1' === '1') -> true.
            // "1,2" -> parseInt -> 1 -> String -> "1". ('1' === '1,2') -> false.
            // "Picking" -> parseInt -> NaN. -> false.
            return !isNaN(num) && String(num) === id;
        })
        // 2. Convertimos los strings validados a n√∫meros reales.
        .map(id => parseInt(id, 10));

    if (numericIdentifiers.length === 0) return 1;

    // 3. El resto de la l√≥gica para encontrar el siguiente n√∫mero disponible funciona perfectamente.
    const sortedNumbers = [...numericIdentifiers].sort((a, b) => a - b);
    
    for (let i = 0; i < sortedNumbers.length; i++) {
        if (sortedNumbers[i] !== i + 1) {
            return i + 1;
        }
    }
    return sortedNumbers.length + 1;
});
// --- FIN DE LA CORRECCI√ìN ---


const instructionText = computed(() => {
    if (isDrawingMode.value) {
        const salaName = activeSala.value?.nombre || 'la sala';
        return `Definiendo √°rea para "${salaName}": Haz clic para a√±adir puntos. Haz clic en el primer punto para cerrar la forma.`;
    }
    if (isPointEditingMode.value) {
        const salaName = activeSala.value?.nombre || 'NINGUNA';
        return `Modo Edici√≥n de Puntos: Haz clic en el plano para a√±adir puntos en la sala "${salaName.toUpperCase()}".`;
    }
    return null;
});

onMounted(async () => {
  loading.value = true;
  const { data: versionData } = await supabase.from('versiones_plano').select('*, centros(*)').eq('id', versionId).single();
  if (!versionData) {
    alert("Error: No se pudo cargar la versi√≥n del plano o no existe.");
    loading.value = false; return;
  }
  version.value = versionData;
  centro.value = versionData.centros;
  const [salasRes, puntosRes] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', versionId).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', versionId)
  ]);
  salas.value = salasRes.data || [];
  puntos.value = puntosRes.data || [];
  if (salas.value.length > 0 && !activeSalaId.value) {
      activeSalaId.value = salas.value[0].id;
  }
  loading.value = false;

  // Suscripci√≥n en tiempo real
  channel.value = supabase.channel(`version-${versionId}`)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'salas', filter: `version_id=eq.${versionId}` }, (payload) => {
      if (payload.eventType === 'INSERT') {
        salas.value.push(payload.new);
        salas.value.sort((a, b) => a.nombre.localeCompare(b.nombre));
      } else if (payload.eventType === 'UPDATE') {
        const index = salas.value.findIndex(s => s.id === payload.new.id);
        if (index !== -1) salas.value[index] = payload.new;
      } else if (payload.eventType === 'DELETE') {
        salas.value = salas.value.filter(s => s.id !== payload.old.id);
        if (activeSalaId.value === payload.old.id) {
          activeSalaId.value = salas.value.length > 0 ? salas.value[0].id : null;
        }
      }
    })
    .on('postgres_changes', { event: '*', schema: 'public', table: 'puntos_maestros', filter: `version_id=eq.${versionId}` }, (payload) => {
      if (payload.eventType === 'INSERT') {
        puntos.value.push(payload.new);
      } else if (payload.eventType === 'UPDATE') {
        const index = puntos.value.findIndex(p => p.id === payload.new.id);
        if (index !== -1) puntos.value[index] = payload.new;
      } else if (payload.eventType === 'DELETE') {
        puntos.value = puntos.value.filter(p => p.id !== payload.old.id);
      }
    })
    .subscribe();
});

onUnmounted(() => {
  if (channel.value) {
    channel.value.unsubscribe();
  }
});

const togglePointEditingMode = () => {
    if (!isPointEditingMode.value && !activeSalaId.value) {
        alert('Por favor, selecciona primero una sala para empezar a editar sus puntos.');
        return;
    }
    isPointEditingMode.value = !isPointEditingMode.value;
    isDrawingMode.value = false;
};

const cancelAllModes = () => {
    isDrawingMode.value = false;
    isPointEditingMode.value = false;
};

const onFileSelected = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const fileName = `planos/centro_${centro.value.id}/version_${versionId}/${Date.now()}_${file.name}`;
    
    const { error: uploadError } = await supabase.storage.from('planos-clientes').upload(fileName, file, { upsert: true });
    if (uploadError) {
      alert("Error al subir el plano: " + uploadError.message);
      return;
    }
    const { data: { publicUrl } } = supabase.storage.from('planos-clientes').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('versiones_plano').update({ url_imagen_plano: publicUrl }).eq('id', versionId);
    if(updateError) {
        alert("Error al guardar la URL del plano: " + updateError.message);
    } else {
        version.value.url_imagen_plano = publicUrl;
        alert("Plano actualizado correctamente.");
    }
};


const enterDrawingMode = () => {
  if (!activeSalaId.value) { 
    alert("Selecciona una sala para poder definir su √°rea."); 
    return; 
  }
  isDrawingMode.value = true;
  isPointEditingMode.value = false;
};

const handleAreaDrawn = async (points) => {
    console.log('Area drawn for sala', activeSalaId.value, 'points:', points);
    if (!activeSalaId.value) return;
    isSavingArea.value = true;
    try {
        console.log('Updating sala', activeSalaId.value, 'with points', points);
        const { error } = await supabase.from('salas').update({ area_puntos: points }).eq('id', activeSalaId.value);
        if (error) throw error;
        console.log('Area saved successfully');
        const sala = salas.value.find(s => s.id === activeSalaId.value);
        if (sala) sala.area_puntos = points;
        isDrawingMode.value = false;
    } catch (error) {
        console.error('Error saving area:', error);
        alert('Error al guardar el √°rea: ' + error.message);
    } finally {
        isSavingArea.value = false;
    }
};

const clearArea = async () => {
    if (!activeSalaId.value) return;
    const { error } = await supabase.from('salas').update({ area_puntos: null }).eq('id', activeSalaId.value);
    if (error) {
        alert('Error al limpiar el √°rea: ' + error.message);
    } else {
        const sala = salas.value.find(s => s.id === activeSalaId.value);
        if (sala) sala.area_puntos = null;
    }
};


const handleMapClick = (coords) => {
  if (isPointEditingMode.value) {
    newPointCoords.value = coords;
    isNomenclatureModalOpen.value = true;
  }
};

const handleSaveNomenclature = async (pointIdentifier) => {
  isNomenclatureModalOpen.value = false;
  const coords = newPointCoords.value;
  if (!coords || !activeSalaId.value) return;

  const sala = salas.value.find(s => s.id === activeSalaId.value);
  const newNomenclature = `${sala.nombre}-${pointIdentifier}`;

  const { data, error } = await supabase.from('puntos_maestros').insert({ 
    version_id: versionId, 
    sala_id: activeSalaId.value, 
    nomenclatura: newNomenclature, 
    coordenada_x: coords.x, 
    coordenada_y: coords.y
  }).select().single();
  
  if (data) {
    puntos.value.push(data);
  } else if (error) {
    alert(error.message);
  }
  newPointCoords.value = null;
};

const handleDeletePoint = async (point) => {
    if (confirm(`¬øEst√°s seguro de que quieres borrar el punto "${point.nomenclatura}" de este plano?`)) {
        const { error } = await supabase.from('puntos_maestros').delete().eq('id', point.id);
        if (error) {
            alert('Error al borrar el punto: ' + error.message);
        } else {
            puntos.value = puntos.value.filter(p => p.id !== point.id);
        }
    }
};

const addSala = async () => {
  const name = newSalaName.value.trim();
  if (!name) {
    alert('El nombre de la sala no puede estar vac√≠o.');
    return;
  }
  
  const nameExists = salas.value.some(s => s.nombre.toLowerCase() === name.toLowerCase());
  if (nameExists) {
    alert(`La sala "${name}" ya existe en esta versi√≥n del plano.`);
    return;
  }

  const { data: newSala, error } = await supabase
    .from('salas')
    .insert({
      version_id: versionId,
      nombre: name,
      color: '#CCCCCC' // Un color gris por defecto
    })
    .select()
    .single();

  if (error) {
    alert('Error al crear la nueva sala: ' + error.message);
  } else {
    salas.value.push(newSala);
    salas.value.sort((a, b) => a.nombre.localeCompare(b.nombre)); // Mantener el orden alfab√©tico
    newSalaName.value = ''; // Limpiar el input
  }
};

const deleteSala = async (salaId) => {
  const sala = salas.value.find(s => s.id === salaId);
  if (!sala) return;
  
  const puntosEnSala = puntos.value.filter(p => p.sala_id === salaId).length;
  if (puntosEnSala > 0) {
    alert(`No se puede borrar la sala "${sala.nombre}" porque contiene ${puntosEnSala} puntos. B√≥rralos primero.`);
    return;
  }

  if (confirm(`¬øEst√°s seguro de que quieres borrar la sala "${sala.nombre}"? Esta acci√≥n no se puede deshacer.`)) {
    const { error } = await supabase.from('salas').delete().eq('id', salaId);

    if (error) {
      alert('Error al borrar la sala: ' + error.message);
    } else {
      salas.value = salas.value.filter(s => s.id !== salaId);
      if (activeSalaId.value === salaId) {
        activeSalaId.value = salas.value.length > 0 ? salas.value[0].id : null;
      }
    }
  }
};

const handleUpdatePosition = async (point) => {
  const { error } = await supabase
    .from('puntos_maestros')
    .update({ 
        coordenada_x: point.coordenada_x, 
        coordenada_y: point.coordenada_y 
    })
    .eq('id', point.id);

  if (error) {
    alert('Error al actualizar la posici√≥n del punto: ' + error.message);
    // Opcional: recargar los datos para revertir el cambio visual
    // fetchData(); 
  }
};

const saveSalaColor = async (sala) => {
  await supabase.from('salas').update({ color: sala.color }).eq('id', sala.id);
};
</script>


<template>
  <div class="p-4 sm:p-8 h-full flex flex-col">
    <input type="file" @change="onFileSelected" accept="image/*" class="hidden" ref="fileInput">
    <div v-if="loading" class="flex justify-center items-center h-full">Cargando...</div>
    <div v-else-if="centro && version" class="flex-1 flex flex-col">
      <div v-if="version.url_imagen_plano" class="flex-1 flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-start mb-6 gap-4">
          <div>
            <h1 class="text-3xl font-bold text-slate-800">Configurar: {{ centro.nombre }}</h1>
            <p class="text-slate-600 mt-2">
              Editando versi√≥n: <strong class="text-blue-600">{{ version.nombre }}</strong> 
              <span v-if="version.es_activa" class="ml-2 text-xs font-bold text-green-700 bg-green-100 px-2 py-0.5 rounded-full">ACTIVA</span>
              <span v-else class="ml-2 text-xs font-bold text-slate-700 bg-slate-100 px-2 py-0.5 rounded-full">ARCHIVADA</span>
            </p>
          </div>
          <div class="flex gap-2 flex-shrink-0">
             <button @click="fileInput.click()" class="flex items-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <ArrowPathIcon class="h-5 w-5" /> Cambiar Plano
             </button>
             <button v-if="isDrawingMode || isPointEditingMode" @click="cancelAllModes" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
                <XCircleIcon class="h-5 w-5" /> Cancelar
             </button>
            <button @click="router.push(`/centros/${centro.id}/versiones`)" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">Volver a Versiones</button>
          </div>
        </div>
        
        <div class="flex-grow h-full grid grid-cols-1 lg:grid-cols-4 gap-8">
          <div class="lg:col-span-1 lg:sticky lg:top-8 self-start bg-white rounded-xl shadow-sm border border-slate-200 p-4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-slate-800">Salas</h2>
                <button 
                    @click="togglePointEditingMode" 
                    :disabled="salas.length === 0"
                    :class="[
                        'flex items-center gap-1.5 px-2.5 py-1 text-xs font-semibold text-white rounded-md transition-colors',
                        'disabled:bg-slate-400 disabled:cursor-not-allowed',
                        isPointEditingMode ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'
                    ]">
                    <component :is="isPointEditingMode ? CheckCircleIcon : PencilIcon" class="h-4 w-4" />
                    {{ isPointEditingMode ? 'Finalizar Edici√≥n' : 'Gestionar Puntos' }}
                </button>
            </div>
            <ul class="space-y-2">
              <li v-for="sala in salas" :key="sala.id">
                <div @click="activeSalaId = sala.id" :class="['w-full p-3 rounded-lg transition-colors flex justify-between items-center group cursor-pointer', activeSalaId === sala.id ? 'bg-blue-100 ring-2 ring-blue-300' : 'hover:bg-slate-100']">
                  <div class="flex items-center gap-3">
                    <input type="color" v-model="sala.color" @input="saveSalaColor(sala)" class="w-6 h-6 p-0 border-none rounded-md cursor-pointer flex-shrink-0">
                    <span class="font-semibold" :class="{'text-blue-800': activeSalaId === sala.id}">{{ sala.nombre }}</span>
                  </div>
                </div>
                <div v-if="activeSalaId === sala.id" class="pl-10 pt-1 pb-2 flex items-center space-x-4">
                    <button @click="enterDrawingMode" :disabled="isPointEditingMode || isSavingArea" class="flex items-center gap-1.5 text-xs text-blue-600 hover:text-blue-800 disabled:text-slate-400 disabled:cursor-not-allowed">
                       <MapIcon class="h-4 w-4" /> <span>Definir √Årea</span>
                     </button>
                     <button v-if="sala.area_puntos" @click="clearArea" :disabled="isPointEditingMode || isSavingArea" class="flex items-center gap-1.5 text-xs text-red-600 hover:text-red-800 disabled:text-slate-400 disabled:cursor-not-allowed">
                        <XCircleIcon class="h-4 w-4" /> <span>Limpiar</span>
                     </button>
                     <button @click="deleteSala(sala.id)" :disabled="isPointEditingMode || isSavingArea" class="flex items-center gap-1.5 text-xs text-slate-500 hover:text-red-600 disabled:text-slate-400 disabled:cursor-not-allowed">
                        <TrashIcon class="h-4 w-4" /> <span>Borrar</span>
                     </button>
                 </div>
              </li>
            </ul>
            <form @submit.prevent="addSala" class="mt-4 flex-shrink-0 flex gap-2">
              <input v-model="newSalaName" type="text" placeholder="Nueva sala..." class="flex-1 block w-full rounded-md border-slate-300 shadow-sm text-sm">
              <button type="submit" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                <PlusIcon class="h-5 w-5" />
              </button>
            </form>
          </div>
          
          <div class="lg:col-span-3 relative">
            <div v-if="instructionText" class="bg-blue-600 text-white text-sm font-semibold py-2 px-4 flex items-center gap-2 mb-4">
              <InformationCircleIcon class="h-5 w-5 flex-shrink-0" />
              <span>{{ instructionText }}</span>
            </div>
            <InteractiveMap
              class="h-full"
              :image-url="version.url_imagen_plano"
              :points="puntos"
              :salas="salas"
              :is-read-only="!isPointEditingMode && !isDrawingMode"
              :is-placement-mode="isPointEditingMode"
              :is-area-drawing-mode="isDrawingMode"
              @add-point="handleMapClick"
              @delete-point="handleDeletePoint"
              @update-point-position="handleUpdatePosition"
              @area-drawn="handleAreaDrawn"
              @drawing-cancelled="cancelAllModes"
            />
          </div>
        </div>
      </div>
      
      <div v-else class="flex-1 flex flex-col items-center justify-center">
         <div class="max-w-3xl mx-auto text-center">
          <h1 class="text-3xl font-bold text-slate-800">Se necesita un plano para esta versi√≥n</h1>
          <p class="text-slate-600 mt-4 text-lg">La versi√≥n <strong class="text-blue-600">{{ version.nombre }}</strong> no tiene un plano asignado.</p>
        </div>
        <div class="mt-8 max-w-lg w-full mx-auto bg-white p-8 rounded-lg shadow-md border">
          <button @click="fileInput.click()" class="w-full flex flex-col items-center justify-center gap-4 p-6 border-2 border-dashed border-slate-300 rounded-lg hover:bg-slate-50 transition-colors">
            <ArrowUpTrayIcon class="h-10 w-10 text-slate-400" />
            <span class="text-slate-500 font-medium">Haz clic aqu√≠ para seleccionar un archivo</span>
          </button>
        </div>
        <div class="text-center mt-8">
          <button @click="router.push(`/centros/${centro.id}/versiones`)" class="font-semibold text-slate-600 hover:text-slate-800">Volver a Versiones</button>
        </div>
      </div>
    </div>

    <NomenclatureModal
      :is-open="isNomenclatureModalOpen"
      :sala-nombre="activeSala?.nombre"
      :suggested-number="suggestedNextNumber"
      :existing-identifiers="existingIdentifiersInActiveSala"
      @close="isNomenclatureModalOpen = false"
      @save="handleSaveNomenclature"
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroConfigView.vue ---

--- INICIO DEL ARCHIVO: src/composables/useOnlineStatus.js ---
// src/composables/useOnlineStatus.js
import { ref, onMounted, onUnmounted } from 'vue';

export function useOnlineStatus() {
  const isOnline = ref(navigator.onLine);

  const updateOnlineStatus = () => {
    isOnline.value = navigator.onLine;
  };

  onMounted(() => {
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
  });

  onUnmounted(() => {
    window.removeEventListener('online', updateOnlineStatus);
    window.removeEventListener('offline', updateOnlineStatus);
  });

  return { isOnline };
}
--- FIN DEL ARCHIVO: src/composables/useOnlineStatus.js ---

--- INICIO DEL ARCHIVO: src/composables/useInspections.js ---
// src/composables/useInspections.js

import { ref, onMounted, onUnmounted, readonly } from 'vue';
import { supabase } from '../supabase';
import { createLogger } from '../utils/logger';

const logger = createLogger('Inspections');

// Web Worker for processing inspection details
const createProcessingWorker = () => {
  const workerCode = `
    self.onmessage = function(e) {
      const { puntosData } = e.data;

      const salasMap = new Map();
      const salaCountsMap = new Map();

      puntosData.forEach(punto => {
        const salaId = punto.puntos_maestros?.sala_id;
        const salaNombre = punto.puntos_maestros?.salas?.nombre;
        if (salaId && salaNombre) {
          if (!salasMap.has(salaId)) {
            salasMap.set(salaId, { id: salaId, nombre: salaNombre, puntos: [] });
            salaCountsMap.set(salaId, { verde: 0, ambar: 0, rojo: 0 });
          }
          const counts = { verde: 0, ambar: 0, rojo: 0 };
          (punto.incidencias || []).forEach(inc => {
            if (counts[inc.gravedad] !== undefined) counts[inc.gravedad]++;
          });
          salasMap.get(salaId).puntos.push({ ...punto, counts });
          const salaCounts = salaCountsMap.get(salaId);
          salaCounts.verde += counts.verde;
          salaCounts.ambar += counts.ambar;
          salaCounts.rojo += counts.rojo;
        }
      });

      const salasConPuntos = Array.from(salasMap.values()).map(sala => ({
        ...sala,
        puntos: sala.puntos.sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true})),
        counts: salaCountsMap.get(sala.id)
      })).filter(s => s.puntos.length > 0);

      self.postMessage({ salasConPuntos });
    };
  `;

  const blob = new Blob([workerCode], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
};

export function useInspections(centroId) {
  const loading = ref(true);
  const loadingMore = ref(false);
  const centro = ref(null);
  const inspecciones = ref([]);
  const realtimeSubscription = ref(null);
  const availableYears = ref([]);
  
  const pageSize = 20;
  const currentPage = ref(1);
  const totalInspecciones = ref(0);
  const hasMorePages = ref(false);

  const CACHE_KEY = `inspections_${centroId}`;
  const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  const getCachedData = () => {
    try {
      const cached = localStorage.getItem(CACHE_KEY);
      if (cached) {
        const { data, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp < CACHE_DURATION) return data;
      }
    } catch (error) { logger.warn('Error reading cache:', error); }
    return null;
  };

  const setCachedData = (data) => {
    try {
      const cacheData = { data, timestamp: Date.now() };
      localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
    } catch (error) { logger.warn('Error writing cache:', error); }
  };

  const fetchData = async (page = 1, append = false, silent = false) => {
    if (!append && !silent) loading.value = true;
    else if (append && !silent) loadingMore.value = true;

    if (page === 1 && !append) {
      const cachedData = getCachedData();
      if (cachedData) {
        centro.value = cachedData.centro;
        inspecciones.value = cachedData.inspecciones;
        totalInspecciones.value = cachedData.totalInspecciones;
        availableYears.value = cachedData.availableYears;
        hasMorePages.value = cachedData.hasMorePages;
        loading.value = false;
        return;
      }
    }

    const [centroRes, countRes] = await Promise.all([
      supabase.from('centros').select('nombre').eq('id', centroId).single(),
      supabase.from('inspecciones').select('id', { count: 'exact', head: true }).eq('centro_id', centroId)
    ]);

    centro.value = centroRes.data;
    totalInspecciones.value = countRes.count || 0;

    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    const { data: inspeccionesData } = await supabase
      .from('inspecciones')
      .select('id, fecha_inspeccion, estado, tecnico_nombre, centro_id, fecha_envio_cliente, responsable_envio_cliente, url_pdf_informe_inicial, url_pdf_informe_final, versiones_plano(id, nombre)')
      .eq('centro_id', centroId)
      .order('fecha_inspeccion', { ascending: false })
      .range(from, to);

    if (!inspeccionesData) {
      if (!append) inspecciones.value = [];
      loading.value = false;
      loadingMore.value = false;
      return;
    }

    const inspectionIds = inspeccionesData.map(i => i.id);
    const countsMap = new Map();
    inspectionIds.forEach(id => countsMap.set(id, { verde: 0, ambar: 0, rojo: 0 }));

    if (inspectionIds.length > 0) {
      const { data: countsData } = await supabase.from('incidencias').select('inspeccion_id, gravedad').in('inspeccion_id', inspectionIds);
      if (countsData) {
        countsData.forEach(inc => {
          const counts = countsMap.get(inc.inspeccion_id);
          if (counts && counts[inc.gravedad] !== undefined) counts[inc.gravedad]++;
        });
      }
    }

    const processedInspections = inspeccionesData.map(inspeccion => ({
      ...inspeccion,
      details: [],
      totalCounts: countsMap.get(inspeccion.id) || { verde: 0, ambar: 0, rojo: 0 }
    }));

    if (append) inspecciones.value.push(...processedInspections);
    else inspecciones.value = processedInspections;
    
    hasMorePages.value = (page * pageSize) < totalInspecciones.value;
    
    if (inspecciones.value.length > 0) {
      const years = new Set(inspecciones.value.map(i => new Date(i.fecha_inspeccion).getFullYear()));
      availableYears.value = Array.from(years).sort((a, b) => b - a);
    }

    if (page === 1 && !append) {
      setCachedData({ centro: centro.value, inspecciones: inspecciones.value, totalInspecciones: totalInspecciones.value, availableYears: availableYears.value, hasMorePages: hasMorePages.value });
    }

    if (!silent) {
      loading.value = false;
      loadingMore.value = false;
    }
  };

  const loadInspectionDetails = async (inspeccionId) => {
    const inspeccion = inspecciones.value.find(i => i.id === inspeccionId);
    if (!inspeccion || (inspeccion.details && inspeccion.details.length > 0)) return;

    const { data: puntosData } = await supabase.from('puntos_inspeccionados').select('id, nomenclatura, puntos_maestros!inner(id, sala_id, salas!inner(id, nombre)), incidencias(gravedad)').eq('inspeccion_id', inspeccionId);
    if (!puntosData) return;

    const worker = createProcessingWorker();
    worker.onmessage = (e) => {
      const { salasConPuntos } = e.data;
      const index = inspecciones.value.findIndex(i => i.id === inspeccionId);
      if (index !== -1) {
        inspecciones.value[index].details = salasConPuntos;
      }
      worker.terminate();
    };
    worker.postMessage({ puntosData });
  };
  
  const loadMore = async () => {
    if (!hasMorePages.value || loadingMore.value) return;
    currentPage.value++;
    await fetchData(currentPage.value, true);
  };

  const setupRealtime = () => {
    if (realtimeSubscription.value) realtimeSubscription.value.unsubscribe();
    realtimeSubscription.value = supabase.channel(`inspections_${centroId}`)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'inspecciones', filter: `centro_id=eq.${centroId}` }, () => {
        localStorage.removeItem(CACHE_KEY);
        fetchData(currentPage.value, false, true);
      }).subscribe();
  };
  
  onMounted(async () => {
    await fetchData(1);
    setupRealtime();
  });
  
  onUnmounted(() => {
    if (realtimeSubscription.value) realtimeSubscription.value.unsubscribe();
  });

  return {
    loading: readonly(loading),
    loadingMore: readonly(loadingMore),
    centro: readonly(centro),
    inspecciones, // Return as ref for updates
    availableYears: readonly(availableYears),
    hasMorePages: readonly(hasMorePages),
    totalInspecciones: readonly(totalInspecciones),
    loadMore,
    loadInspectionDetails,
    refreshData: () => fetchData(1, false),
    updateInspectionInList: (updatedInspection) => {
      const index = inspecciones.value.findIndex(i => i.id === updatedInspection.id);
      if (index !== -1) {
        inspecciones.value[index] = { ...inspecciones.value[index], ...updatedInspection };
      }
    },
    removeInspectionFromList: (inspectionId) => {
      inspecciones.value = inspecciones.value.filter(i => i.id !== inspectionId);
      totalInspecciones.value--;
    }
  };
}
--- FIN DEL ARCHIVO: src/composables/useInspections.js ---

--- INICIO DEL ARCHIVO: src/composables/useFileUpload.js ---
// src/composables/useFileUpload.js

import { ref } from 'vue';
import { useNotification } from '../utils/notification';
import { addToQueue, FILE_STORAGE_KEY_PREFIX } from '../utils/syncQueue';
import { createLogger } from '../utils/logger';

const logger = createLogger('FileUpload');

function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = (error) => reject(error);
    reader.readAsArrayBuffer(file);
  });
}

export function useFileUpload(inspeccionId, puntoId) {
  const { showNotification } = useNotification();
  const isUploading = ref(null);

  const compressImage = (file) => {
    // ... (funci√≥n de compresi√≥n no cambia)
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => {
        let { width, height } = img;
        const maxDimension = 1024;
        if (width > height) {
          if (width > maxDimension) { height = (height * maxDimension) / width; width = maxDimension; }
        } else {
          if (height > maxDimension) { width = (width * maxDimension) / height; height = maxDimension; }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob((blob) => {
          if (blob) {
            const compressedFile = new File([blob], file.name, { type: 'image/jpeg', lastModified: Date.now() });
            resolve(compressedFile);
          } else { reject(new Error('Failed to compress image')); }
        }, 'image/jpeg', 0.6);
      };
      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = URL.createObjectURL(file);
    });
  };

  const handleFileUpload = async (file, incidencia) => {
    if (!file.type.startsWith('image/')) {
      showNotification('Solo se permiten archivos de imagen.', 'error'); return null;
    }
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      showNotification('El archivo es demasiado grande. M√°ximo 10MB.', 'error'); return null;
    }

    isUploading.value = incidencia.id;

    try {
      let fileToUpload = file;
      if (file.size > 500 * 1024) {
        showNotification('Comprimiendo imagen...', 'info');
        fileToUpload = await compressImage(file);
      }
      
      const arrayBuffer = await readFileAsArrayBuffer(fileToUpload);
      const stableBlob = new Blob([arrayBuffer], { type: fileToUpload.type });
      const stableBlobUrl = URL.createObjectURL(stableBlob);

      const fileName = `inspeccion_${inspeccionId}/punto_${puntoId}/${Date.now()}_${file.name}`;

      // addToQueue manejar√° la creaci√≥n del fileId internamente
      const queueAction = {
        type: 'uploadAndUpdate',
        bucket: 'incidencias',
        path: fileName,
        file: stableBlob,
        table: 'incidencias',
        recordId: incidencia.id,
        urlColumn: 'url_foto_antes',
      };

      await addToQueue(queueAction);

      showNotification('Foto guardada localmente.', 'success');

      // addToQueue modifica el objeto queueAction y le a√±ade el fileId
      return {
          offlinePhotoKey: queueAction.fileId, // Usamos el fileId que addToQueue cre√≥
          previewUrl: stableBlobUrl,
      };

    } catch (error) {
      logger.error('Error procesando imagen para guardado local:', error);
      showNotification('Error al procesar la imagen: ' + error.message, 'error');
      return null;
    } finally {
      isUploading.value = null;
    }
  };

  return {
    isUploading,
    handleFileUpload,
  };
}
--- FIN DEL ARCHIVO: src/composables/useFileUpload.js ---

--- INICIO DEL ARCHIVO: src/router/index.js ---
// src/router/index.js

import { createRouter, createWebHistory } from 'vue-router'
import { supabase } from '../supabase'
import { createLogger } from '../utils/logger'

const logger = createLogger('Router')

// Importaci√≥n de Vistas y Componentes
import Login from '../components/Login.vue'

const routes = [
  { path: '/', name: 'Login', component: Login, meta: { layout: 'Blank' } },
  { path: '/dashboard', name: 'Dashboard', component: () => import('../views/DashboardView.vue'), meta: { requiresAuth: true } },
  { path: '/gestion', name: 'Gestion', component: () => import('../views/GestionView.vue'), meta: { requiresAuth: true } },
  { path: '/centros', name: 'CentrosList', component: () => import('../views/CentrosListView.vue'), meta: { requiresAuth: true } },
  { path: '/centros/:id/versiones', name: 'CentroVersions', component: () => import('../views/CentroVersionsView.vue'), meta: { requiresAuth: true } },
  { path: '/versiones/:id/configurar', name: 'VersionConfig', component: () => import('../views/CentroConfigView.vue'), meta: { requiresAuth: true } },
  { path: '/inspecciones', name: 'InspeccionesList', component: () => import('../views/InspeccionesListView.vue'), meta: { requiresAuth: true } },
  { path: '/inspecciones/:id', name: 'InspeccionDetail', component: () => import('../views/InspeccionDetailView.vue'), meta: { requiresAuth: true, hideDefaultHeader: true } },
  { path: '/centros/:id/historial', name: 'CentroHistorial', component: () => import('../views/CentroHistorialView.vue'), meta: { requiresAuth: true } },
  {
    path: '/inspecciones/:id/plano-preview',
    name: 'PlanoPreview',
    component: () => import('../views/PlanoPreviewView.vue'),
    meta: { layout: 'Blank' }
  },
  {
    path: '/inspecciones/:id/cierre',
    name: 'CierreInforme',
    component: () => import('../views/CierreInformeView.vue'),
    meta: { requiresAuth: true }
  },
  { path: '/admin', name: 'Admin', component: () => import('../views/AdminView.vue'), meta: { requiresAuth: true } }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

router.beforeEach(async (to, from, next) => {
  logger.debug(`Navegando de '${from.fullPath}' a '${to.fullPath}'`);

  const { data: { session } } = await supabase.auth.getSession()
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth)

  if (requiresAuth && !session) { next({ name: 'Login' }) }
  else if (session && to.name === 'Login') { next({ name: 'Dashboard' }) }
  else { next() }
})

export default router
--- FIN DEL ARCHIVO: src/router/index.js ---

--- INICIO DEL ARCHIVO: src/layouts/BlankLayout.vue ---
<!-- src/layouts/BlankLayout.vue -->
<script setup>
import { onMounted } from 'vue';
// --- LOGS DE DEBUG ---
onMounted(() => console.log('[BlankLayout.vue] Componente montado en el DOM.'));
</script>

<template>
  <!-- 
    CORRECCI√ìN: Se elimina el div contenedor. 
    <router-view> actuar√° como el elemento ra√≠z de este layout,
    permitiendo que la p√°gina que renderiza controle su propio layout al 100%.
  -->
  <router-view />
</template>
--- FIN DEL ARCHIVO: src/layouts/BlankLayout.vue ---

--- INICIO DEL ARCHIVO: src/layouts/DefaultLayout.vue ---
<!-- src/layouts/DefaultLayout.vue -->
<script setup>
import { ref, provide } from 'vue';
import { RouterLink, useRoute } from 'vue-router';
import { HomeIcon, ListBulletIcon, DocumentMagnifyingGlassIcon, Cog6ToothIcon, Bars3Icon, TableCellsIcon } from '@heroicons/vue/24/outline';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
// --- INICIO DE LA MODIFICACI√ìN ---
import GlobalStatusIndicator from '../components/GlobalStatusIndicator.vue';
// --- FIN DE LA MODIFICACI√ìN ---

const route = useRoute();
const router = useRouter();
const isSidebarOpen = ref(false);

// Proporcionar el estado del sidebar a los componentes hijos
provide('toggleSidebar', () => { isSidebarOpen.value = true; });

const navigation = [
  { name: 'Men√∫ Principal', href: '/dashboard', icon: HomeIcon },
  { name: 'Gesti√≥n', href: '/gestion', icon: TableCellsIcon },
  { name: 'Maestro de Centros', href: '/centros', icon: ListBulletIcon },
  { name: 'Inspecciones', href: '/inspecciones', icon: DocumentMagnifyingGlassIcon },
  { name: 'Admin', href: '/admin', icon: Cog6ToothIcon },
];

const isActive = (href) => {
  return route.path === href || (href !== '/dashboard' && route.path.startsWith(href));
};

const handleLogout = async () => {
  await supabase.auth.signOut();
  router.push('/');
};
</script>
<template>
<div class="relative h-screen flex overflow-hidden bg-slate-100">
  <!-- Overlay para m√≥vil -->
  <div v-if="isSidebarOpen" @click="isSidebarOpen = false" class="fixed inset-0 bg-black bg-opacity-50 z-20 md:hidden"></div>
  
  <!-- Barra Lateral -->
  <aside 
    :class="[
      'absolute inset-y-0 left-0 w-64 bg-slate-800 flex flex-col z-30 transform transition-transform duration-300 ease-in-out md:relative md:translate-x-0',
      isSidebarOpen ? 'translate-x-0' : '-translate-x-full'
    ]"
  >
    <div class="h-16 flex-shrink-0 flex items-center justify-center">
      <h1 class="text-2xl font-bold text-white tracking-wider">Arsel</h1>
    </div>
    <nav class="flex-1 px-4 py-2 space-y-2">
        <RouterLink
          v-for="item in navigation"
          :key="item.name"
          :to="item.href"
          @click="isSidebarOpen = false"
          :class="[
            'flex items-center px-3 py-3 text-sm font-medium rounded-lg transition-colors',
            isActive(item.href)
              ? 'bg-blue-600 text-white shadow-inner'
              : 'text-slate-300 hover:bg-slate-700 hover:text-white',
          ]"
        >
          <component :is="item.icon" class="h-6 w-6 mr-3" />
          {{ item.name }}
        </RouterLink>
    </nav>
    
    <!-- --- INICIO DE LA MODIFICACI√ìN: Indicador para ESCRITORIO --- -->
    <div class="px-4 py-2 border-t border-slate-700">
      <GlobalStatusIndicator mode="desktop" />
    </div>
    <!-- --- FIN DE LA MODIFICACI√ìN --- -->

    <div class="p-4 border-t border-slate-700">
      <button @click="handleLogout" class="w-full px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
        Cerrar Sesi√≥n
      </button>
    </div>
  </aside>

  <!-- Contenido Principal -->
  <div class="flex-1 flex flex-col overflow-hidden">
      <header
        v-if="!route.meta.hideDefaultHeader"
        class="md:hidden h-16 bg-white shadow-sm flex items-center justify-between px-4 flex-shrink-0">
        <button @click="isSidebarOpen = true" class="text-slate-600">
          <Bars3Icon class="h-6 w-6" />
        </button>
        <h2 class="text-lg font-bold text-slate-800">{{ route.name }}</h2>
        <!-- --- INICIO DE LA MODIFICACI√ìN: Indicador para M√ìVIL --- -->
        <GlobalStatusIndicator mode="mobile" />
        <!-- --- FIN DE LA MODIFICACI√ìN --- -->
      </header>

      <main class="flex-1 overflow-y-auto">
        <router-view />
      </main>
    </div>
  </div>
  
  <!-- El indicador flotante de escritorio ya no es necesario aqu√≠ -->
</template>
--- FIN DEL ARCHIVO: src/layouts/DefaultLayout.vue ---

