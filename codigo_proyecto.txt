--- INICIO DEL ARCHIVO: package.json ---
{
  "name": "arsel",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "tailwind:init": "tailwindcss init -p"
  },
  "dependencies": {
    "@heroicons/vue": "^2.2.0",
    "@supabase/supabase-js": "^2.53.1",
    "chart.js": "^4.5.0",
    "html2canvas": "^1.4.1",
    "jspdf": "^3.0.1",
    "jspdf-autotable": "^5.0.2",
    "vue": "^3.5.18",
    "vue-chartjs": "^5.3.2",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "vite": "^7.1.0"
  }
}

--- FIN DEL ARCHIVO: package.json ---

--- INICIO DEL ARCHIVO: vite.config.js ---
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
  server: {
    host: true, // <-- AÑADE ESTA LÍNEA
    hmr: {
      clientPort: 443,
    }
  }
})
--- FIN DEL ARCHIVO: vite.config.js ---

--- INICIO DEL ARCHIVO: src/main.js ---
// src/main.js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router' // Importamos nuestro router

const app = createApp(App)

app.use(router) // Le decimos a la app que use el router

app.mount('#app')
--- FIN DEL ARCHIVO: src/main.js ---

--- INICIO DEL ARCHIVO: src/App.vue ---
<!-- src/App.vue -->
<script setup>
import { computed, onMounted, onUpdated, provide } from 'vue'; // Importamos 'provide'
import { useRoute } from 'vue-router';
import DefaultLayout from './layouts/DefaultLayout.vue';
import BlankLayout from './layouts/BlankLayout.vue';
import Notification from './components/Notification.vue'; // Importamos el componente
import { useNotification } from './utils/notification'; // Importamos el servicio

// --- LOGS DE DEBUG ---
onMounted(() => console.log('[App.vue] Componente montado en el DOM.'));
onUpdated(() => console.log('[App.vue] Componente actualizado (cambio de layout o ruta).'));

// --- SISTEMA DE NOTIFICACIONES ---
const { notificationShow, notificationMessage, notificationType, showNotification } = useNotification();
// Hacemos que la función 'showNotification' esté disponible para todos los componentes hijos
provide('showNotification', showNotification);
// --- FIN DEL SISTEMA DE NOTIFICACIONES ---

const route = useRoute();
const layout = computed(() => {
  const layoutName = route.meta.layout === 'Blank' ? 'BlankLayout' : 'DefaultLayout';
  console.log(`[App.vue] Layout computado es: ${layoutName}`);
  return layoutName === 'BlankLayout' ? BlankLayout : DefaultLayout;
});
</script>

<template>
  <!-- El layout se renderiza como siempre -->
  <component :is="layout" />
  
  <!-- El componente de notificación vive por encima de todo -->
  <Notification
    :show="notificationShow"
    :message="notificationMessage"
    :type="notificationType"
  />
</template>
--- FIN DEL ARCHIVO: src/App.vue ---

--- INICIO DEL ARCHIVO: src/supabase.js ---
// src/supabase.js
import { createClient } from '@supabase/supabase-js'

// Estas líneas leen las claves que pusiste en el archivo .env.local
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

// Exportamos el cliente para poder usarlo en toda la aplicación
export const supabase = createClient(supabaseUrl, supabaseAnonKey)
--- FIN DEL ARCHIVO: src/supabase.js ---

--- INICIO DEL ARCHIVO: src/style.css ---
/* src/style.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
--- FIN DEL ARCHIVO: src/style.css ---

--- INICIO DEL ARCHIVO: src/utils/notification.js ---
// src/utils/notification.js
import { ref, readonly } from 'vue';

// Estado reactivo que compartiremos en toda la app
const show = ref(false);
const message = ref('');
const type = ref('success');

// Temporizador para ocultar la notificación
let timeoutId = null;

// La función que llamaremos desde cualquier componente
export function useNotification() {
  const showNotification = (newMessage, newType = 'success', duration = 3000) => {
    message.value = newMessage;
    type.value = newType;
    show.value = true;

    // Limpiamos cualquier temporizador anterior para evitar solapamientos
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    // Ocultamos la notificación después de la duración especificada
    timeoutId = setTimeout(() => {
      show.value = false;
    }, duration);
  };

  return {
    // Exportamos los estados como `readonly` para que no se puedan modificar directamente
    notificationShow: readonly(show),
    notificationMessage: readonly(message),
    notificationType: readonly(type),
    // Exportamos la función que permite mostrar notificaciones
    showNotification,
  };
}
--- FIN DEL ARCHIVO: src/utils/notification.js ---

--- INICIO DEL ARCHIVO: src/utils/plano-layout.js ---
// src/utils/plano-layout.js

export function calculatePlanoLayout(allPointsData, mapDimensions, badgeWidth) {
    const placedObstacles = allPointsData.map(p => ({
        x: p.absX - 5, y: p.absY - 5,
        width: 10, height: 10
    }));

    const labelsToDraw = [];
    const mapCenterX = mapDimensions.x + mapDimensions.width / 2;
    const mapCenterY = mapDimensions.y + mapDimensions.height / 2;
    
    const sortedPoints = [...allPointsData].sort((a, b) => {
        const distA = Math.sqrt(Math.pow(a.absX - mapCenterX, 2) + Math.pow(a.absY - mapCenterY, 2));
        const distB = Math.sqrt(Math.pow(b.absX - mapCenterX, 2) + Math.pow(b.absY - mapCenterY, 2));
        return distA - distB;
    });

    for (const point of sortedPoints) {
        const needsBadge = point.estado !== 'existente' || point.detalle_modificacion !== null ||
            (point.counts.verde > 0 || point.counts.ambar > 0 || point.counts.rojo > 0);
        if (!needsBadge) continue;

        // --- CORRECCIÓN DE TAMAÑO ---
        // Calculamos la altura dinámicamente basándonos en un ancho fijo
        let badgeHeight = 35; // Altura base
        if (point.estado !== 'existente' || point.detalle_modificacion !== null) {
            badgeHeight += 12; // Espacio extra para el texto de estado
        }
        const badgeSize = { width: badgeWidth, height: badgeHeight };
        
        const finalPosition = findNonOverlappingPosition(point, badgeSize, placedObstacles, mapDimensions);
        const badgeRect = { x: finalPosition.x - badgeSize.width / 2, y: finalPosition.y - badgeSize.height / 2, ...badgeSize };

        placedObstacles.push(badgeRect);
        
        labelsToDraw.push({
            pointData: point,
            position: { x: finalPosition.x, y: finalPosition.y },
            size: badgeSize
        });
    }
    return labelsToDraw;
}

function findNonOverlappingPosition(point, badgeSize, obstacles, pageBounds) {
    const isOverlapping = (rect1, rect2) => {
        const margin = 5; // Más margen para que no se peguen
        return !(rect1.x > rect2.x + rect2.width + margin ||
            rect1.x + rect1.width + margin < rect2.x ||
            rect1.y > rect2.y + rect2.height + margin ||
            rect1.y + rect1.height + margin < rect2.y);
    };
    const isWithinBounds = (rect) => (
        rect.x >= pageBounds.x &&
        rect.y >= pageBounds.y &&
        rect.x + rect.width <= pageBounds.x + pageBounds.width &&
        rect.y + rect.height <= pageBounds.y + pageBounds.height
    );
    const checkPosition = (pos) => {
        const candidateRect = {
            x: pos.x - badgeSize.width / 2,
            y: pos.y - badgeSize.height / 2,
            ...badgeSize
        };
        if (isWithinBounds(candidateRect) && !obstacles.some(obs => isOverlapping(candidateRect, obs))) {
            return pos;
        }
        return null;
    };
    const preferredOffsets = [
        { x: 0, y: -(badgeSize.height / 2 + 10) }, { x: 0, y: (badgeSize.height / 2 + 10) },
        { x: (badgeSize.width / 2 + 10), y: 0 },   { x: -(badgeSize.width / 2 + 10), y: 0 }
    ];
    for (const offset of preferredOffsets) {
        const position = checkPosition({ x: point.absX + offset.x, y: point.absY + offset.y });
        if (position) return position;
    }

    let x = point.absX, y = point.absY, dx = 0, dy = -1, stepSize = 10, stepsInSegment = 1, turnCounter = 0;
    for (let i = 0; i < 1000; i++) {
        for (let j = 0; j < Math.floor(stepsInSegment); j++) {
            x += dx * stepSize;
            y += dy * stepSize;
            const position = checkPosition({ x, y });
            if (position) return position;
        }
        [dx, dy] = [-dy, dx];
        turnCounter++;
        if (turnCounter % 2 === 0) stepsInSegment += 0.5; // Espiral más densa
    }
    return { x: point.absX, y: point.absY - (badgeSize.height / 2 + 10) };
}
--- FIN DEL ARCHIVO: src/utils/plano-layout.js ---

--- INICIO DEL ARCHIVO: src/utils/provincias.js ---
// src/utils/provincias.js
export const provincias = [
  'Álava', 'Albacete', 'Alicante', 'Almería', 'Asturias', 'Ávila', 'Badajoz', 'Barcelona', 'Burgos', 'Cáceres', 
  'Cádiz', 'Cantabria', 'Castellón', 'Ciudad Real', 'Córdoba', 'La Coruña', 'Cuenca', 'Gerona', 'Granada', 'Guadalajara', 
  'Guipúzcoa', 'Huelva', 'Huesca', 'Islas Baleares', 'Jaén', 'León', 'Lérida', 'Lugo', 'Madrid', 'Málaga', 'Murcia', 
  'Navarra', 'Orense', 'Palencia', 'Las Palmas', 'Pontevedra', 'La Rioja', 'Salamanca', 'Segovia', 'Sevilla', 
  'Soria', 'Tarragona', 'Santa Cruz de Tenerife', 'Teruel', 'Toledo', 'Valencia', 'Valladolid', 'Vizcaya', 'Zamora', 'Zaragoza'
];
--- FIN DEL ARCHIVO: src/utils/provincias.js ---

--- INICIO DEL ARCHIVO: src/utils/checklist.js ---
// src/utils/checklist.js
export const checklistItems = [
  { id: 1, text: "Existe copia de la documentación de validación" },
  { id: 2, text: "Tiene las placas de identificación correctamente colocadas y son legibles." },
  { id: 3, text: "El número de módulos y niveles se corresponde con el establecido en el documento de validación." },
  { id: 4, text: "Los niveles de altura están dentro de los límites establecidos." },
  { id: 5, text: "El tipo de puntal se corresponde con el del documento de validación." },
  { id: 6, text: "La verticalidad de los puntales está dentro de los límites permitidos." },
  { id: 7, text: "Las placas base no presentan deterioro y tienen todos los tornillos de fijación previsto." },
  { id: 8, text: "Las placas base no presentan descalce." },
  { id: 9, text: "La estantería no está fijada a otros elementos." },
  { id: 10, text: "La estantería no sirve de soporte a otros elementos." },
  { id: 11, text: "Los puntales no presentan deterioro." },
  { id: 12, text: "Las diagonales y horizontales de bastidores no presentan deterioro." },
  { id: 13, text: "El tipo de larguero se corresponde con el del documento de validación." },
  { id: 14, text: "Los largueros no presentan deterioro." },
  { id: 15, text: "Los largueros están montados horizontales y a la misma altura que el larguero opuesto." },
  { id: 16, text: "La flecha de los largueros está dentro de los límites establecidos en el documento de validación." },
  { id: 17, text: "Los largueros tienen puesto correctamente el dispositivo de fijación (horquillas)." },
  { id: 18, text: "No se aprecia en inspección visual grietas en soldadura o material base." },
  { id: 19, text: "Los elementos del sistema no presentan degradación por pérdida de pintura de protección y/o oxidación." },
  { id: 20, text: "El estado de las protecciones en el bastidor es correcto (mantienen distancia de seguridad y están correctamente fijadas al suelo)." },
  { id: 21, text: "Las cargas se ajustan a las dimensiones estandarizadas para las paletas." },
  { id: 22, text: "Las cargas a nivel de suelo no sobresalen de la alineación, respetando los anchos de pasillo." },
  { id: 23, text: "La iluminación es adecuada." },
  { id: 24, text: "En estanterías de picking las barandillas de segundo nivel están en perfecto estado, tienen pasamanos superior, intermedio y rodapié." },
  { id: 25, text: "En estanterías de picking se mantienen todos los elementos de los niveles previstos y en caso contrario se mantiene los largueros y/o baldas superiores y se ha señalizado correctamente 'no utilizar'." },
  { id: 26, text: "La carga se distribuye uniformemente y de forma ordenada." },
  { id: 27, text: "Las cargas están dentro de los límites establecidos en las placas identificativas." },
];
--- FIN DEL ARCHIVO: src/utils/checklist.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-checklist.js ---
// src/utils/pdf/pdf-module-checklist.js

import autoTable from 'jspdf-autotable';
import { checklistItems } from '../checklist';
import { MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

// Helper para determinar la gravedad máxima de un grupo de incidencias
function getHighestSeverity(incidencias) {
    if (incidencias.some(inc => inc.gravedad === 'rojo')) return 'rojo';
    if (incidencias.some(inc => inc.gravedad === 'ambar')) return 'ambar';
    if (incidencias.some(inc => inc.gravedad === 'verde')) return 'verde';
    return null;
}

export async function buildChecklistAnnex(pdf, reportData) {
    const { inspectionData, salasData, puntosMaestrosData, puntosInspeccionadosData, incidenciasData } = reportData;

    // Lógica de filtrado principal
    if (!incidenciasData || incidenciasData.length === 0) {
        return;
    }
    const puntosInspeccionadosConIncidenciasIds = new Set(incidenciasData.map(inc => inc.punto_inspeccionado_id));
    const puntosMaestrosConIncidenciasIds = new Set(
        puntosInspeccionadosData
            .filter(pi => puntosInspeccionadosConIncidenciasIds.has(pi.id))
            .map(pi => pi.punto_maestro_id)
    );
    if (puntosMaestrosConIncidenciasIds.size === 0) {
        return;
    }

    // Página de portada del anexo
    pdf.addPage();
    autoTable(pdf, {
        body: [['ANEXO 02:\nCHECKLIST']],
        startY: 145,
        theme: 'plain',
        styles: { 
            fontSize: FONT_SIZES.annexTitle, 
            fontStyle: 'bold', 
            halign: 'center',
            font: 'helvetica' // <-- FUENTE OPTIMIZADA
        },
        margin: { left: MARGIN, right: MARGIN }
    });

    for (const sala of salasData) {
        const puntosDeLaSala = puntosMaestrosData
            .filter(pm => pm.sala_id === sala.id && puntosMaestrosConIncidenciasIds.has(pm.id))
            .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}));
        
        if (puntosDeLaSala.length === 0) {
            continue;
        }

        for (const puntoMaestro of puntosDeLaSala) {
            pdf.addPage();

            autoTable(pdf, {
                body: [['FORMATO DE INSPECCIÓN DEL SISTEMA DE ALMACENAJE']],
                startY: 25,
                theme: 'plain',
                styles: { fontSize: FONT_SIZES.h2, fontStyle: 'bold', halign: 'center', font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                margin: { left: MARGIN, right: MARGIN }
            });

            autoTable(pdf, {
                body: [[
                    `HIPERMERCADO: ${inspectionData.centros.nombre.toUpperCase()}`,
                    `Reserva: ${sala.nombre.toUpperCase()}`,
                    `Alineación: ${puntoMaestro.nomenclatura.split('-').pop()}`
                ]],
                startY: pdf.lastAutoTable.finalY + 1,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.body, fontStyle: 'normal', lineColor: 0, lineWidth: 0.1, font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                headStyles: { fillColor: [255, 192, 0] },
                columnStyles: {
                    0: { cellWidth: 100 },
                    1: { cellWidth: 40 },
                    2: { cellWidth: 40, halign: 'left' }
                },
                margin: { left: MARGIN, right: MARGIN }
            });

            const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.punto_maestro_id === puntoMaestro.id);
            const puntoInspeccionadoId = puntoInspeccionado ? puntoInspeccionado.id : null;
            const head = [
                [{ content: 'Parámetro de control', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } },
                { content: 'S', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } },
                { content: 'I', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } }, 
                { content: 'N', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } },
                { content: 'RIESGO', colSpan: 3, styles: { halign: 'center' } }],
                ['V', 'A', 'R']
            ];
            
            const body = checklistItems.map(item => {
                const itemIncidencias = incidenciasData.filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && inc.item_checklist === item.id);
                const tieneIncidencias = itemIncidencias.length > 0;
                const maxSeverity = tieneIncidencias ? getHighestSeverity(itemIncidencias) : null;
                
                return [
                    `${item.id}. ${item.text}`,
                    !tieneIncidencias ? 'X' : '',
                    tieneIncidencias ? 'X' : '',
                    '', // N/A
                    maxSeverity === 'verde' ? 'X' : '',
                    maxSeverity === 'ambar' ? 'X' : '',
                    maxSeverity === 'rojo' ? 'X' : '',
                ];
            });

            autoTable(pdf, {
                head, body, 
                startY: pdf.lastAutoTable.finalY, 
                margin: { left: MARGIN, right: MARGIN }, 
                theme: 'grid',
                headStyles: { fillColor: [255, 192, 0], textColor: 0, fontStyle: 'bold', halign: 'center', fontSize: 7, lineColor: 0, lineWidth: 0.1, font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                styles: { fontSize: 7, cellPadding: 1.5, overflow: 'linebreak', lineColor: 0, lineWidth: 0.1, font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                columnStyles: {
                    0: { cellWidth: 129 }, 1: { cellWidth: 7, halign: 'center' }, 2: { cellWidth: 7, halign: 'center' }, 3: { cellWidth: 7, halign: 'center' },
                    4: { cellWidth: 10, halign: 'center' }, 5: { cellWidth: 10, halign: 'center' }, 6: { cellWidth: 10, halign: 'center' },
                },
            });

            let finalY = pdf.lastAutoTable.finalY;

            const observacionesDelPunto = incidenciasData
                .filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && inc.observaciones && inc.observaciones.trim() !== '')
                .map((obs) => {
                    const itemIncidencias = incidenciasData.filter(i => i.punto_inspeccionado_id === puntoInspeccionadoId && i.item_checklist === obs.item_checklist);
                    const obsIndex = itemIncidencias.findIndex(i => i.id === obs.id);
                    const numTotal = itemIncidencias.length;
                    const countStr = numTotal > 1 ? ` (${obsIndex + 1}/${numTotal})` : '';

                    return `Parámetro ${obs.item_checklist}${countStr}: ${obs.observaciones}`;
                })
                .join('\n');
            
            autoTable(pdf, {
                body: [[{ content: `Observaciones:\n${observacionesDelPunto}`, styles: { fontStyle: 'bold', valign: 'top' } }]],
                startY: finalY,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 20, font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                margin: { left: MARGIN, right: MARGIN }
            });

            const fechaInspeccion = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
            autoTable(pdf, {
                body: [[
                    `Fecha revisión: ${fechaInspeccion}\n\nFirma de Arsel Ingenieria S.L.:`,
                    `Firma del PRSES:`
                ]],
                startY: pdf.lastAutoTable.finalY,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 15, valign: 'top', font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                columnStyles: { 1: { halign: 'left' } },
                margin: { left: MARGIN, right: MARGIN }
            });

            autoTable(pdf, {
                body: [['S: Satisfactorio, I: Insatisfactorio, N: No aplica; V: Verde, A: Ámbar, R: Rojo']],
                startY: pdf.lastAutoTable.finalY,
                theme: 'plain',
                styles: { fontSize: 7, halign: 'left', font: 'helvetica' }, // <-- FUENTE OPTIMIZADA
                margin: { left: MARGIN, right: MARGIN }
            });
        }
    }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-checklist.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-summary.js ---
// src/utils/pdf/pdf-module-summary.js

import { drawHeader, MARGIN } from './pdf-helpers';

// --- (No hay cambios en esta función de posicionamiento, sigue siendo la correcta) ---
function findNonOverlappingPosition(point, badgeSize, obstacles, pageBounds) {
    const isOverlapping = (rect1, rect2) => {
        const margin = 2; 
        return !(rect1.x > rect2.x + rect2.width + margin ||
                 rect1.x + rect1.width + margin < rect2.x ||
                 rect1.y > rect2.y + rect2.height + margin ||
                 rect1.y + rect1.height + margin < rect2.y);
    };

    const isWithinBounds = (rect) => {
        return rect.x >= pageBounds.x &&
               rect.y >= pageBounds.y &&
               rect.x + rect.width <= pageBounds.x + pageBounds.width &&
               rect.y + rect.height <= pageBounds.y + pageBounds.height;
    };

    const checkPosition = (pos) => {
        const candidateRect = {
            x: pos.x - badgeSize.width / 2,
            y: pos.y - badgeSize.height / 2,
            width: badgeSize.width,
            height: badgeSize.height
        };
        if (isWithinBounds(candidateRect) && !obstacles.some(obs => isOverlapping(candidateRect, obs))) {
            return pos;
        }
        return null;
    };

    const preferredOffsets = [
        { x: 0, y: -(badgeSize.height / 2 + 8) }, { x: 0, y: (badgeSize.height / 2 + 8) },
        { x: (badgeSize.width / 2 + 8), y: 0 },   { x: -(badgeSize.width / 2 + 8), y: 0 },
        { x: 15, y: -15 }, { x: -15, y: -15 }, { x: 15, y: 15 }, { x: -15, y: 15 }
    ];

    for (const offset of preferredOffsets) {
        const position = checkPosition({ x: point.absX + offset.x, y: point.absY + offset.y });
        if (position) return position;
    }

    let x = point.absX;
    let y = point.absY;
    let dx = 0;
    let dy = -1;
    let stepSize = 5; 
    let stepsInSegment = 1;
    let turnCounter = 0;

    for (let i = 0; i < 5000; i++) {
        for (let j = 0; j < Math.floor(stepsInSegment); j++) {
            x += dx * stepSize;
            y += dy * stepSize;
            const position = checkPosition({ x, y });
            if (position) return position;
        }
        [dx, dy] = [-dy, dx];
        turnCounter++;
        if (turnCounter % 2 === 0) {
            stepsInSegment += 1;
        }
    }

    console.warn("El algoritmo en espiral no encontró una posición. Colocando en la posición por defecto.");
    return { x: point.absX, y: point.absY - 25 };
}


function drawSalaPolygons(pdf, salas, planoX, planoY, planoW, planoH) {
    // (Esta función no necesita cambios)
    for (const sala of salas) {
        if (sala.area_puntos && sala.area_puntos.length > 2) {
            const rgb = ((hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
            })(sala.color);
            if (rgb) {
                pdf.setDrawColor(rgb[0], rgb[1], rgb[2]);
                pdf.setLineWidth(0.8);
                const absolutePoints = sala.area_puntos.map(p => ({ x: planoX + (p.x * planoW), y: planoY + (p.y * planoH) }));
                for (let i = 0; i < absolutePoints.length; i++) {
                    const p1 = absolutePoints[i];
                    const p2 = absolutePoints[(i + 1) % absolutePoints.length];
                    pdf.line(p1.x, p1.y, p2.x, p2.y);
                }
            }
        }
    }
}

// --- MEJORA 3: CÍRCULO DE ANCLAJE EN EL MAPA ---
function drawPointNumberOnMap(pdf, point) {
    const pointNumber = (point.nomenclatura && typeof point.nomenclatura === 'string')
        ? point.nomenclatura.split('-').pop() || '?'
        : '?';

    // Parsear el color de la sala para el borde
    const salaColorRGB = ((hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [128, 128, 128];
    })(point.salaColor);

    pdf.setFontSize(7).setFont(undefined, 'bold');
    pdf.setTextColor(salaColorRGB[0], salaColorRGB[1], salaColorRGB[2]);
    
    const textWidth = pdf.getStringUnitWidth(pointNumber) * 7 / pdf.internal.scaleFactor;
    const circleRadius = textWidth / 2 + 1.5; // Radio del círculo

    // Dibuja el círculo con borde y fondo blanco
    pdf.setFillColor(255, 255, 255);
    pdf.setDrawColor(salaColorRGB[0], salaColorRGB[1], salaColorRGB[2]);
    pdf.setLineWidth(0.4);
    pdf.circle(point.absX, point.absY, circleRadius, 'FD'); // FD = Fill and Draw (Stroke)
    
    // Dibuja el número en el centro
    pdf.text(pointNumber, point.absX, point.absY, { align: 'center', baseline: 'middle' });
}
// --- FIN DE MEJORA 3 ---


// --- MEJORA 1: NÚMERO DEL PUNTO EN LA TARJETA ---
function drawInfoBadge(pdf, position, point) {
    const FONT_SIZE_STATE = 5.5;
    const FONT_SIZE_SEMAPHORE = 6;
    const FONT_SIZE_PUNTO = 7;
    const PADDING_V = 1.2;
    const BADGE_WIDTH = 14; // Un poco más ancha para el número

    // Extraer el número del punto
    const pointNumber = point.nomenclatura.split('-').pop() || '?';

    let stateText = null;
    if (point.estado === 'nuevo') stateText = 'NUEVA';
    else if (point.estado === 'suprimido') stateText = 'SUPRIMIDA';
    else if (point.detalle_modificacion === 'aumentado') stateText = 'AUMENTADA';
    else if (point.detalle_modificacion === 'disminuido') stateText = 'DISMINUIDA';

    // Calcular altura dinámicamente
    const pointNumberHeight = FONT_SIZE_PUNTO + PADDING_V + 1; // +1 para la línea separadora
    const stateTextHeight = stateText ? FONT_SIZE_STATE + PADDING_V : 0;
    const semaphoreHeight = 3 * 4;
    const badgeHeight = pointNumberHeight + stateTextHeight + semaphoreHeight + (PADDING_V * 2);
    
    const startX = position.x - (BADGE_WIDTH / 2);
    let currentY = position.y - (badgeHeight / 2);

    // Dibuja el cuerpo del badge
    pdf.setFillColor(255, 255, 255);
    pdf.setDrawColor(150, 150, 150); // Borde un poco más oscuro
    pdf.setLineWidth(0.3);
    pdf.roundedRect(startX, currentY, BADGE_WIDTH, badgeHeight, 2, 2, 'FD');

    // Sección del Número del Punto
    currentY += PADDING_V + (FONT_SIZE_PUNTO / 2);
    pdf.setFontSize(FONT_SIZE_PUNTO).setFont(undefined, 'bold');
    pdf.setTextColor(50, 50, 50);
    pdf.text(`Punto ${pointNumber}`, position.x, currentY + 1, { align: 'center' });
    currentY += (FONT_SIZE_PUNTO / 2) + PADDING_V;
    pdf.setDrawColor(220, 220, 220);
    pdf.line(startX + 1, currentY, startX + BADGE_WIDTH - 1, currentY);
    currentY += 1;

    // Sección de Estado (si aplica)
    if (stateText) {
        currentY += PADDING_V;
        pdf.setFontSize(FONT_SIZE_STATE).setFont(undefined, 'bold');
        pdf.setTextColor(80, 80, 80);
        pdf.text(stateText, position.x, currentY + stateTextHeight / 2 - 0.2, { align: 'center', baseline: 'middle' });
        currentY += stateTextHeight;
    }

    // Sección del Semáforo
    const items = [
        { color: [34, 197, 94], count: point.counts.verde },
        { color: [245, 158, 11], count: point.counts.ambar },
        { color: [239, 68, 68], count: point.counts.rojo },
    ];

    items.forEach(item => {
        const itemCenterY = currentY + 4 / 2;
        pdf.setFillColor(item.color[0], item.color[1], item.color[2]);
        pdf.circle(startX + 4, itemCenterY, 1.5, 'F'); // Círculos en lugar de cuadrados
        pdf.setTextColor(80, 80, 80);
        pdf.setFontSize(FONT_SIZE_SEMAPHORE).setFont(undefined, 'normal');
        pdf.text(String(item.count), startX + BADGE_WIDTH - 4, itemCenterY, { align: 'center', baseline: 'middle' });
        currentY += 4;
    });
    
    return { x: startX, y: position.y - (badgeHeight/2), width: BADGE_WIDTH, height: badgeHeight };
}
// --- FIN DE MEJORA 1 ---


// --- MEJORA 2: LÍNEAS GUÍA MÁS ELEGANTES ---
function drawLeaderLine(pdf, from, to, badgeRect) {
    // Usar línea sólida, fina y gris
    pdf.setDrawColor(180, 180, 180);
    pdf.setLineWidth(0.2);
    // Quitar el patrón de guiones: pdf.setLineDashPattern([1, 1], 0);

    const badgeCenterX = badgeRect.x + badgeRect.width / 2;
    const badgeCenterY = badgeRect.y + badgeRect.height / 2;
    
    // Lógica para conectar al borde más cercano del badge
    const dx = from.x - badgeCenterX;
    const dy = from.y - badgeCenterY;
    const halfW = badgeRect.width / 2;
    const halfH = badgeRect.height / 2;
    
    let targetX, targetY;
    const slopeY = halfW * (dy / dx);
    const slopeX = halfH * (dx / dy);

    if (Math.abs(dy) <= halfH) { // Intersecta con lados verticales
      targetX = dx > 0 ? badgeRect.x + badgeRect.width : badgeRect.x;
      targetY = badgeCenterY + slopeY;
    } else { // Intersecta con lados horizontales
      targetY = dy > 0 ? badgeRect.y + badgeRect.height : badgeRect.y;
      targetX = badgeCenterX + slopeX;
    }

    pdf.line(from.x, from.y, targetX, targetY);
}
// --- FIN DE MEJORA 2 ---


export async function buildSummaryAnnex(pdf, reportData) {
    const { salasData, puntosInspeccionadosData, puntosMaestrosData, planoBase64, incidenceCounts } = reportData;

    const PAGE_WIDTH = pdf.internal.pageSize.getWidth();
    const PAGE_HEIGHT = pdf.internal.pageSize.getHeight();
    const HEADER_HEIGHT = 15;
    const MARGIN_V = 10;
    
    const pageBounds = {
        x: MARGIN,
        y: HEADER_HEIGHT,
        width: PAGE_WIDTH - MARGIN * 2,
        height: PAGE_HEIGHT - HEADER_HEIGHT - MARGIN_V
    };

    const imgProps = pdf.getImageProperties(planoBase64);
    const canvasAspectRatio = pageBounds.width / pageBounds.height;
    const imageAspectRatio = imgProps.width / imgProps.height;

    let imgWidth, imgHeight;
    if (imageAspectRatio > canvasAspectRatio) {
        imgWidth = pageBounds.width;
        imgHeight = imgWidth / imageAspectRatio;
    } else {
        imgHeight = pageBounds.height;
        imgWidth = imgHeight * imageAspectRatio;
    }

    const planoStartX = (PAGE_WIDTH - imgWidth) / 2;
    const planoStartY = HEADER_HEIGHT + (pageBounds.height - imgHeight) / 2;

    pdf.addImage(planoBase64, 'JPEG', planoStartX, planoStartY, imgWidth, imgHeight);
    drawSalaPolygons(pdf, salasData, planoStartX, planoStartY, imgWidth, imgHeight);

    const puntoMaestroMap = new Map(puntosMaestrosData.map(pm => [pm.id, pm]));
    const salaMap = new Map(salasData.map(s => [s.id, s]));

    const allPoints = puntosInspeccionadosData.map(punto => {
        const puntoMaestro = puntoMaestroMap.get(punto.punto_maestro_id);
        if (!puntoMaestro) return null;
        const sala = salaMap.get(puntoMaestro.sala_id);
        const salaColor = sala ? sala.color : '#808080';
        const absX = planoStartX + (punto.coordenada_x * imgWidth);
        const absY = planoStartY + (punto.coordenada_y * imgHeight);
        const counts = incidenceCounts.get(punto.id) || { verde: 0, ambar: 0, rojo: 0 };
        return { ...punto, nomenclatura: puntoMaestro.nomenclatura, sala, salaColor, absX, absY, counts };
    }).filter(Boolean);
    
    const placedObstacles = allPoints.map(p => ({ x: p.absX - 5, y: p.absY - 5, width: 10, height: 10 })); // Usar el círculo de anclaje como obstáculo
    const labelsToDraw = [];
    
    const mapCenterX = planoStartX + imgWidth / 2;
    const mapCenterY = planoStartY + imgHeight / 2;
    allPoints.sort((a, b) => {
        const distA = Math.sqrt(Math.pow(a.absX - mapCenterX, 2) + Math.pow(a.absY - mapCenterY, 2));
        const distB = Math.sqrt(Math.pow(b.absX - mapCenterX, 2) + Math.pow(b.absY - mapCenterY, 2));
        return distA - distB;
    });

    for (const point of allPoints) {
        const needsBadge = point.estado !== 'existente' || point.detalle_modificacion !== null ||
            (point.counts.verde > 0 || point.counts.ambar > 0 || point.counts.rojo > 0);

        if (!needsBadge) continue;
        
        // --- (Código actualizado para calcular el tamaño del badge) ---
        let badgeHeight = (1.2 * 2) + (4 * 3) + (7 + 1.2 + 1);
        if (point.estado !== 'existente' || point.detalle_modificacion !== null) {
            badgeHeight += 5.5 + 1.2;
        }
        const badgeSize = { width: 14, height: badgeHeight };
        
        const finalPosition = findNonOverlappingPosition(point, badgeSize, placedObstacles, pageBounds);

        const badgeRect = {
            x: finalPosition.x - badgeSize.width / 2,
            y: finalPosition.y - badgeSize.height / 2,
            ...badgeSize
        };
        
        placedObstacles.push(badgeRect);
        labelsToDraw.push({ point, position: finalPosition, finalBadgeRect: badgeRect });
    }

    // Dibujar primero todos los números/anclajes de los puntos
    allPoints.forEach(point => drawPointNumberOnMap(pdf, point));
    
    // Luego, dibujar los badges y sus líneas guía
    labelsToDraw.forEach(({point, position, finalBadgeRect}) => {
        drawInfoBadge(pdf, position, point);
        drawLeaderLine(pdf, {x: point.absX, y: point.absY}, position, finalBadgeRect);
    });
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-summary.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-text.js ---
// src/utils/pdf/pdf-module-text.js

import { drawHeader, loadImageAsBase64, ARSEL_LOGO_URL, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

export async function buildTextPages(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;

  const fecha = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
  const puntoMaestroASalaMap = new Map();
  puntosMaestrosData.forEach(pm => {
    const sala = salasData.find(s => s.id === pm.sala_id);
    if (sala) puntoMaestroASalaMap.set(pm.id, sala);
  });
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const agruparPuntosPorPropiedad = (propiedad, valor) => {
    const puntosFiltrados = puntosInspeccionadosData.filter(pi => pi[propiedad] === valor);
    if (puntosFiltrados.length === 0) return '';
    const grupos = {};
    puntosFiltrados.forEach(pi => {
      const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
      if (sala) {
        if (!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
        grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
      }
    });
    // --- INICIO DE LA CORRECCIÓN ---
    // Se corrige `grupos[sala.nombre]` por `grupos[nombreSala]`
    return Object.keys(grupos).sort().map(nombreSala =>
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
    // --- FIN DE LA CORRECCIÓN ---
  };

  const agruparPuntosConPlacaInvalida = () => {
    const puntosConProblemaDePlaca = puntosInspeccionadosData.filter(pi => 
        pi.tiene_placa_caracteristicas === false || pi.detalle_modificacion === 'aumentado'
    );
      
    if (puntosConProblemaDePlaca.length === 0) return '';

    const grupos = {};
    puntosConProblemaDePlaca.forEach(pi => {
        const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
        if(sala) {
            if(!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
            grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
        }
    });
    // --- INICIO DE LA CORRECCIÓN ---
    // Se aplica la misma corrección aquí para consistencia
    return Object.keys(grupos).sort().map(nombreSala => 
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
    // --- FIN DE LA CORRECCIÓN ---
  };

  const lineasSuprimidas = agruparPuntosPorPropiedad('estado', 'suprimido');
  const lineasNuevas = agruparPuntosPorPropiedad('estado', 'nuevo');
  const lineasDisminuidas = agruparPuntosPorPropiedad('detalle_modificacion', 'disminuido');
  const lineasConPlacaInvalida = agruparPuntosConPlacaInvalida();
  
  const getSalaYNumeroDeIncidencia = (incidencia) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(incidencia.punto_inspeccionado_id);
    if (!puntoMaestroId) return null;
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    if (!sala || !puntoMaestro) return null;
    return { nombreSala: sala.nombre, numeroPunto: puntoMaestro.nomenclatura.split('-').pop() };
  };

  const agruparIncidenciasPorSala = (incidencias) => {
    if (incidencias.length === 0) return '';
    const grupos = {};
    incidencias.forEach(inc => {
      const info = getSalaYNumeroDeIncidencia(inc);
      if (info) {
        if (!grupos[info.nombreSala]) grupos[info.nombreSala] = new Set();
        grupos[info.nombreSala].add(info.numeroPunto);
      }
    });
    const nombresDeSalasOrdenados = Object.keys(grupos).sort((a, b) => a.localeCompare(b));
    return nombresDeSalasOrdenados.map(nombreSala => {
      const numerosOrdenados = [...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ');
      return `${nombreSala.toUpperCase()}: ${numerosOrdenados}`;
    }).join('\n');
  };

  const incidenciasVerdeAmbar = incidenciasData.filter(i => i.gravedad === 'verde' || i.gravedad === 'ambar');
  const textoVerdeAmbar = agruparIncidenciasPorSala(incidenciasVerdeAmbar);
  const incidenciasRojo = incidenciasData.filter(i => i.gravedad === 'rojo');
  const textoRojo = agruparIncidenciasPorSala(incidenciasRojo);

  // --- PÁGINA 1 ---
  await drawHeader(pdf, inspectionData);
  let currentY = 50;
  
  pdf.setFont('helvetica', 'bold');
  const titulo = `INFORME VISITA INSPECCIÓN DEL SISTEMA DE ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES DEL Hipermercado ${inspectionData.centros.nombre.toUpperCase()}`;
  pdf.setFontSize(FONT_SIZES.h2);
  const tituloLines = pdf.splitTextToSize(titulo, DOC_WIDTH - (MARGIN * 2));
  pdf.text(tituloLines, DOC_WIDTH / 2, currentY, { align: 'center' });
  currentY += (tituloLines.length * 7) + 15;

  pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'bold'); pdf.text('1. OBJETO', MARGIN, currentY); currentY += 8; pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); pdf.text(`Con motivo de la visita programada para la inspección del sistema de almacenaje para cargas paletizadas y manuales del ${inspectionData.centros.nombre}, se redacta el presente informe que recoge de forma somera el resultado de la visita.`, MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 25;
  pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'bold'); pdf.text('2. ANTECEDENTES', MARGIN, currentY); currentY += 8; pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); pdf.text('Para realizar la inspección del sistema de almacenaje de cargas paletizadas y manuales ubicadas en las reservas se toma como base la memoria técnica previa de evaluación de dichos sistemas facilitada al centro para la realización de las correcciones oportunas. Este documento establece los parámetros dimensionales y de carga, así como los elementos y medidas de seguridad que deben contemplar los sistemas de almacenaje para garantizar su estabilidad y uso seguro.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 40; pdf.text('La inspección consiste en la revisión visual del sistema llevada a cabo por un técnico cualificado, con la comprobación de los puntos recogidos en el checklist previsto para tal fin en la memoria de evaluación previa, con el consiguiente registro escrito de los resultados obtenidos.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 30;
  pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'bold'); pdf.text('3. RESULTADO DE LA VISITA', MARGIN, currentY); currentY += 8; pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'normal'); pdf.text('En rasgos generales los sistemas de almacenaje cumplen los parámetros establecidos en la memoria técnica de evaluación.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 15; 
  
  if (textoVerdeAmbar) {
    pdf.text('Se han detectado anomalías de riesgo verde y/o ámbar, tal y como se refleja en los listados de inspección elaborados durante la visita en:', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 });
  }

  // --- PÁGINA 2 Y SIGUIENTES ---
  pdf.addPage();
  await drawHeader(pdf, inspectionData);
  currentY = 50;
  
  const PAGE_HEIGHT = pdf.internal.pageSize.getHeight();
  const FOOTER_MARGIN = 30;

  const checkPageBreak = async (heightNeeded) => {
    if (currentY + heightNeeded > PAGE_HEIGHT - FOOTER_MARGIN) {
      pdf.addPage();
      await drawHeader(pdf, inspectionData);
      currentY = 50;
    }
  };

  const addSection = async (title, content) => {
    if (!content && !title.toLowerCase().includes('nuevas montadas')) return;
    content = content || 'Ninguna';
    
    const titleHeight = 8;
    const contentHeight = content.split('\n').length * 5 + 5;
    await checkPageBreak(titleHeight + contentHeight);
    
    pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body).text(title, MARGIN, currentY);
    currentY += titleHeight;
    pdf.setFont('helvetica', 'bold').text(content, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += contentHeight;
  };

  if (textoVerdeAmbar) {
    pdf.setFont('helvetica', 'bold').setFontSize(FONT_SIZES.body).text(textoVerdeAmbar, MARGIN, currentY, { lineHeightFactor: 1.5 });
    currentY += (textoVerdeAmbar.split('\n').length * 5) + 5;
  }
  
  pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body);
  
  const textoPostVerdeAmbar = 'Estas anomalías, si bien no comprometen de forma inmediata la estabilidad ni seguridad del sistema, deben subsanarse lo antes posible para evitar que puedan derivar en un riesgo mayor. (Se adjuntan listados de chequeo y reportaje fotográfico de la visita).';
  const postVerdeAmbarLines = pdf.splitTextToSize(textoPostVerdeAmbar, DOC_WIDTH - MARGIN * 2);
  await checkPageBreak(postVerdeAmbarLines.length * 5 + 15);
  pdf.text(textoPostVerdeAmbar, MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 });
  currentY += postVerdeAmbarLines.length * 5 + 15;

  if(textoRojo) {
    const textoPreRojo = 'Puntualmente, se han detectado anomalías de riesgo rojo en:';
    await checkPageBreak(8 + textoRojo.split('\n').length * 5 + 5);
    pdf.text(textoPreRojo, MARGIN, currentY); currentY += 8;
    pdf.setFont('helvetica', 'bold');
    pdf.text(textoRojo, MARGIN, currentY, { lineHeightFactor: 1.5 });
    currentY += (textoRojo.split('\n').length * 5) + 5;
    
    pdf.setFont('helvetica', 'normal');
    const textoRiesgoRojo = 'Estas anomalías deben subsanarse inmediatamente para evitar el colapso de las estanterías en el caso de una combinación de cargas desfavorables, procediendo a la descarga de la mercancía de los módulos afectados y señalizando la zona para que no se almacene producto en los mismos hasta que puedan ser sustituidos los elementos dañados. La sustitución se llevará a cabo con nuevo material que se tiene que solicitar si no cuenta con repuesto en el centro.';
    const textLines = pdf.splitTextToSize(textoRiesgoRojo, DOC_WIDTH - (MARGIN * 2));
    await checkPageBreak(textLines.length * 5 + 15);
    pdf.text(textLines, MARGIN, currentY, { lineHeightFactor: 1.5 });
    currentY += textLines.length * 5 + 15;
  }

  await addSection('Alineaciones sin placa de características o con placa no válida (por aumento de módulos/niveles):', lineasConPlacaInvalida);
  await addSection('Alineaciones con módulos DISMINUIDOS desde la inspección anterior:', lineasDisminuidas);
  await addSection('Alineaciones desmontadas desde la inspección anterior:', lineasSuprimidas);
  await addSection('Alineaciones nuevas montadas desde la inspección anterior:', lineasNuevas);

  await checkPageBreak(80);
  pdf.setFont('helvetica', 'normal').setFontSize(FONT_SIZES.body);
  pdf.text('Para cerrar el proceso de inspección completo, el centro subsanará las deficiencias de menor grado detectadas en los próximos días, comunicando la resolución de las mismas mediante correo electrónico a ARSEL Ingeniería y al Técnico de Prevención Regional.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 40;
  pdf.text('Informe realizado por:', MARGIN, currentY); currentY += 15;
  const arselLogoBase64 = await loadImageAsBase64(ARSEL_LOGO_URL);
  if (arselLogoBase64) {
      pdf.addImage(arselLogoBase64, 'PNG', MARGIN, currentY, 35, 15, undefined, 'MEDIUM');
      currentY += 18;
  }
  pdf.setFont('helvetica', 'bold').text('ARSEL INGENIERIA', MARGIN, currentY);
  currentY += 5;
  pdf.setFont('helvetica', 'normal').text(`Valencia, ${fecha}`, MARGIN, currentY);
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-text.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-data.js ---
// src/utils/pdf/pdf-data.js

import { supabase } from '../../supabase';
import { loadImageAsBase64 } from './pdf-helpers';

// --- INICIO DEL CAMBIO: Aceptamos un objeto de opciones ---
export async function fetchReportData(inspeccionId, options = {}) {
  const { optimizePlan = true } = options; // Por defecto, optimiza el plano
  // --- FIN DEL CAMBIO ---

  console.log(`[fetchReportData] Iniciando búsqueda de datos para la inspección ID: ${inspeccionId}`);
  
  try {
    const { data: inspectionData, error: inspectionError } = await supabase
      .from('inspecciones')
      .select('*, centros(*), versiones_plano(*)')
      .eq('id', inspeccionId)
      .single();
    
    if (inspectionError) {
      console.error('[fetchReportData] ¡ERROR CRÍTICO al obtener la inspección!', inspectionError);
      throw new Error(`Error al obtener la inspección: ${inspectionError.message}`);
    }
    console.log('[fetchReportData] Datos de la inspección principal obtenidos:', inspectionData);
    
    if (!inspectionData.centros) {
      console.error('[fetchReportData] ¡ERROR! La inspección no tiene un centro asociado.');
      throw new Error('Datos del centro no encontrados para esta inspección.');
    }

    const versionId = inspectionData.versiones_plano?.id;
    console.log(`[fetchReportData] Usando la versión de plano ID: ${versionId}`);

    const planoUrl = inspectionData.versiones_plano?.url_imagen_plano;
    
    // --- INICIO DEL CAMBIO: Pasamos la opción de optimización al helper ---
    const planoBase64 = planoUrl ? await loadImageAsBase64(planoUrl, { optimize: optimizePlan }) : null;
    // --- FIN DEL CAMBIO ---
    
    console.log(`[fetchReportData] ¿Se cargó la imagen del plano? -> ${planoBase64 ? 'Sí' : 'No'}. ¿Fue optimizada? -> ${optimizePlan}`);

    const [
      { data: salasData, error: salasError },
      { data: puntosMaestrosData, error: puntosMaestrosError },
      { data: puntosInspeccionadosData, error: puntosInspeccionadosError },
      { data: incidenciasData, error: incidenciasError }
    ] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', versionId).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', versionId),
      supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId),
      supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId)
    ]);

    if (salasError || puntosMaestrosError || puntosInspeccionadosError || incidenciasError) {
      console.error('[fetchReportData] ¡ERROR en una de las consultas en paralelo!', { salasError, puntosMaestrosError, puntosInspeccionadosError, incidenciasError });
      throw new Error('Error al obtener datos relacionados con la inspección.');
    }
    console.log('[fetchReportData] Datos relacionados obtenidos:', {
        salas: salasData?.length,
        puntosMaestros: puntosMaestrosData?.length,
        puntosInspeccionados: puntosInspeccionadosData?.length,
        incidencias: incidenciasData?.length
    });
    
    const incidenceCounts = new Map();
    (puntosInspeccionadosData || []).forEach(pi => {
        incidenceCounts.set(pi.id, { verde: 0, ambar: 0, rojo: 0 });
    });
    (incidenciasData || []).forEach(inc => {
        const counts = incidenceCounts.get(inc.punto_inspeccionado_id);
        if (counts && counts[inc.gravedad] !== undefined) {
            counts[inc.gravedad]++;
        }
    });

    const result = {
      inspectionData,
      salasData: salasData || [],
      puntosMaestrosData: puntosMaestrosData || [],
      puntosInspeccionadosData: puntosInspeccionadosData || [],
      incidenciasData: incidenciasData || [],
      planoBase64,
      incidenceCounts,
    };
    
    console.log('[fetchReportData] Búsqueda de datos completada con éxito.');
    return result;

  } catch (error) {
    console.error('[fetchReportData] La función ha fallado con una excepción:', error);
    return null;
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-data.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-module-photos.js ---
// src/utils/pdf/pdf-module-photos.js

import { checklistItems } from '../checklist';
import { drawHeader, loadImageAsBase64, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

// --- ANEXO DE FOTOS INICIAL (OPTIMIZADO) ---
export async function buildInitialPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;
  
  const incidenciasConFoto = incidenciasData.filter(inc => 
    inc.url_foto_antes && inc.item_checklist !== 2
  );
  if (incidenciasConFoto.length === 0) return;

  const puntoMaestroASalaMap = new Map(puntosMaestrosData.map(pm => [pm.id, salasData.find(s => s.id === pm.sala_id)]));
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const getSortInfoForIncidencia = (inc) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(inc.punto_inspeccionado_id);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    return {
      salaNombre: sala ? sala.nombre : 'ZZZ',
      puntoNumero: puntoMaestro ? parseInt(puntoMaestro.nomenclatura.split('-').pop() || 0) : 9999
    };
  };

  incidenciasConFoto.sort((a, b) => {
    const infoA = getSortInfoForIncidencia(a);
    const infoB = getSortInfoForIncidencia(b);
    const comparacionSala = infoA.salaNombre.localeCompare(infoB.salaNombre);
    if (comparacionSala !== 0) return comparacionSala;
    return infoA.puntoNumero - infoB.puntoNumero;
  });

  pdf.addPage();
  await drawHeader(pdf, inspectionData);
  
  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont('helvetica', 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  pdf.text('REPORTAJE FOTOGRÁFICO', DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont('helvetica', 'normal');

  for (const incidencia of incidenciasConFoto) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;

    pdf.addPage();
    await drawHeader(pdf, inspectionData);
    
    let currentY = 45;
    pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'normal');
    pdf.text(`Alineación: ${puntoMaestro.nomenclatura}`, MARGIN, currentY);
    currentY += 8;

    const checklistItem = checklistItems.find(item => item.id === incidencia.item_checklist);
    if (checklistItem) {
      pdf.setFontSize(FONT_SIZES.body).setFont('helvetica', 'italic');
      pdf.setTextColor(100);
      const itemText = `Incidencia: ${checklistItem.id}. ${checklistItem.text}`;
      const splitText = pdf.splitTextToSize(itemText, DOC_WIDTH - (MARGIN * 2));
      pdf.text(splitText, MARGIN, currentY);
      currentY += (splitText.length * 5) + 5;
      pdf.setTextColor(0);
      pdf.setFont('helvetica', 'normal');
    }

    // --- CORRECCIÓN DE OPTIMIZACIÓN: Usa el default optimizado (1024px) ---
    const fotoAntesBase64 = await loadImageAsBase64(incidencia.url_foto_antes);
    if(fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN, currentY, 180, 100, undefined, 'MEDIUM');
    }

    let obsBlockY = currentY + 100 + 10;
    pdf.setFontSize(FONT_SIZES.body);
    const obsText = incidencia.observaciones || '';
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight);

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont('helvetica', 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 10);
  }
}


// --- ANEXO DE FOTOS DE SUBSANACIÓN (OPTIMIZADO) ---
export async function buildRemediationPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData } = reportData;
  
  const incidenciasSubsanadas = incidenciasData.filter(inc => inc.url_foto_antes && inc.url_foto_despues);
  if (incidenciasSubsanadas.length === 0) return;

  pdf.addPage();
  await drawHeader(pdf, inspectionData);

  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont('helvetica', 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  const remediationTitleLines = pdf.splitTextToSize('REPORTAJE FOTOGRÁFICO DE SUBSANACIÓN', 180);
  pdf.text(remediationTitleLines, DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont('helvetica', 'normal');
  
  for (const incidencia of incidenciasSubsanadas) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;
    
    pdf.addPage();
    await drawHeader(pdf, inspectionData);
    pdf.setFontSize(FONT_SIZES.h2).setFont('helvetica', 'normal').text(`Subsanación de Incidencia: ${puntoMaestro.nomenclatura}`, MARGIN, 45);

    // --- CORRECCIÓN DE OPTIMIZACIÓN: Redimensiona a un tamaño más pequeño (600px) ---
    const [fotoAntesBase64, fotoDespuesBase64] = await Promise.all([
      loadImageAsBase64(incidencia.url_foto_antes, 600, 600),
      loadImageAsBase64(incidencia.url_foto_despues, 600, 600)
    ]);
    
    const photoBoxY = 65;
    const photoBoxSize = 85;
    const photoPadding = 2;

    pdf.text('ANTES', MARGIN + (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(MARGIN, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'MEDIUM');
    }
    
    pdf.text('DESPUÉS', DOC_WIDTH - MARGIN - (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(DOC_WIDTH / 2 + 5, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoDespuesBase64) {
      pdf.addImage(fotoDespuesBase64, 'JPEG', (DOC_WIDTH / 2 + 5) + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'MEDIUM');
    }
    
    let obsBlockY = 160;
    pdf.setFontSize(FONT_SIZES.body);
    const obsText = incidencia.observaciones || '';
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight);

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont('helvetica', 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 10);
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-module-photos.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/index.js ---
// src/utils/pdf/index.js

import jsPDF from 'jspdf';
import { fetchReportData } from './pdf-data';
import { buildTextPages } from './pdf-module-text';
import { buildInitialPhotoAnnex, buildRemediationPhotoAnnex } from './pdf-module-photos';
import { buildChecklistAnnex } from './pdf-module-checklist';
import { buildSummaryAnnex } from './pdf-module-summary';

// --- NUEVA FUNCIÓN HELPER PARA LIMPIAR NOMBRES DE ARCHIVO ---
function sanitizeFileName(name) {
  // 1. Reemplaza espacios con guiones bajos
  let sanitized = name.replace(/\s+/g, '_');
  // 2. Normaliza para separar tildes de las letras (ej. á -> a + ´)
  sanitized = sanitized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  // 3. Elimina cualquier caracter que no sea letra, número, guión bajo, punto o guión
  sanitized = sanitized.replace(/[^a-zA-Z0-9_.-]/g, '');
  return sanitized;
}

/**
 * Genera el informe en PDF. Puede descargarlo o devolverlo como Blob.
 * @param {number} inspeccionId - El ID de la inspección.
 * @param {string} reportType - 'initial' o 'remediation'.
 * @param {string} outputType - 'download' o 'blob'.
 */
export async function generateTextReport(inspeccionId, reportType = 'initial', outputType = 'download') {
  try {
    console.log(`Iniciando generación de Informe de Texto (output: ${outputType})...`);
    const reportData = await fetchReportData(inspeccionId, { optimizePlan: true }); 
    if (!reportData) throw new Error("No se pudieron cargar los datos para el informe.");
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    console.log("Construyendo páginas de texto...");
    await buildTextPages(pdf, reportData);
    
    if (reportType === 'initial') {
      console.log("Construyendo anexo de fotos inicial...");
      await buildInitialPhotoAnnex(pdf, reportData);
    } else if (reportType === 'remediation') {
      console.log("Construyendo anexo de fotos de subsanación...");
      await buildRemediationPhotoAnnex(pdf, reportData);
    }
    
    console.log("Construyendo anexo de checklist...");
    await buildChecklistAnnex(pdf, reportData);
    
    const { inspectionData } = reportData;
    const reportTypeName = reportType === 'initial' ? 'Informe' : 'Subsanacion';
    
    // --- INICIO DE LA CORRECCIÓN: Sanitizamos el nombre del archivo ---
    const rawFileName = `${reportTypeName}_${inspectionData.centros.nombre}_${inspectionData.fecha_inspeccion}.pdf`;
    const fileName = sanitizeFileName(rawFileName);
    // --- FIN DE LA CORRECCIÓN ---

    if (outputType === 'blob') {
      console.log('Devolviendo PDF como Blob.');
      return { blob: pdf.output('blob'), fileName: fileName };
    } else {
      console.log(`Guardando PDF como: ${fileName}`);
      pdf.save(fileName);
      return { blob: null, fileName: fileName };
    }

  } catch (err) {
    console.error("Error generando el Informe de Texto:", err);
    alert(`Hubo un error al generar el informe. Revisa la consola: ${err.message}`);
    return null;
  }
}

/**
 * Genera un PDF que contiene ÚNICAMENTE el plano visual de incidencias.
 * @param {number} inspeccionId - El ID de la inspección.
 */
export async function generatePlanPdf(inspeccionId) {
  try {
    console.log("Iniciando generación de PDF del Plano...");
    const reportData = await fetchReportData(inspeccionId, { optimizePlan: true }); 
    
    if (!reportData.planoBase64) {
        throw new Error("No se pudo cargar la imagen del plano para esta inspección.");
    }

    const pdf = new jsPDF('l', 'mm', 'a4');
    
    console.log("Construyendo anexo de resumen visual...");
    await buildSummaryAnnex(pdf, reportData);
    
    const { inspectionData } = reportData;
    
    // --- INICIO DE LA CORRECCIÓN: Sanitizamos también aquí ---
    const rawFileName = `Plano_Incidencias_${inspectionData.centros.nombre}_${inspectionData.fecha_inspeccion}.pdf`;
    const fileName = sanitizeFileName(rawFileName);
    // --- FIN DE LA CORRECCIÓN ---

    console.log(`Guardando PDF como: ${fileName}`);
    pdf.save(fileName);

  } catch (err) {
    console.error("Error generando el PDF del Plano:", err);
    alert(`Hubo un error al generar el plano. Revisa la consola: ${err.message}`);
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/index.js ---

--- INICIO DEL ARCHIVO: src/utils/pdf/pdf-helpers.js ---
// src/utils/pdf/pdf-helpers.js

// --- CONSTANTES ---
export const MARGIN = 15;
export const DOC_WIDTH = 210;
export const DOC_WIDTH_LANDSCAPE = 297;
export const FONT_SIZES = { annexTitle: 22, title: 16, h1: 14, h2: 12, body: 11, small: 8 };
export const ARSEL_LOGO_URL = "https://bgltxcklvjumltuktdvv.supabase.co/storage/v1/object/public/logos-clientes/logo.PNG";

// --- FUNCIÓN DE AYUDA PARA CARGAR IMÁGENES (CON CONTROL DE OPTIMIZACIÓN) ---
export async function loadImageAsBase64(url, options = {}) {
  // Opciones por defecto: optimizar siempre con un máximo de 1024px
  const { optimize = true, maxWidth = 1024, maxHeight = 1024 } = options;

  if (!url || !url.startsWith('http')) return null;
  try {
    const response = await fetch(url);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.startsWith("image/")) {
      console.warn(`La URL no devolvió una imagen: ${url}`);
      return null;
    }
    const blob = await response.blob();

    return new Promise((resolve, reject) => {
      // --- INICIO DEL CAMBIO: Si no se debe optimizar, devolvemos el original ---
      if (!optimize) {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
        return;
      }
      // --- FIN DEL CAMBIO ---

      const img = new Image();
      const objectUrl = URL.createObjectURL(blob);
      img.src = objectUrl;
      
      img.onload = () => {
        let { width, height } = img;
        
        if (width <= maxWidth && height <= maxHeight) {
            const reader = new FileReader();
            reader.onloadend = () => {
                URL.revokeObjectURL(objectUrl);
                resolve(reader.result);
            };
            reader.onerror = (err) => {
                URL.revokeObjectURL(objectUrl);
                reject(err);
            };
            reader.readAsDataURL(blob);
            return;
        }

        const ratio = Math.min(maxWidth / width, maxHeight / height);
        const newWidth = Math.floor(width * ratio);
        const newHeight = Math.floor(height * ratio);
        
        const canvas = document.createElement('canvas');
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, newWidth, newHeight);
        
        const dataUrl = canvas.toDataURL('image/jpeg', 0.80);
        
        URL.revokeObjectURL(objectUrl);
        resolve(dataUrl);
      };

      img.onerror = (err) => {
        URL.revokeObjectURL(objectUrl);
        reject(err);
      };
    });

  } catch (error) {
    console.error("Error cargando y optimizando imagen para PDF:", url, error);
    return null;
  }
}

// --- CABECERA PRINCIPAL (REUTILIZABLE EN TODO EL PDF) ---
export async function drawHeader(pdf, inspectionData) {
  const [clientLogoBase64, arselLogoBase64] = await Promise.all([
    // Los logos siempre los optimizamos a un tamaño pequeño
    loadImageAsBase64(inspectionData.centros.url_logo_cliente, { maxWidth: 300, maxHeight: 300 }),
    loadImageAsBase64(ARSEL_LOGO_URL, { maxWidth: 300, maxHeight: 300 })
  ]);

  // (El resto de la función drawHeader no cambia)
  const pageSize = pdf.internal.pageSize;
  const pageWidth = pageSize.getWidth();

  const headerY = MARGIN - 8;
  const headerHeight = 20;
  const contentWidth = pageWidth - (MARGIN * 2); 
  const cell1Width = 40;
  const cell3Width = 40;
  const cell2Width = contentWidth - cell1Width - cell3Width;

  pdf.rect(MARGIN, headerY, contentWidth, headerHeight);
  pdf.line(MARGIN, headerY + 8, pageWidth - MARGIN, headerY + 8);
  pdf.line(MARGIN + cell1Width, headerY + 8, MARGIN + cell1Width, headerY + headerHeight);
  pdf.line(MARGIN + cell1Width + cell2Width, headerY + 8, MARGIN + cell1Width + cell2Width, headerY + headerHeight);

  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(FONT_SIZES.h2);
  pdf.text(`HIPERMERCADO ${inspectionData.centros.nombre.toUpperCase()}`, pageWidth / 2, headerY + 5.5, { align: 'center' });

  if (clientLogoBase64) {
    pdf.addImage(clientLogoBase64, 'JPEG', MARGIN + 2, headerY + 9.5, cell1Width - 4, 9, undefined, 'MEDIUM');
  }

  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(FONT_SIZES.small);
  const titleText = 'INFORME VISITA INSPECCIÓN DEL SISTEMA DE ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES';
  pdf.text(titleText, MARGIN + cell1Width + (cell2Width / 2), headerY + 12.5, {
    maxWidth: cell2Width - 4,
    align: 'center',
    lineHeightFactor: 1.2
  });
  
  if (arselLogoBase64) {
    pdf.addImage(arselLogoBase64, 'JPEG', MARGIN + cell1Width + cell2Width + 2, headerY + 9.5, cell3Width - 4, 9, undefined, 'MEDIUM');
  }
}
--- FIN DEL ARCHIVO: src/utils/pdf/pdf-helpers.js ---

--- INICIO DEL ARCHIVO: src/components/PointList.vue ---
<!-- src/components/PointList.vue -->
<script setup>
import { ref } from 'vue';
import { EyeSlashIcon, ArrowUturnLeftIcon, TrashIcon, ChevronDownIcon } from '@heroicons/vue/24/solid';

defineProps({
  groupedPoints: {
    type: Array,
    required: true
  }
});

defineEmits(['select-point', 'update-state', 'delete-new-point']);

const openSalaId = ref(null);

const toggleSala = (salaId) => {
  openSalaId.value = openSalaId.value === salaId ? null : salaId;
};
</script>

<template>
  <div class="space-y-2">
    <div v-for="grupo in groupedPoints" :key="grupo.id">
      <!-- Encabezado de la Sala (clickeable) -->
      <button @click="toggleSala(grupo.id)" class="w-full flex justify-between items-center p-3 rounded-lg text-left" :class="openSalaId === grupo.id ? 'bg-blue-50' : 'hover:bg-slate-50'">
        <h3 class="font-bold text-slate-700">{{ grupo.nombre }}</h3>
        <ChevronDownIcon class="h-5 w-5 text-slate-400 transition-transform" :class="{'rotate-180': openSalaId === grupo.id}" />
      </button>

      <!-- Lista de Puntos (se muestra si la sala está abierta) -->
      <ul v-if="openSalaId === grupo.id" class="space-y-1 pl-4 border-l-2 ml-3">
        <li v-for="punto in grupo.puntos" :key="punto.id">
          <div :class="['p-2 rounded-lg flex items-center justify-between group', { 'bg-slate-100': punto.estado === 'suprimido' }]">
            <button @click="$emit('select-point', punto)" 
                    :disabled="punto.estado === 'suprimido'"
                    class="flex-1 text-left disabled:cursor-not-allowed">
              <div class="flex items-center">
                <span class="w-3 h-3 rounded-full flex-shrink-0" :style="{ backgroundColor: punto.color }"></span>
                <span :class="['font-semibold ml-3', { 'line-through text-slate-500': punto.estado === 'suprimido', 'text-slate-700': punto.estado !== 'suprimido' }]">
                  {{ punto.nomenclatura }}
                </span>
                <span v-if="punto.estado === 'nuevo'" class="ml-2 text-xs font-bold text-green-600 bg-green-100 px-2 py-0.5 rounded-full">NUEVO</span>
              </div>
            </button>
            <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
              <button v-if="punto.estado === 'nuevo'" @click="$emit('delete-new-point', punto)" class="p-1 text-slate-400 hover:text-red-500" title="Borrar punto nuevo">
                <TrashIcon class="h-5 w-5" />
              </button>
              
              <button v-if="punto.estado !== 'suprimido'" @click="$emit('update-state', punto, 'suprimido')" class="p-1 text-slate-400 hover:text-red-500" title="Marcar como suprimido">
                <EyeSlashIcon class="h-5 w-5" />
              </button>
              <button v-else @click="$emit('update-state', punto, 'existente')" class="p-1 text-slate-500 hover:text-blue-500" title="Reactivar punto">
                <ArrowUturnLeftIcon class="h-5 w-5" />
              </button>
            </div>
          </div>
        </li>
      </ul>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/PointList.vue ---

--- INICIO DEL ARCHIVO: src/components/ChecklistModal.vue ---
<!-- src/components/ChecklistModal.vue -->
<script setup>
import { ref, watch, computed } from 'vue';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';
import { ArrowUpTrayIcon, CheckCircleIcon, XCircleIcon, PlusCircleIcon, TrashIcon, ArrowTrendingUpIcon, ArrowTrendingDownIcon, StopCircleIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  punto: Object,
  inspeccionId: Number,
});

const emit = defineEmits(['close', 'save']);

const incidencias = ref([]);
const loading = ref(false);
const isUploading = ref(null);
const puntoInspeccionado = ref(null);

const gravedadOptions = [
  { label: 'Leve', value: 'verde' },
  { label: 'Moderado', value: 'ambar' },
  { label: 'Grave', value: 'rojo' },
];

const tienePlaca = computed({
  get: () => puntoInspeccionado.value?.tiene_placa_caracteristicas,
  set: (newValue) => {
    if (puntoInspeccionado.value) {
      puntoInspeccionado.value.tiene_placa_caracteristicas = newValue;
      handlePlacaStatusChange(newValue);
    }
  }
});

const detalleModificacion = computed({
  get: () => puntoInspeccionado.value?.detalle_modificacion,
  set: (newValue) => {
    if (puntoInspeccionado.value) {
      puntoInspeccionado.value.detalle_modificacion = newValue;
      handleModificationChange(newValue);
    }
  }
});

const loadData = async () => {
  if (!props.punto || !props.inspeccionId) return;
  loading.value = true;
  
  const { data: puntoRelacionado, error: findError } = await supabase
    .from('puntos_inspeccionados')
    .select('*')
    .eq('inspeccion_id', props.inspeccionId)
    .eq('punto_maestro_id', props.punto.id)
    .maybeSingle();

  if (findError) {
    console.error("Error buscando punto inspeccionado:", findError);
    loading.value = false;
    return;
  }
  
  if (puntoRelacionado) {
    puntoInspeccionado.value = puntoRelacionado;
  } else {
    const { data: nuevoPunto, error: createError } = await supabase
      .from('puntos_inspeccionados')
      .insert({
        inspeccion_id: props.inspeccionId,
        punto_maestro_id: props.punto.id,
        nomenclatura: props.punto.nomenclatura,
        coordenada_x: props.punto.coordenada_x,
        coordenada_y: props.punto.coordenada_y,
        tiene_placa_caracteristicas: true,
      })
      .select('*')
      .single();
    
    if (createError) {
      console.error("Error crítico al crear el punto de inspección:", createError);
      loading.value = false;
      return;
    }
    puntoInspeccionado.value = nuevoPunto;
  }

  const { data: incidenciasData } = await supabase
    .from('incidencias')
    .select('*')
    .eq('punto_inspeccionado_id', puntoInspeccionado.value.id);
    
  incidencias.value = incidenciasData || [];
  loading.value = false;
};

watch(() => props.isOpen, (newVal) => {
  if (newVal) loadData();
});

const handlePlacaStatusChange = async (status) => {
  if (!puntoInspeccionado.value) return;

  await supabase
    .from('puntos_inspeccionados')
    .update({ tiene_placa_caracteristicas: status })
    .eq('id', puntoInspeccionado.value.id);

  const incidenciasPlaca = getIncidenciasForItem(2).value;

  if (status === true) {
    if (incidenciasPlaca.length > 0) {
      const idsToDelete = incidenciasPlaca.map(inc => inc.id);
      await supabase.from('incidencias').delete().in('id', idsToDelete);
      incidencias.value = incidencias.value.filter(inc => !idsToDelete.includes(inc.id));
    }
  } else {
    if (incidenciasPlaca.length === 0) {
      await addIncidencia(2, {
          gravedad: 'verde',
          observaciones: 'No dispone de placa de características.',
      });
    }
  }
};

const handleModificationChange = async (newStatus) => {
    if (!puntoInspeccionado.value) return;

    await supabase
        .from('puntos_inspeccionados')
        .update({ detalle_modificacion: newStatus })
        .eq('id', puntoInspeccionado.value.id);

    const incidenciasModificacion = getIncidenciasForItem(3).value;
    const idsToDelete = incidenciasModificacion.map(inc => inc.id);

    if (idsToDelete.length > 0) {
        await supabase.from('incidencias').delete().in('id', idsToDelete);
        incidencias.value = incidencias.value.filter(inc => !idsToDelete.includes(inc.id));
    }
    
    if (newStatus === 'aumentado') {
        await addIncidencia(3, {
            gravedad: 'ambar',
            observaciones: 'Se ha aumentado el número de módulos y/o niveles.',
        });
    } else if (newStatus === 'disminuido') {
        await addIncidencia(3, {
            gravedad: 'verde',
            observaciones: 'Se ha disminuido el número de módulos y/o niveles.',
        });
    }
};

const getIncidenciasForItem = (itemId) => {
    return computed(() => incidencias.value.filter(inc => inc.item_checklist === itemId));
};

const addIncidencia = async (itemId, defaults = {}) => {
  if (!puntoInspeccionado.value) return;
  const { data: newIncidencia } = await supabase
    .from('incidencias')
    .insert({
      punto_inspeccionado_id: puntoInspeccionado.value.id,
      inspeccion_id: props.inspeccionId,
      item_checklist: itemId,
      gravedad: defaults.gravedad || 'verde',
      observaciones: defaults.observaciones || null
    }).select().single();
    
  if (newIncidencia) {
    incidencias.value.push(newIncidencia);
  }
};

const deleteIncidencia = async (incidenciaId) => {
    const { error } = await supabase.from('incidencias').delete().eq('id', incidenciaId);
    if (!error) {
      incidencias.value = incidencias.value.filter(inc => inc.id !== incidenciaId);
    } else {
      alert("Error al borrar la incidencia: " + error.message);
    }
}

const toggleItemStatus = async (itemId) => {
    if (itemId === 2 || itemId === 3) {
        alert("El estado de este punto se gestiona automáticamente desde las preguntas superiores.");
        return;
    }
    
    const itemIncidencias = getIncidenciasForItem(itemId).value;

    if (itemIncidencias.length > 0) {
        if (confirm(`¿Marcar este punto como "Satisfactorio"? Se borrarán las ${itemIncidencias.length} incidencias registradas.`)) {
            const idsToDelete = itemIncidencias.map(inc => inc.id);
            const { error } = await supabase.from('incidencias').delete().in('id', idsToDelete);
            if (!error) {
                incidencias.value = incidencias.value.filter(inc => !idsToDelete.includes(inc.id));
            }
        }
    } else {
        await addIncidencia(itemId);
    }
};


const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;
  isUploading.value = incidencia.id;
  const fileName = `inspeccion_${props.inspeccionId}/punto_${puntoInspeccionado.value.id}/${Date.now()}_${file.name}`;
  const { error: uploadError } = await supabase.storage.from('incidencias').upload(fileName, file);
  if (uploadError) {
    alert("Error al subir la foto: " + uploadError.message);
    isUploading.value = null;
    return;
  }
  const { data: { publicUrl } } = supabase.storage.from('incidencias').getPublicUrl(fileName);
  incidencia.url_foto_antes = publicUrl;
  await saveIncidencia(incidencia);
  isUploading.value = null;
};

const saveIncidencia = async (incidencia) => {
  const { id, ...dataToUpdate } = incidencia;
  await supabase.from('incidencias').update(dataToUpdate).eq('id', id);
};

const handleClose = () => {
  emit('save');
  emit('close');
};
</script>

<template>
  <div v-if="isOpen" @click.self="handleClose" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-slate-50 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
      <header class="p-4 border-b bg-white rounded-t-lg flex justify-between items-center">
        <h2 class="text-xl font-bold text-slate-800">Checklist para Punto: {{ punto?.nomenclatura }}</h2>
        <button @click="handleClose" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
      </header>
      
      <main class="flex-1 overflow-y-auto p-6 space-y-3">
        <div v-if="loading" class="text-center p-10">Cargando datos del punto...</div>
        <div v-else>
          <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-6">
            <h3 class="font-bold text-blue-800 mb-3">¿Dispone de placa de características?</h3>
            <div class="flex gap-4">
              <button @click="tienePlaca = true" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === true ? 'bg-green-600 text-white shadow-md ring-2 ring-offset-2 ring-green-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><CheckCircleIcon class="h-5 w-5" />Sí, dispone de placa</button>
              <button @click="tienePlaca = false" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === false ? 'bg-red-600 text-white shadow-md ring-2 ring-offset-2 ring-red-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><XCircleIcon class="h-5 w-5" />No, no dispone de placa</button>
            </div>
            <p v-if="tienePlaca !== null" class="text-xs text-slate-500 mt-3 text-center">El estado del punto "2. Tiene las placas de identificación..." se ha actualizado automáticamente.</p>
          </div>

          <div class="bg-orange-50 border-2 border-orange-200 rounded-lg p-4 mb-6">
            <h3 class="font-bold text-orange-800 mb-3">¿Ha habido alguna modificación en los módulos/niveles?</h3>
            <div class="grid grid-cols-3 gap-4">
              <button @click="detalleModificacion = 'aumentado'" :class="['flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', detalleModificacion === 'aumentado' ? 'bg-amber-500 text-white shadow-md ring-2 ring-offset-2 ring-amber-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><ArrowTrendingUpIcon class="h-5 w-5" />Ha aumentado</button>
              <button @click="detalleModificacion = 'disminuido'" :class="['flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', detalleModificacion === 'disminuido' ? 'bg-teal-500 text-white shadow-md ring-2 ring-offset-2 ring-teal-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><ArrowTrendingDownIcon class="h-5 w-5" />Ha disminuido</button>
              <button @click="detalleModificacion = null" :class="['flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', detalleModificacion === null ? 'bg-slate-600 text-white shadow-md ring-2 ring-offset-2 ring-slate-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><StopCircleIcon class="h-5 w-5" />No ha cambiado</button>
            </div>
            <p v-if="detalleModificacion !== undefined" class="text-xs text-slate-500 mt-3 text-center">El estado del punto "3. El número de módulos y niveles..." se ha actualizado automáticamente.</p>
          </div>

          <div v-for="item in checklistItems" :key="item.id" class="bg-white rounded-lg shadow-sm border transition-all duration-300">
            <div class="p-3 flex items-center justify-between">
              <p class="text-slate-700">{{ item.id }}. {{ item.text }}</p>
              <button 
                @click="toggleItemStatus(item.id)"
                :disabled="item.id === 2 || item.id === 3"
                :class="['px-3 py-1 text-xs font-bold rounded-full disabled:cursor-not-allowed disabled:bg-slate-200 disabled:text-slate-500', 
                         getIncidenciasForItem(item.id).value.length > 0 ? 'bg-red-100 text-red-800 hover:bg-red-200' : 'bg-green-100 text-green-800 hover:bg-green-200']"
              >
                {{ getIncidenciasForItem(item.id).value.length > 0 ? 'INSATISFACTORIO' : 'SATISFACTORIO' }}
              </button>
            </div>
            
            <div v-if="getIncidenciasForItem(item.id).value.length > 0" class="border-t bg-slate-50 p-4 space-y-4">
              <div v-if="item.id === 2" class="text-center text-sm text-slate-600 bg-slate-200 p-2 rounded-md">
                 Este parámetro se gestiona automáticamente desde las preguntas superiores.
              </div>
              <div v-for="(incidencia, index) in getIncidenciasForItem(item.id).value" :key="incidencia.id" class="bg-white border rounded-lg p-4 shadow-sm relative">
                <div class="flex justify-between items-center mb-3">
                  <h4 class="font-bold text-slate-700">Incidencia #{{ index + 1 }}</h4>
                  <button v-if="item.id !== 2 && item.id !== 3" @click="deleteIncidencia(incidencia.id)" title="Borrar esta incidencia" class="p-1 text-slate-400 hover:text-red-500"><TrashIcon class="h-5 w-5"/></button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div class="space-y-4">
                    <div>
                      <label class="block text-xs font-medium text-slate-600">Gravedad</label>
                      <!-- ===== INICIO DE LA CORRECCIÓN: Se quita la condición item.id === 3 ===== -->
                      <select v-model="incidencia.gravedad" @change="saveIncidencia(incidencia)" :disabled="item.id === 2" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm disabled:bg-slate-200"><option v-for="opt in gravedadOptions" :key="opt.value" :value="opt.value">{{ opt.label }}</option></select>
                      <!-- ===== FIN DE LA CORRECCIÓN ===== -->
                    </div>
                    <div>
                      <label class="block text-xs font-medium text-slate-600">Observaciones</label>
                      <!-- ===== INICIO DE LA CORRECCIÓN: Se quita la condición item.id === 3 ===== -->
                      <textarea v-model="incidencia.observaciones" @blur="saveIncidencia(incidencia)" rows="3" :disabled="item.id === 2" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm disabled:bg-slate-200"></textarea>
                      <!-- ===== FIN DE LA CORRECCIÓN ===== -->
                    </div>
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Foto de la Incidencia</label>
                    <div v-if="item.id === 2" class="aspect-video bg-slate-200 rounded-md flex items-center justify-center text-center p-4"><p class="text-sm text-slate-600">No se requiere fotografía para esta incidencia.</p></div>
                    <div v-else class="aspect-video bg-slate-200 rounded-md flex items-center justify-center overflow-hidden relative group">
                      <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="object-cover w-full h-full">
                      <div v-else class="text-center">
                        <p v-if="isUploading === incidencia.id" class="text-sm text-slate-600">Subiendo...</p>
                        <label v-else :for="'fileInput-' + incidencia.id" class="cursor-pointer flex items-center gap-2 px-3 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700"><ArrowUpTrayIcon class="h-4 w-4" />Subir Foto</label>
                        <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id">
                      </div>
                      <div v-if="incidencia.url_foto_antes" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                         <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-change-' + incidencia.id">
                         <label :for="'fileInput-change-' + incidencia.id" class="cursor-pointer text-white text-sm font-semibold">Cambiar Foto</label>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div v-if="item.id !== 2 && item.id !== 3">
                <button @click="addIncidencia(item.id)" class="w-full flex items-center justify-center gap-2 py-2 text-sm font-semibold text-blue-700 bg-blue-50 rounded-md hover:bg-blue-100 border border-dashed border-blue-300"><PlusCircleIcon class="h-5 w-5"/>Añadir otra incidencia a este parámetro</button>
              </div>

            </div>
          </div>
        </div>
      </main>

      <footer class="p-4 bg-white border-t rounded-b-lg flex justify-end">
        <button @click="handleClose" class="px-5 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Cerrar</button>
      </footer>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/ChecklistModal.vue ---

--- INICIO DEL ARCHIVO: src/components/AddPointForm.vue ---
<!-- src/components/AddPointForm.vue -->
<script setup>
import { ref } from 'vue';

defineProps({
  salas: {
    type: Array,
    required: true
  }
});

const emit = defineEmits(['save', 'cancel']);

const selectedSalaId = ref(null);

const handleSave = () => {
  if (!selectedSalaId.value) {
    alert("Por favor, selecciona una sala.");
    return;
  }
  emit('save', selectedSalaId.value);
};
</script>

<template>
  <div class="p-2 bg-slate-50 rounded-lg">
    <h4 class="font-bold text-sm mb-2">Añadir Nuevo Punto</h4>
    <select v-model="selectedSalaId" class="block w-full rounded-md border-slate-300 shadow-sm text-sm mb-2">
      <option :value="null" disabled>Selecciona una sala...</option>
      <option v-for="sala in salas" :key="sala.id" :value="sala.id">{{ sala.nombre }}</option>
    </select>
    <div class="flex gap-2">
      <button @click="$emit('cancel')" class="w-full text-sm py-1 px-2 rounded bg-white border hover:bg-slate-50">Cancelar</button>
      <button @click="handleSave" class="w-full text-sm py-1 px-2 rounded bg-blue-600 text-white hover:bg-blue-700">Guardar</button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/AddPointForm.vue ---

--- INICIO DEL ARCHIVO: src/components/Login.vue ---
<!-- src/components/Login.vue -->
<script setup>
import { ref } from 'vue'
import { supabase } from '../supabase'
import { useRouter } from 'vue-router'

const router = useRouter()
const loading = ref(false)
const email = ref('')
const password = ref('')

const handleLogin = async () => {
  try {
    loading.value = true
    const { error } = await supabase.auth.signInWithPassword({
      email: email.value,
      password: password.value,
    })
    if (error) throw error
    router.push('/dashboard')
  } catch (error) {
    alert(error.error_description || error.message)
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <!-- Cambiamos los colores de fondo y texto principales -->
  <div class="flex items-center justify-center min-h-screen bg-gray-100 text-gray-800">
    <!-- El contenedor del formulario ahora es blanco con una sombra sutil -->
    <div class="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
      <h1 class="text-3xl font-bold text-center text-gray-900">Inspección de Estanterías</h1>
      <p class="text-center text-gray-600">Inicia sesión para continuar</p>
      <form @submit.prevent="handleLogin" class="space-y-6">
        <div>
          <label for="email" class="block text-sm font-medium text-gray-700">Email</label>
          <!-- Los inputs ahora tienen un fondo más claro -->
          <input 
            id="email" 
            type="email" 
            v-model="email" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="email"
            required
          />
        </div>
        <div>
          <label for="password" class="block text-sm font-medium text-gray-700">Contraseña</label>
          <input 
            id="password" 
            type="password" 
            v-model="password" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="current-password"
            required
          />
        </div>
        <div>
          <button 
            type="submit" 
            :disabled="loading" 
            class="w-full py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            {{ loading ? 'Cargando...' : 'Acceder' }}
          </button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/Login.vue ---

--- INICIO DEL ARCHIVO: src/components/NomenclatureModal.vue ---
<!-- src/components/NomenclatureModal.vue -->
<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
  isOpen: Boolean,
  salaNombre: String,
  suggestedNumber: Number,
  existingNumbers: {
    type: Array,
    default: () => []
  }
});

const emit = defineEmits(['save', 'close']);
const pointNumber = ref('');
const error = ref('');

watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    pointNumber.value = props.suggestedNumber;
    error.value = '';
  }
});

const handleSave = () => {
  error.value = '';
  const num = parseInt(pointNumber.value, 10);

  if (isNaN(num) || num <= 0) {
    error.value = 'Por favor, introduce un número válido.';
    return;
  }

  if (props.existingNumbers.includes(num)) {
    error.value = `El punto número ${num} ya existe en esta sala.`;
    return;
  }

  emit('save', num);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-sm">
      <div class="p-6">
        <h2 class="text-lg font-bold text-slate-800">Añadir Nuevo Punto</h2>
        <p class="text-sm text-slate-500 mt-1">
          Introduce el número para el nuevo punto en la sala <span class="font-semibold">{{ salaNombre }}</span>.
        </p>
        <div class="mt-4">
          <label for="pointNumber" class="block text-sm font-medium text-slate-700">Número del Punto</label>
          <input
            v-model="pointNumber"
            type="number"
            id="pointNumber"
            @keyup.enter="handleSave"
            class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          >
          <p v-if="error" class="mt-2 text-sm text-red-600">{{ error }}</p>
        </div>
      </div>
      <div class="p-4 bg-slate-50 border-t flex justify-end space-x-3">
        <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          Cancelar
        </button>
        <button type="button" @click="handleSave" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
          Guardar Punto
        </button>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/NomenclatureModal.vue ---

--- INICIO DEL ARCHIVO: src/components/MarkAsSentModal.vue ---
<!-- src/components/MarkAsSentModal.vue -->
<script setup>
import { ref, watch } from 'vue';
import { PaperAirplaneIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  inspeccionId: Number,
});

const emit = defineEmits(['close', 'save']);

const formData = ref({
  fecha_envio: '',
  responsable_envio: '',
});

// Cuando el modal se abre, pre-rellenamos la fecha con el día de hoy
watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    formData.value = {
      fecha_envio: new Date().toISOString().slice(0, 10), // Formato YYYY-MM-DD
      responsable_envio: '',
    };
  }
});

const handleSubmit = () => {
  if (!formData.value.fecha_envio || !formData.value.responsable_envio) {
    alert('Por favor, completa todos los campos.');
    return;
  }
  emit('save', formData.value);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md transform transition-all">
      <div class="p-6 border-b border-slate-200 text-center">
        <div class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
            <PaperAirplaneIcon class="h-6 w-6 text-blue-600" aria-hidden="true" />
        </div>
        <h2 class="mt-4 text-xl font-bold text-slate-800">Confirmar Envío a Cliente</h2>
        <p class="text-sm text-slate-500 mt-1">Registra la fecha y el responsable del envío.</p>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 space-y-4">
          <div>
            <label for="fecha_envio" class="block text-sm font-medium text-slate-600">Fecha de Envío</label>
            <input 
              v-model="formData.fecha_envio" 
              type="date" 
              id="fecha_envio" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
          <div>
            <label for="responsable_envio" class="block text-sm font-medium text-slate-600">Enviado por</label>
            <input 
              v-model="formData.responsable_envio" 
              type="text" 
              id="responsable_envio" 
              placeholder="Nombre del responsable" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
        </div>
        <div class="p-4 bg-slate-50 border-t border-slate-200 flex justify-end space-x-3">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar y Marcar</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/MarkAsSentModal.vue ---

--- INICIO DEL ARCHIVO: src/components/CentroFormModal.vue ---
<!-- src/components/CentroFormModal.vue -->
<script setup>
import { ref, watch, nextTick } from 'vue';
import { provincias } from '../utils/provincias';
import { supabase } from '../supabase';
import { ArrowUpTrayIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  isOpen: Boolean,
  centro: Object,
});

const emit = defineEmits(['close', 'save']);

const form = ref({});
const isUploadingLogo = ref(false);
const logoInput = ref(null); // Referencia para el input de tipo file
const zonas = ['Norte', 'Sur', 'Este', 'Oeste', 'Centro', 'Noreste', 'Noroeste', 'Sureste', 'Islas Baleares', 'Islas Canarias'];

watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    // Usamos un clon del objeto para no modificar el original hasta guardar
    form.value = props.centro ? { ...props.centro } : { nombre: '', direccion: '', responsable_nombre: '', responsable_email: '', provincia: '', zona: '', url_logo_cliente: null };
  }
});

const handleLogoSelected = async (event) => {
  const file = event.target.files[0];
  if (!file || !form.value.id) {
    if(!form.value.id) alert("Guarda primero el centro para poder asignarle un logo.");
    return;
  }
  
  isUploadingLogo.value = true;
  const fileName = `cliente_${form.value.id}/${Date.now()}_${file.name}`;
  
  // Subir el nuevo logo
  const { error: uploadError } = await supabase.storage.from('logos-clientes').upload(fileName, file);
  if (uploadError) {
    alert("Error al subir el logo: " + uploadError.message);
    isUploadingLogo.value = false;
    return;
  }

  // Obtener la URL pública
  const { data: { publicUrl } } = supabase.storage.from('logos-clientes').getPublicUrl(fileName);

  // Actualizar el campo en la BBDD y en el formulario
  const { error: updateError } = await supabase
    .from('centros')
    .update({ url_logo_cliente: publicUrl })
    .eq('id', form.value.id);

  if (updateError) {
    alert("Error al guardar la URL del logo: " + updateError.message);
  } else {
    // Actualizamos el logo en el formulario para que se vea el cambio al instante
    form.value.url_logo_cliente = publicUrl;
  }
  isUploadingLogo.value = false;
};


const handleSubmit = () => {
  // Simplemente emitimos los datos del formulario. La subida del logo es independiente.
  emit('save', form.value);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
      <div class="p-6 border-b">
        <h2 class="text-2xl font-bold text-slate-800">{{ centro ? 'Editar Centro' : 'Agregar Nuevo Centro' }}</h2>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
          <!-- Columna 1 y 2: Campos del formulario -->
          <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="md:col-span-2">
              <label for="nombre" class="block text-sm font-medium text-slate-600">Nombre del Centro</label>
              <input v-model="form.nombre" type="text" id="nombre" required class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div class="md:col-span-2">
              <label for="direccion" class="block text-sm font-medium text-slate-600">Dirección</label>
              <input v-model="form.direccion" type="text" id="direccion" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_nombre" class="block text-sm font-medium text-slate-600">Nombre del Responsable</label>
              <input v-model="form.responsable_nombre" type="text" id="responsable_nombre" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_email" class="block text-sm font-medium text-slate-600">Email del Responsable</label>
              <input v-model="form.responsable_email" type="email" id="responsable_email" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="provincia" class="block text-sm font-medium text-slate-600">Provincia</label>
              <select v-model="form.provincia" id="provincia" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <option disabled value="">Selecciona una provincia</option>
                <option v-for="p in provincias" :key="p" :value="p">{{ p }}</option>
              </select>
            </div>
            <div>
              <label for="zona" class="block text-sm font-medium text-slate-600">Zona</label>
              <select v-model="form.zona" id="zona" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <option disabled value="">Selecciona una zona</option>
                <option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
              </select>
            </div>
          </div>
          
          <!-- Columna 3: Logo del Cliente -->
          <div class="md:col-span-1">
             <input type="file" ref="logoInput" @change="handleLogoSelected" accept="image/*" class="hidden">
             <label class="block text-sm font-medium text-slate-600 mb-1">Logo del Cliente</label>
             <div class="aspect-video bg-slate-100 rounded-md flex items-center justify-center border-2 border-dashed">
                <img v-if="form.url_logo_cliente" :src="form.url_logo_cliente" class="object-contain w-full h-full p-2">
                <div v-else class="text-center text-slate-500 p-4">Sin logo</div>
             </div>
             <button 
                type="button" 
                @click="logoInput.click()" 
                :disabled="!form.id || isUploadingLogo"
                class="mt-2 w-full flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold rounded-md transition-colors
                       disabled:bg-slate-200 disabled:text-slate-500 disabled:cursor-not-allowed
                       text-slate-700 bg-white border border-slate-300 hover:bg-slate-50"
              >
               <ArrowUpTrayIcon class="h-4 w-4" />
               {{ isUploadingLogo ? 'Subiendo...' : (form.url_logo_cliente ? 'Cambiar Logo' : 'Subir Logo') }}
             </button>
             <p v-if="!form.id" class="text-xs text-slate-500 mt-1 text-center">Debes guardar el centro antes de subir un logo.</p>
          </div>
        </div>
        <div class="p-6 bg-slate-50 border-t flex justify-end space-x-4">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar Cambios</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/CentroFormModal.vue ---

--- INICIO DEL ARCHIVO: src/components/PlanoBadge.vue ---
<!-- src/components/PlanoBadge.vue -->
<template>
  <div
    class="w-full h-full p-1 flex flex-col items-center bg-white rounded-lg shadow-lg border border-gray-300 cursor-move font-sans"
  >
    <div class="font-bold text-center text-xs text-gray-800">Punto {{ pointNumber }}</div>
    <hr class="w-11/12 my-1 border-t border-gray-200">
    
    <div v-if="stateText" class="font-bold text-center text-[10px] text-gray-600 mb-1">
      {{ stateText }}
    </div>

    <!-- Sección Semáforos -->
    <div class="flex-1 w-full flex flex-col justify-center items-center space-y-1 px-2 pb-1">
      <div v-for="item in semaphoreItems" :key="item.label" class="relative w-full flex justify-between items-center">
        
        <!-- INICIO DE LA CORRECCIÓN: Fondo sólido para el semáforo -->
        <div class="absolute inset-0 bg-white/70 backdrop-blur-[1px] rounded-sm"></div>
        <!-- FIN DE LA CORRECCIÓN -->

        <!-- Elementos del semáforo, ahora por encima del fondo -->
        <div class="relative w-3 h-3 rounded-full" :style="{ backgroundColor: item.color }"></div>
        <div class="relative font-semibold text-sm text-right text-gray-700">{{ item.count }}</div>

      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  pointData: Object
});

const pointNumber = computed(() => props.pointData.nomenclatura.split('-').pop() || '?');

const stateText = computed(() => {
  if (props.pointData.estado === 'nuevo') return 'NUEVA';
  if (props.pointData.estado === 'suprimido') return 'SUPRIMIDA';
  if (props.pointData.detalle_modificacion === 'aumentado') return 'AUMENTADA';
  if (props.pointData.detalle_modificacion === 'disminuido') return 'DISMINUIDA';
  return null;
});

const semaphoreItems = computed(() => [
  { label: 'verde', color: '#22C55E', count: props.pointData.counts.verde },
  { label: 'ambar', color: '#F59E0B', count: props.pointData.counts.ambar },
  { label: 'rojo', color: '#EF4444', count: props.pointData.counts.rojo },
]);
</script>
--- FIN DEL ARCHIVO: src/components/PlanoBadge.vue ---

--- INICIO DEL ARCHIVO: src/components/Notification.vue ---
<!-- src/components/Notification.vue -->
<script setup>
import { CheckCircleIcon, XCircleIcon } from '@heroicons/vue/24/solid';

defineProps({
  show: Boolean,
  message: String,
  type: {
    type: String,
    default: 'success', // 'success' o 'error'
  },
});
</script>

<template>
  <div
    aria-live="assertive"
    class="pointer-events-none fixed inset-0 flex items-end px-4 py-6 sm:items-start sm:p-6 z-[100]"
  >
    <div class="flex w-full flex-col items-center space-y-4 sm:items-end">
      <transition
        enter-active-class="transform ease-out duration-300 transition"
        enter-from-class="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
        enter-to-class="translate-y-0 opacity-100 sm:translate-x-0"
        leave-active-class="transition ease-in duration-100"
        leave-from-class="opacity-100"
        leave-to-class="opacity-0"
      >
        <div
          v-if="show"
          class="pointer-events-auto w-full max-w-sm overflow-hidden rounded-lg bg-white shadow-lg ring-1 ring-black ring-opacity-5"
        >
          <div class="p-4">
            <div class="flex items-start">
              <div class="flex-shrink-0">
                <CheckCircleIcon v-if="type === 'success'" class="h-6 w-6 text-green-400" aria-hidden="true" />
                <XCircleIcon v-if="type === 'error'" class="h-6 w-6 text-red-400" aria-hidden="true" />
              </div>
              <div class="ml-3 w-0 flex-1 pt-0.5">
                <p class="text-sm font-medium text-gray-900">
                  {{ type === 'success' ? 'Éxito' : 'Error' }}
                </p>
                <p class="mt-1 text-sm text-gray-500">
                  {{ message }}
                </p>
              </div>
            </div>
          </div>
        </div>
      </transition>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/Notification.vue ---

--- INICIO DEL ARCHIVO: src/components/InteractiveMap.vue ---
<!-- src/components/InteractiveMap.vue -->
<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';

const props = defineProps({
  imageUrl: { type: String, required: true },
  points: { type: Array, default: () => [] },
  salas: { type: Array, default: () => [] },
  isReadOnly: { type: Boolean, default: false },
  isPlacementMode: { type: Boolean, default: false },
  isAreaDrawingMode: { type: Boolean, default: false },
});

const emit = defineEmits(['add-point', 'delete-point', 'update-point-position', 'point-click', 'area-drawn', 'drawing-cancelled']);

const overlayRef = ref(null);
const draggedPointId = ref(null);
const drawingPoints = ref([]);
const mousePosition = ref({ x: 0, y: 0 });

watch(() => props.isAreaDrawingMode, (newVal) => {
  if (!newVal) {
    drawingPoints.value = [];
  }
});

const toSvgPoints = (pointsArray, overlayWidth, overlayHeight) => {
  if (!pointsArray || pointsArray.length === 0 || !overlayWidth || !overlayHeight) return "";
  return pointsArray.map(p => `${p.x * overlayWidth},${p.y * overlayHeight}`).join(' ');
};

const handleMapClick = (event) => {
  if (!overlayRef.value) return;
  const overlayRect = overlayRef.value.getBoundingClientRect();
  const x = (event.clientX - overlayRect.left) / overlayRect.width;
  const y = (event.clientY - overlayRect.top) / overlayRect.height;
  
  if (props.isAreaDrawingMode) {
    if (drawingPoints.value.length > 2) {
      const firstPoint = drawingPoints.value[0];
      const distance = Math.sqrt(Math.pow((x - firstPoint.x), 2) + Math.pow((y - firstPoint.y), 2));
      if (distance < 0.02) {
        emit('area-drawn', drawingPoints.value);
        drawingPoints.value = [];
        return;
      }
    }
    drawingPoints.value.push({ x, y });
  } else if (props.isPlacementMode) {
    emit('add-point', { x, y });
  }
};

const handleMouseMove = (event) => {
    if (!props.isAreaDrawingMode || !overlayRef.value) return;
    const overlayRect = overlayRef.value.getBoundingClientRect();
    mousePosition.value.x = event.clientX - overlayRect.left;
    mousePosition.value.y = event.clientY - overlayRect.top;
};

const handleKeydown = (e) => {
    if (e.key === 'Escape' && props.isAreaDrawingMode) {
        drawingPoints.value = [];
        emit('drawing-cancelled');
    }
};

onMounted(() => window.addEventListener('keydown', handleKeydown));
onUnmounted(() => window.removeEventListener('keydown', handleKeydown));

const getSalaColor = (salaId) => {
  const sala = props.salas.find(s => s.id === salaId);
  return sala ? sala.color : '#9CA3AF';
};

const startDrag = (point) => {
  if (props.isReadOnly) return;
  draggedPointId.value = point.id;
};

const onDrag = (event) => {
  if (props.isReadOnly || draggedPointId.value === null || !overlayRef.value) return;
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (!point) return;
  const overlayRect = overlayRef.value.getBoundingClientRect();
  point.coordenada_x = (event.clientX - overlayRect.left) / overlayRect.width;
  point.coordenada_y = (event.clientY - overlayRect.top) / overlayRect.height;
};

const stopDrag = () => {
  if (draggedPointId.value === null) return;
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (point) {
    emit('update-point-position', point);
  }
  draggedPointId.value = null;
};

const handleDeleteClick = (point) => {
  emit('delete-point', point);
};

const handlePointClick = (point) => {
  if (props.isPlacementMode || props.isAreaDrawingMode) return;
  emit('point-click', point);
};
</script>

<template>
  <div 
    class="relative"
    @mousemove="onDrag"
    @mouseup="stopDrag"
    @mouseleave="stopDrag"
  >
    <div class="relative max-w-full max-h-full">
      <img :src="imageUrl" class="block max-w-full max-h-full object-contain pointer-events-none" alt="Plano del centro">
      <div
        ref="overlayRef"
        class="absolute inset-0"
        :class="{ 'cursor-crosshair': isPlacementMode || isAreaDrawingMode }"
        @click="handleMapClick"
        @mousemove="handleMouseMove"
      >
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none">
          <template v-for="sala in salas" :key="`sala-area-${sala.id}`">
            <polygon
              v-if="sala.area_puntos && overlayRef"
              :points="toSvgPoints(sala.area_puntos, overlayRef.clientWidth, overlayRef.clientHeight)"
              :style="{ fill: `${getSalaColor(sala.id)}33`, stroke: getSalaColor(sala.id), strokeWidth: '2px' }"
            />
          </template>

          <g v-if="isAreaDrawingMode && overlayRef">
            <polyline 
              :points="toSvgPoints(drawingPoints, overlayRef.clientWidth, overlayRef.clientHeight)"
              style="fill: none; stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <line 
              v-if="drawingPoints.length > 0"
              :x1="drawingPoints[drawingPoints.length - 1].x * overlayRef.clientWidth"
              :y1="drawingPoints[drawingPoints.length - 1].y * overlayRef.clientHeight"
              :x2="mousePosition.x"
              :y2="mousePosition.y"
              style="stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <circle
              v-for="(point, index) in drawingPoints"
              :key="`drawing-point-${index}`"
              :cx="point.x * overlayRef.clientWidth"
              :cy="point.y * overlayRef.clientHeight"
              r="5"
              :class="index === 0 ? 'fill-green-500 stroke-white' : 'fill-blue-500 stroke-white'"
              style="stroke-width: 2px;"
            />
          </g>
        </svg>

        <div
          v-for="point in points"
          :key="point.id"
          class="absolute w-8 h-8 -translate-x-1/2 -translate-y-1/2 border-2 border-white rounded-full flex items-center justify-center text-white text-xs font-bold group shadow-lg pointer-events-auto"
          :class="{ 
            'cursor-grab active:cursor-grabbing': !isReadOnly, 
            'cursor-pointer hover:scale-110 transition-transform': isReadOnly 
          }"
          :style="{ 
            left: (point.coordenada_x * 100) + '%', 
            top: (point.coordenada_y * 100) + '%',
            backgroundColor: point.color || getSalaColor(point.sala_id)
          }"
          @mousedown.stop="startDrag(point)"
          @click.stop="handlePointClick(point)"
        >
          {{ point.nomenclatura.split('-').pop() || '?' }}
          <button 
            v-if="!isReadOnly && (point.estado === 'nuevo' || point.estado === undefined)"
            @click.stop="handleDeleteClick(point)"
            class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 text-white rounded-full text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
            title="Borrar punto"
          >X</button>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/components/InteractiveMap.vue ---

--- INICIO DEL ARCHIVO: src/assets/vue.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
--- FIN DEL ARCHIVO: src/assets/vue.svg ---

--- INICIO DEL ARCHIVO: src/views/CentrosListView.vue ---
<!-- src/views/CentrosListView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import { PlusIcon, PencilIcon, MapPinIcon, ArchiveBoxIcon, DocumentDuplicateIcon } from '@heroicons/vue/24/solid';
import CentroFormModal from '../components/CentroFormModal.vue';

const centros = ref([]);
const loading = ref(true);
const isModalOpen = ref(false);
const selectedCentro = ref(null);
const filterZona = ref('');

const zonas = ['Norte', 'Sur', 'Este', 'Oeste', 'Centro', 'Noreste', 'Noroeste', 'Sureste', 'Islas Baleares', 'Islas Canarias'];

const filteredCentros = computed(() => {
  if (!filterZona.value) return centros.value;
  return centros.value.filter(c => c.zona === filterZona.value);
});

const openCreateModal = () => {
  selectedCentro.value = null;
  isModalOpen.value = true;
};

const openEditModal = (centro) => {
  selectedCentro.value = centro;
  isModalOpen.value = true;
};

const handleSaveCentro = async (centroData) => {
  const dataToSave = { ...centroData };
  let error;
  if (dataToSave.id) {
    const { error: updateError } = await supabase.from('centros').update(dataToSave).eq('id', dataToSave.id);
    error = updateError;
  } else {
    delete dataToSave.id;
    const { error: insertError } = await supabase.from('centros').insert(dataToSave);
    error = insertError;
  }
  if (error) alert(error.message);
  else {
    isModalOpen.value = false;
    fetchCentros();
  }
};

const fetchCentros = async () => {
  loading.value = true;
  const { data } = await supabase.from('centros').select('*').order('nombre');
  if (data) centros.value = data;
  loading.value = false;
};

onMounted(fetchCentros);
</script>

<template>
  <div class="p-8">
    <div class="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
      <h1 class="text-4xl font-bold text-slate-800">Maestro de Centros</h1>
      <div class="flex items-center gap-4">
        <select v-model="filterZona" class="rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm">
          <option value="">Todas las Zonas</option>
          <option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
        </select>
        <button @click="openCreateModal" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm">
          <PlusIcon class="h-5 w-5" />
          Agregar Centro
        </button>
      </div>
    </div>
    
    <div v-if="loading" class="text-center text-slate-500">Cargando...</div>
    <div v-else class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
      <div class="min-w-full">
        <div class="hidden md:grid grid-cols-12 gap-4 px-6 py-4 bg-slate-50 border-b border-slate-200">
          <div class="col-span-4 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Centro / Dirección</div>
          <div class="col-span-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Responsable</div>
          <div class="col-span-2 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Zona</div>
          <div class="col-span-3 text-right text-xs font-semibold text-slate-500 uppercase tracking-wider">Acciones</div>
        </div>

        <ul class="divide-y divide-slate-200">
          <li v-for="centro in filteredCentros" :key="centro.id" class="px-6 py-4 grid grid-cols-1 md:grid-cols-12 gap-4 items-center">
            <div class="col-span-1 md:col-span-4">
              <p class="text-lg font-bold text-slate-900">{{ centro.nombre }}</p>
              <p class="text-sm text-slate-500">{{ centro.direccion }}</p>
            </div>
            <div class="col-span-1 md:col-span-3">
              <p class="text-sm font-medium text-slate-800">{{ centro.responsable_nombre }}</p>
              <p class="text-sm text-slate-500">{{ centro.responsable_email }}</p>
            </div>
            <div class="col-span-1 md:col-span-2">
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800">
                {{ centro.zona }}
              </span>
            </div>
            <div class="col-span-1 md:col-span-3 flex justify-end items-center flex-wrap gap-2">
              <button @click="openEditModal(centro)" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <PencilIcon class="h-4 w-4" />
                Editar
              </button>
              <router-link :to="`/centros/${centro.id}/historial`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <ArchiveBoxIcon class="h-4 w-4" />
                Historial
              </router-link>
              <!-- === CAMBIO: El botón ahora apunta a la nueva vista de versiones === -->
              <router-link :to="`/centros/${centro.id}/versiones`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
                <DocumentDuplicateIcon class="h-4 w-4" />
                Planos
              </router-link>
            </div>
          </li>
        </ul>
      </div>
    </div>

    <CentroFormModal :is-open="isModalOpen" :centro="selectedCentro" @close="isModalOpen = false" @save="handleSaveCentro" />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentrosListView.vue ---

--- INICIO DEL ARCHIVO: src/views/SubsanacionView.vue ---
<!-- src/views/SubsanacionView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';
import { generateTextReport } from '../utils/pdf';
import { ArrowUpTrayIcon, CheckCircleIcon } from '@heroicons/vue/24/solid';

const showNotification = inject('showNotification');
const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const isFinalizing = ref(false);
const inspeccion = ref(null);
const incidencias = ref([]);
const isUploading = ref(null);

onMounted(async () => {
  loading.value = true;
  const { data: inspectionData } = await supabase.from('inspecciones').select('*, centros(nombre, id)').eq('id', inspeccionId).single();
  inspeccion.value = inspectionData;
  const { data: incidenciasData } = await supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId).neq('item_checklist', 2).order('item_checklist', { ascending: true });
  incidencias.value = incidenciasData || [];
  loading.value = false;
});

const getItemText = (itemId) => {
  const item = checklistItems.find(i => i.id === itemId);
  return item ? `${item.id}. ${item.text}` : 'Item desconocido';
};
const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;
  isUploading.value = incidencia.id;
  const fileName = `subsanacion_${inspeccionId}/incidencia_${incidencia.id}/${Date.now()}_${file.name}`;
  const { error: uploadError } = await supabase.storage.from('incidencias').upload(fileName, file, { upsert: true });
  if (uploadError) {
    showNotification("Error al subir la foto: " + uploadError.message, 'error');
    isUploading.value = null;
    return;
  }
  const { data: { publicUrl } } = supabase.storage.from('incidencias').getPublicUrl(fileName);
  const { error: updateError } = await supabase.from('incidencias').update({ url_foto_despues: publicUrl }).eq('id', incidencia.id);
  if (updateError) {
    showNotification("Error al guardar la URL: " + updateError.message, 'error');
  } else {
    incidencia.url_foto_despues = publicUrl;
  }
  isUploading.value = null;
};
const todasSubsanadas = computed(() => {
  if (incidencias.value.length === 0) return true;
  return incidencias.value.every(inc => !!inc.url_foto_despues);
});

function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      const dataUrl = reader.result;
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    reader.readAsDataURL(blob);
  });
}

const finalizarSubsanacion = async () => {
  if (!confirm('¿Estás seguro de que quieres generar el informe final, archivarlo y cerrar esta inspección?')) {
      return;
  }
  isFinalizing.value = true;
  try {
    const report = await generateTextReport(inspeccionId, 'remediation', 'blob');
    if (!report || !report.blob) throw new Error("La generación del PDF de subsanación falló.");

    const base64File = await blobToBase64(report.blob);

    const centroId = inspeccion.value.centros.id;
    const fileNameWithId = `${inspeccionId}-${report.fileName}`;
    const finalFileName = `centro_${centroId}/${fileNameWithId}`;

    console.log("Invocando función Edge 'upload-pdf-to-b2' para subsanación con la ruta:", finalFileName);
    const { data, error: invokeError } = await supabase.functions.invoke('upload-pdf-to-b2', {
      body: { 
        file: base64File,
        // --- INICIO DE LA CORRECCIÓN ---
        fileName: finalFileName,
        // --- FIN DE LA CORRECCIÓN ---
        contentType: 'application/pdf'
      }
    });

    if (invokeError) throw new Error(`Error al contactar con la función Edge: ${invokeError.message}.`);
    if (data.error) throw new Error(data.error);
    if (!data.publicUrl) throw new Error('La función Edge no devolvió una URL válida.');
    
    const publicUrl = data.publicUrl;
    
    const { error: updateError } = await supabase.from('inspecciones').update({ estado: 'cerrada', url_pdf_informe_final: publicUrl }).eq('id', inspeccionId);
    if (updateError) throw updateError;
    
    showNotification('Inspección cerrada y archivada con éxito.');
    router.push(`/centros/${inspeccion.value.centros.id}/historial`);
  } catch (error) {
    console.error("Error al finalizar subsanación:", error);
    showNotification('Ocurrió un error al finalizar la subsanación: ' + error.message, 'error');
  } finally {
    isFinalizing.value = false;
  }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex items-center justify-center">Cargando datos de subsanación...</div>
    <div v-else-if="inspeccion" class="flex-1 flex flex-col min-h-0">
      <header class="flex-shrink-0 px-4 sm:px-8 pt-6 sm:pt-8 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 class="text-2xl sm:text-3xl font-bold text-slate-800">Gestión de Subsanación</h1>
            <p class="text-lg text-slate-600 mt-1">{{ inspeccion.centros.nombre }}</p>
            <p class="text-sm text-slate-500 mt-1">Inspección del {{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</p>
          </div>
          <div class="flex gap-4 w-full sm:w-auto">
            <button @click="router.go(-1)" class="flex-1 sm:flex-none px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Volver</button>
            <button @click="finalizarSubsanacion" :disabled="!todasSubsanadas || isFinalizing" class="flex-1 sm:flex-none flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
              <CheckCircleIcon class="h-5 w-5" />
              {{ isFinalizing ? 'Finalizando...' : 'Finalizar y Cerrar' }}
            </button>
          </div>
        </div>
      </header>
      <main class="flex-1 overflow-y-auto p-4 sm:p-8">
        <div class="space-y-6 max-w-7xl mx-auto">
          <div v-if="incidencias.length === 0" class="bg-white p-8 rounded-lg shadow-sm text-center">
              <h3 class="text-lg font-medium text-slate-700">¡No hay incidencias que subsanar!</h3>
              <p class="text-slate-500">Esta inspección no tiene incidencias que requieran una foto de subsanación. Puedes cerrarla directamente.</p>
          </div>
          <div v-for="incidencia in incidencias" :key="incidencia.id" class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 class="font-bold text-lg text-slate-800 border-b pb-3 mb-4">{{ getItemText(incidencia.item_checklist) }}</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">ANTES (Incidencia Original)</p>
                <div class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden">
                  <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="w-full h-full object-contain">
                  <p v-else class="text-slate-500 text-sm p-4">No se adjuntó foto de la incidencia.</p>
                </div>
                <div v-if="incidencia.observaciones" class="mt-3 text-sm bg-slate-50 p-3 rounded-md">
                  <strong>Observaciones:</strong> {{ incidencia.observaciones }}
                </div>
              </div>
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">DESPUÉS (Evidencia de Subsanación)</p>
                <div class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden relative group">
                  <img v-if="incidencia.url_foto_despues" :src="incidencia.url_foto_despues" class="w-full h-full object-contain">
                  <div v-else-if="isUploading === incidencia.id" class="text-center text-slate-600">Subiendo foto...</div>
                  <div v-else class="text-center">
                    <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id" accept="image/*">
                    <label :for="'fileInput-' + incidencia.id" class="cursor-pointer flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                      <ArrowUpTrayIcon class="h-4 w-4" />
                      Subir Foto
                    </label>
                  </div>
                   <div v-if="incidencia.url_foto_despues" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                     <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInputChange-' + incidencia.id" accept="image/*">
                     <label :for="'fileInputChange-' + incidencia.id" class="cursor-pointer text-white font-semibold">Cambiar Foto</label>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/SubsanacionView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroHistorialView.vue ---
<!-- src/views/CentroHistorialView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { 
  EyeIcon, 
  TrashIcon, 
  CheckBadgeIcon, 
  PaperAirplaneIcon, 
  WrenchScrewdriverIcon, 
  MapIcon, 
  ArrowDownCircleIcon,
  ArrowUturnLeftIcon
} from '@heroicons/vue/24/outline';
import MarkAsSentModal from '../components/MarkAsSentModal.vue';

const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const loading = ref(true);
const centro = ref(null);
const inspecciones = ref([]);
const isProcessing = ref(null);
const isSentModalOpen = ref(false);
const selectedInspeccion = ref(null);

const estadoInfo = computed(() => (estado) => {
  switch (estado) {
    case 'en_progreso': return { text: 'En Progreso', class: 'bg-blue-100 text-blue-800' };
    case 'finalizada': return { text: 'Pendiente de Envío', class: 'bg-orange-100 text-orange-800' };
    case 'pendiente_subsanacion': return { text: 'Pendiente de Subsanación', class: 'bg-yellow-100 text-yellow-800' };
    case 'cerrada': return { text: 'Cerrada y Subsanada', class: 'bg-green-100 text-green-800' };
    default: return { text: estado, class: 'bg-slate-100 text-slate-800' };
  }
});

const openSentModal = (inspeccion) => {
  selectedInspeccion.value = inspeccion;
  isSentModalOpen.value = true;
};

const handleMarkAsSent = async (formData) => {
  if (!selectedInspeccion.value) return;
  
  isProcessing.value = selectedInspeccion.value.id;
  isSentModalOpen.value = false;

  try {
    const { error } = await supabase
      .from('inspecciones')
      .update({ 
        fecha_envio_cliente: formData.fecha_envio, 
        responsable_envio_cliente: formData.responsable_envio,
        estado: 'pendiente_subsanacion'
      })
      .eq('id', selectedInspeccion.value.id);
    if (error) throw error;
    
    await fetchData();
    alert('Registro de envío guardado con éxito.');
  } catch (error) {
    alert('Error al registrar el envío: ' + error.message);
  } finally {
    isProcessing.value = null;
  }
};

const openArchivedPdf = (url) => {
  if (url) {
    window.open(url, '_blank');
  } else {
    alert('El informe PDF para esta inspección aún no ha sido generado o archivado.');
  }
};

const reabrirInspeccion = async (inspeccion) => {
    if (!confirm(`¿Estás seguro de que quieres reabrir la inspección del ${new Date(inspeccion.fecha_inspeccion).toLocaleDateString()}? El PDF archivado será invalidado y deberás volver a finalizarla.`)) {
        return;
    }
    isProcessing.value = inspeccion.id;
    try {
        const { error } = await supabase
            .from('inspecciones')
            .update({
                estado: 'en_progreso',
                url_pdf_informe_inicial: null,
                url_pdf_informe_final: null
            })
            .eq('id', inspeccion.id);
        if (error) throw error;
        await fetchData();
        alert('Inspección reabierta. Ahora puedes editarla de nuevo.');
    } catch (error) {
        alert('Error al reabrir la inspección: ' + error.message);
    } finally {
        isProcessing.value = null;
    }
}

const fetchData = async () => {
  loading.value = true;
  const { data: centroData } = await supabase.from('centros').select('nombre').eq('id', centroId).single();
  centro.value = centroData;
  const { data: inspeccionesData } = await supabase.from('vista_historial_inspecciones').select('*').eq('centro_id', centroId).order('fecha_inspeccion', { ascending: false });
  inspecciones.value = inspeccionesData || [];
  loading.value = false;
};

const handleDelete = async (inspeccionId) => {
  if (confirm('¿Estás seguro de que quieres borrar esta inspección? Esta acción es permanente y eliminará todos los datos y fotos asociados.')) {
    try {
      const { data: incidencias, error: getError } = await supabase.from('incidencias').select('url_foto_antes, url_foto_despues').eq('inspeccion_id', inspeccionId);
      if (getError) throw getError;
      const filesToDelete = [];
      if (incidencias && incidencias.length > 0) {
        incidencias.forEach(inc => {
          if (inc.url_foto_antes) { const filePath = inc.url_foto_antes.split('/incidencias/')[1]; if (filePath) filesToDelete.push(filePath); }
          if (inc.url_foto_despues) { const filePath = inc.url_foto_despues.split('/incidencias/')[1]; if (filePath) filesToDelete.push(filePath); }
        });
      }
      if (filesToDelete.length > 0) {
        await supabase.storage.from('incidencias').remove(filesToDelete);
      }
      const { error: deleteError } = await supabase.from('inspecciones').delete().eq('id', inspeccionId);
      if (deleteError) throw deleteError;
      inspecciones.value = inspecciones.value.filter(i => i.id !== inspeccionId);
      alert('Inspección borrada con éxito.');
    } catch (error) {
      alert('Ocurrió un error al borrar la inspección: ' + error.message);
    }
  }
};

onMounted(fetchData);
</script>

<template>
  <div class="p-8">
    <div v-if="loading">Cargando...</div>
    <div v-else-if="centro">
      <div class="flex justify-between items-center mb-8">
        <div>
          <h1 class="text-4xl font-bold text-slate-800">Historial de Inspecciones</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <button @click="router.push('/centros')" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">Volver</button>
      </div>
      <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
        <ul class="divide-y divide-slate-200">
          <li v-if="inspecciones.length === 0" class="p-8 text-center text-slate-500">No hay inspecciones.</li>
          <li v-for="inspeccion in inspecciones" :key="inspeccion.id" class="p-4 grid grid-cols-1 lg:grid-cols-5 gap-6 items-center">
            <div class="lg:col-span-1">
              <p class="font-semibold text-slate-800">Fecha Inspección:</p>
              <p class="text-slate-600">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</p>
            </div>
            <div class="lg:col-span-1">
               <p class="font-semibold text-slate-800">Estado General:</p>
               <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium capitalize" :class="estadoInfo(inspeccion.estado).class">
                  {{ estadoInfo(inspeccion.estado).text }}
               </span>
            </div>
            <div class="lg:col-span-1">
              <p class="font-semibold text-slate-800 mb-1">Resumen Incidencias:</p>
              <div class="flex items-center gap-x-3">
                  <div class="flex items-center gap-1.5" title="Leves"><span class="h-2.5 w-2.5 rounded-full bg-green-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.incidencias_verdes }}</span></div>
                  <div class="flex items-center gap-1.5" title="Moderadas"><span class="h-2.5 w-2.5 rounded-full bg-amber-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.incidencias_ambares }}</span></div>
                  <div class="flex items-center gap-1.5" title="Graves"><span class="h-2.5 w-2.5 rounded-full bg-red-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.incidencias_rojas }}</span></div>
              </div>
            </div>
            <div class="lg:col-span-2 flex justify-end items-center flex-wrap gap-2">
              <button v-if="inspeccion.estado === 'finalizada'" @click="openSentModal(inspeccion)" :disabled="isProcessing === inspeccion.id" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-blue-700 bg-blue-50 hover:bg-blue-100 border border-blue-200 disabled:opacity-50">
                <PaperAirplaneIcon class="h-4 w-4" /> 
                Marcar Envío
              </button>
              <router-link v-if="inspeccion.estado === 'pendiente_subsanacion'" :to="`/inspecciones/${inspeccion.id}/subsanar`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-purple-700 bg-purple-50 hover:bg-purple-100 border border-purple-200"><WrenchScrewdriverIcon class="h-4 w-4" /> Subsanar </router-link>
              <router-link :to="`/inspecciones/${inspeccion.id}/plano-preview`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-teal-700 bg-teal-50 hover:bg-teal-100 border border-teal-200">
                  <MapIcon class="h-4 w-4"/>Plano
              </router-link>
              <button @click="openArchivedPdf(inspeccion.url_pdf_informe_inicial)" :disabled="!inspeccion.url_pdf_informe_inicial" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-slate-600 bg-slate-100 hover:bg-slate-200 border border-slate-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <ArrowDownCircleIcon class="h-4 w-4" />
                Informe Inicial
              </button>
              <button v-if="inspeccion.estado === 'cerrada'" @click="openArchivedPdf(inspeccion.url_pdf_informe_final)" :disabled="!inspeccion.url_pdf_informe_final" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-green-700 bg-green-100 hover:bg-green-200 border border-green-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <ArrowDownCircleIcon class="h-4 w-4" />
                Informe Subsanación
              </button>
              <div class="flex items-center gap-1 border-l pl-2 ml-2">
                <router-link :to="`/inspecciones/${inspeccion.id}`" class="p-2 text-slate-500 hover:text-blue-600" title="Ver/Editar Inspección"><EyeIcon class="h-5 w-5" /></router-link>
                <button v-if="inspeccion.estado !== 'en_progreso'" @click="reabrirInspeccion(inspeccion)" :disabled="isProcessing === inspeccion.id" class="p-2 text-slate-500 hover:text-orange-600 disabled:opacity-50" title="Reabrir Inspección para editar">
                    <ArrowUturnLeftIcon class="h-5 w-5" />
                </button>
                <button @click="handleDelete(inspeccion.id)" class="p-2 text-slate-500 hover:text-red-600" title="Borrar Inspección"><TrashIcon class="h-5 w-5" /></button>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
    <MarkAsSentModal :is-open="isSentModalOpen" :inspeccion-id="selectedInspeccion?.id" @close="isSentModalOpen = false" @save="handleMarkAsSent" />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroHistorialView.vue ---

--- INICIO DEL ARCHIVO: src/views/InspeccionDetailView.vue ---
<!-- src/views/InspeccionDetailView.vue -->
<script setup>
import { ref, onMounted, computed, inject } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import ChecklistModal from '../components/ChecklistModal.vue';
import PointList from '../components/PointList.vue';
import AddPointForm from '../components/AddPointForm.vue';
import { CheckCircleIcon, PlusIcon, XCircleIcon, InformationCircleIcon } from '@heroicons/vue/24/solid';
import { generateTextReport } from '../utils/pdf';

const showNotification = inject('showNotification');
const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const isFinalizing = ref(false);
const inspeccion = ref(null);
const centro = ref(null);
const version = ref(null);
const salas = ref([]);
const puntosMaestros = ref([]);
const puntosInspeccionados = ref([]);
const isModalOpen = ref(false);
const selectedPunto = ref(null);
const showAddPointForm = ref(false);
const isPlacementMode = ref(false);
const newPointSalaId = ref(null);

const canEditInspection = computed(() => {
  return inspeccion.value?.estado === 'en_progreso';
});

onMounted(async () => {
  loading.value = true;
  const { data: inspectionData, error: inspectionError } = await supabase.from('inspecciones').select('*, centros(*), versiones_plano(*)').eq('id', inspeccionId).single();
  if (inspectionError || !inspectionData || !inspectionData.versiones_plano) {
      showNotification('Error: No se pudo cargar la inspección.', 'error');
      loading.value = false; return;
  }
  inspeccion.value = inspectionData;
  centro.value = inspectionData.centros;
  version.value = inspectionData.versiones_plano;
  if (version.value) {
    const [salasRes, puntosMaestrosRes] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', version.value.id).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', version.value.id)
    ]);
    salas.value = salasRes.data || [];
    puntosMaestros.value = puntosMaestrosRes.data || [];
    await initializeInspectionPoints();
  }
  loading.value = false;
});

const initializeInspectionPoints = async () => {
  const { data: existingPoints } = await supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId);
  puntosInspeccionados.value = existingPoints || [];
  if (canEditInspection.value && puntosInspeccionados.value.length === 0 && puntosMaestros.value.length > 0) {
    const pointsToCreate = puntosMaestros.value.map(pm => ({
      inspeccion_id: inspeccionId, punto_maestro_id: pm.id, nomenclatura: pm.nomenclatura,
      coordenada_x: pm.coordenada_x, coordenada_y: pm.coordenada_y,
      estado: 'existente', tiene_placa_caracteristicas: true
    }));
    if (pointsToCreate.length > 0) {
      const { data: newPoints } = await supabase.from('puntos_inspeccionados').insert(pointsToCreate).select();
      if (newPoints) puntosInspeccionados.value = newPoints;
    }
  }
};

const getSalaColor = (salaId) => salas.value.find(s => s.id === salaId)?.color || '#9CA3AF';

const puntosParaMostrar = computed(() => {
  return puntosInspeccionados.value.map(pi => {
    const maestro = puntosMaestros.value.find(pm => pm.id === pi.punto_maestro_id);
    return { ...pi, sala_id: maestro?.sala_id, color: getSalaColor(maestro?.sala_id) };
  });
});

const puntosAgrupadosPorSala = computed(() => {
  return salas.value.map(sala => ({
    ...sala,
    puntos: puntosParaMostrar.value
      .filter(p => p.sala_id === sala.id)
      .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}))
  })).filter(g => g.puntos.length > 0);
});

const createNewPointAt = async (coords, salaId) => {
  const salaSeleccionada = salas.value.find(s => s.id === salaId);
  const puntosDeLaSala = puntosMaestros.value.filter(p => p.sala_id === salaId);
  const ultimoNumero = Math.max(0, ...puntosDeLaSala.map(p => parseInt(p.nomenclatura.split('-').pop() || 0)));
  const nuevaNomenclatura = `${salaSeleccionada.nombre}-${ultimoNumero + 1}`;
  
  const { data: nuevoPuntoMaestro, error: maestroError } = await supabase.from('puntos_maestros')
    .insert({ version_id: version.value.id, sala_id: salaId, nomenclatura: nuevaNomenclatura, coordenada_x: coords.x, coordenada_y: coords.y })
    .select().single();
  if (maestroError) {
    showNotification('Error al crear el punto maestro: ' + maestroError.message, 'error');
    return;
  }
  puntosMaestros.value.push(nuevoPuntoMaestro);

  const { data: nuevoPuntoIns, error: inspError } = await supabase.from('puntos_inspeccionados')
    .insert({
      inspeccion_id: inspeccionId, punto_maestro_id: nuevoPuntoMaestro.id,
      nomenclatura: nuevoPuntoMaestro.nomenclatura, coordenada_x: nuevoPuntoMaestro.coordenada_x,
      coordenada_y: nuevoPuntoMaestro.coordenada_y, estado: 'nuevo',
      tiene_placa_caracteristicas: true
    }).select().single();
  if (inspError) {
      showNotification('Error al crear el punto de inspección: ' + inspError.message, 'error');
      return;
  }
  if (nuevoPuntoIns) {
    puntosInspeccionados.value.push(nuevoPuntoIns);
    const { error: incidenciaError } = await supabase.from('incidencias').insert({
        inspeccion_id: inspeccionId, punto_inspeccionado_id: nuevoPuntoIns.id,
        item_checklist: 3, gravedad: 'ambar', observaciones: 'Alineación de nueva implantación.'
    });
    if (incidenciaError) {
        showNotification('El punto se creó, pero falló la creación de la incidencia automática.', 'error');
    } else {
        showNotification(`Punto ${nuevoPuntoIns.nomenclatura} añadido.`, 'success', 1500);
    }
  }
};

const updatePuntoEstado = async (punto, nuevoEstado) => {
    if (!canEditInspection.value) return;
    const { error } = await supabase.from('puntos_inspeccionados').update({ estado: nuevoEstado }).eq('id', punto.id);
    if (error) { showNotification('No se pudo actualizar el estado del punto.', 'error'); }
};

const startPlacementMode = (salaId) => {
  showAddPointForm.value = false;
  newPointSalaId.value = salaId;
  isPlacementMode.value = true;
};
const cancelPlacementMode = () => {
  isPlacementMode.value = false;
  newPointSalaId.value = null;
};
const handleDeleteNewPoint = async (punto) => {
    if (!canEditInspection.value) return;
    if (confirm(`¿Estás seguro de que quieres borrar permanentemente el punto "${punto.nomenclatura}"?`)) {
        const { error: inspError } = await supabase.from('puntos_inspeccionados').delete().eq('id', punto.id);
        if (inspError) { showNotification("Error al borrar el punto de la inspección: " + inspError.message, 'error'); return; }
        const { error: maestroError } = await supabase.from('puntos_maestros').delete().eq('id', punto.punto_maestro_id);
        if (maestroError) { showNotification("Advertencia: No se pudo borrar el punto del plano maestro.", 'error'); }
        puntosInspeccionados.value = puntosInspeccionados.value.filter(p => p.id !== punto.id);
        puntosMaestros.value = puntosMaestros.value.filter(p => p.id !== punto.punto_maestro_id);
        showNotification(`Punto ${punto.nomenclatura} borrado con éxito.`);
    }
};
const openChecklistFor = (punto) => {
  if (isPlacementMode.value) return;
  selectedPunto.value = puntosMaestros.value.find(pm => pm.id === punto.punto_maestro_id);
  isModalOpen.value = true;
};
const handleMapClick = (coords) => {
  if (isPlacementMode.value) { createNewPointAt(coords, newPointSalaId.value); }
};

// --- FUNCIÓN RESTAURADA: blobToBase64 ---
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      const dataUrl = reader.result;
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    reader.readAsDataURL(blob);
  });
}

// --- FUNCIÓN RESTAURADA: finalizarInspeccion ---
const finalizarInspeccion = async () => {
    if (!confirm('¿Estás seguro de que quieres finalizar esta inspección? Se generará y archivará el informe PDF, y la inspección quedará bloqueada.')) {
        return;
    }
    isFinalizing.value = true;
    try {
        const report = await generateTextReport(inspeccionId, 'initial', 'blob');
        if (!report || !report.blob) throw new Error("La generación del PDF falló.");

        const base64File = await blobToBase64(report.blob);
        
        const centroId = centro.value.id;
        const fileNameWithId = `${inspeccionId}-${report.fileName}`;
        const finalFileName = `centro_${centroId}/${fileNameWithId}`;

        const { data, error: invokeError } = await supabase.functions.invoke('upload-pdf-to-b2', {
          body: { file: base64File, fileName: finalFileName, contentType: 'application/pdf' }
        });
        
        if (invokeError) throw new Error(`Error al contactar con la función Edge: ${invokeError.message}.`);
        if (data.error) throw new Error(`Error en el servidor al subir el archivo: ${data.error}`);
        if (!data.publicUrl) throw new Error('La función Edge no devolvió una URL válida.');

        const publicUrl = data.publicUrl;
        
        const { error: updateError } = await supabase
            .from('inspecciones')
            .update({ estado: 'finalizada', url_pdf_informe_inicial: publicUrl })
            .eq('id', inspeccionId);
        if (updateError) throw updateError;
        
        showNotification('Inspección finalizada y archivada con éxito.');
        router.push(`/centros/${centro.value.id}/historial`);

    } catch (error) {
        console.error("Error completo al finalizar la inspección:", error);
        showNotification('Ocurrió un error al finalizar y archivar: ' + error.message, 'error');
    } finally {
        isFinalizing.value = false;
    }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex items-center justify-center text-slate-500">Cargando datos de la inspección...</div>
    
    <div v-else-if="inspeccion && centro && version" class="flex-1 flex flex-col min-h-0">
      
      <header class="flex-shrink-0 px-8 pt-8 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
          <div>
            <h1 class="text-3xl font-bold text-slate-800 mb-1">Inspección: {{ centro.nombre }}</h1>
            <p class="text-slate-500 text-sm">
              Técnico: <span class="font-medium">{{ inspeccion.tecnico_nombre }}</span> | 
              Fecha: <span class="font-medium">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</span> |
              Plano: <strong class="text-blue-600">{{ version.nombre }}</strong>
            </p>
            <div v-if="!canEditInspection" class="mt-2 flex items-center gap-2 text-sm font-semibold text-orange-700 bg-orange-100 border border-orange-200 rounded-md p-2">
                <InformationCircleIcon class="h-5 w-5" />
                <span>Esta inspección está bloqueada (modo solo lectura).</span>
            </div>
          </div>
          <button v-if="canEditInspection" @click="finalizarInspeccion" :disabled="isFinalizing" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 shadow-sm disabled:bg-slate-400">
            <CheckCircleIcon class="h-5 w-5" />
            {{ isFinalizing ? 'Finalizando...' : 'Finalizar Inspección' }}
          </button>
          <button v-else @click="router.push(`/centros/${centro.id}/historial`)" class="flex items-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
            Volver al Historial
          </button>
        </div>
      </header>
      
      <div class="flex-1 flex overflow-hidden">
        
        <aside class="w-80 lg:w-96 flex-shrink-0 bg-white border-r border-slate-200 flex flex-col">
          <div class="p-4 flex-shrink-0">
             <div v-if="canEditInspection">
                <AddPointForm 
                   v-if="showAddPointForm"
                   :salas="salas"
                   @save="startPlacementMode"
                   @cancel="showAddPointForm = false"
                />
                <button v-else-if="!isPlacementMode" @click="showAddPointForm = true" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-600 bg-slate-100 rounded-md hover:bg-slate-200">
                   <PlusIcon class="h-5 w-5" />
                   Agregar Punto Nuevo
                </button>
                <button v-if="isPlacementMode" @click="cancelPlacementMode" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
                   <XCircleIcon class="h-5 w-5" />
                   Cancelar Colocación
                </button>
             </div>
          </div>

          <div class="flex-1 overflow-y-auto px-4 pb-4">
            <PointList 
              :grouped-points="puntosAgrupadosPorSala"
              @select-point="openChecklistFor"
              @update-state="updatePuntoEstado"
              @delete-new-point="handleDeleteNewPoint"
              :class="{ 'pointer-events-none opacity-50': isPlacementMode }"
            />
          </div>
        </aside>
        
        <main class="flex-1 bg-slate-100 min-w-0">
          <InteractiveMap 
            :image-url="version.url_imagen_plano" 
            :points="puntosParaMostrar.filter(p => p.estado !== 'suprimido')"
            :salas="salas"
            :is-read-only="!canEditInspection || !isPlacementMode"
            :is-placement-mode="isPlacementMode"
            @point-click="openChecklistFor"
            @add-point="handleMapClick"
            @delete-point="handleDeleteNewPoint"
          />
        </main>
      </div>
    </div>
    
    <div v-else class="flex-1 flex items-center justify-center text-red-500">No se encontraron datos válidos para esta inspección.</div>

    <ChecklistModal 
      :is-open="isModalOpen" 
      :punto="selectedPunto"
      :inspeccion-id="inspeccionId" 
      @close="isModalOpen = false" 
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/InspeccionDetailView.vue ---

--- INICIO DEL ARCHIVO: src/views/DashboardView.vue ---
<!-- src/views/DashboardView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
import { 
  BuildingStorefrontIcon, 
  ExclamationTriangleIcon, 
  ClockIcon,
  PaperAirplaneIcon,
  CheckBadgeIcon
} from '@heroicons/vue/24/outline';
import { Line, Bar } from 'vue-chartjs';
import { Chart as ChartJS, Title, Tooltip, Legend, LineElement, BarElement, PointElement, CategoryScale, LinearScale } from 'chart.js';

ChartJS.register(Title, Tooltip, Legend, LineElement, BarElement, PointElement, CategoryScale, LinearScale);

const loading = ref(true);
const centros = ref([]);
const resumenInspecciones = ref([]);
const router = useRouter();

onMounted(async () => {
  loading.value = true;
  const [centrosRes, resumenRes] = await Promise.all([
    supabase.from('centros').select('id', { count: 'exact' }),
    supabase.from('vista_resumen_inspecciones').select('*')
  ]);
  
  centros.value = centrosRes.data || [];
  resumenInspecciones.value = resumenRes.data || [];
  loading.value = false;
});

// === DATOS PARA LAS TARJETAS DE RESUMEN ===
const totalCentros = computed(() => centros.value.length);
const inspeccionesEnProgreso = computed(() => resumenInspecciones.value.filter(i => i.estado === 'en_progreso').length);
const inspeccionesPendientesEnvio = computed(() => resumenInspecciones.value.filter(i => i.estado === 'finalizada').length);
const inspeccionesPendientesSubsanacion = computed(() => resumenInspecciones.value.filter(i => i.estado === 'pendiente_subsanacion').length);
const inspeccionesCerradas = computed(() => resumenInspecciones.value.filter(i => i.estado === 'cerrada').length);

// === DATOS GRÁFICO 1: ACTIVIDAD MENSUAL ===
const actividadMensual = computed(() => {
    const meses = {};
    const hoy = new Date();
    for (let i = 11; i >= 0; i--) {
        const d = new Date(hoy.getFullYear(), hoy.getMonth() - i, 1);
        const clave = d.toISOString().slice(0, 7);
        const etiqueta = d.toLocaleString('es-ES', { month: 'short', year: '2-digit' });
        meses[clave] = { etiqueta, realizadas: 0, cerradas: 0 };
    }
    resumenInspecciones.value.forEach(inspeccion => {
        const claveMes = inspeccion.fecha_inspeccion.slice(0, 7);
        if (meses[claveMes]) {
            meses[claveMes].realizadas++;
            if (inspeccion.estado === 'cerrada') meses[claveMes].cerradas++;
        }
    });
    return Object.values(meses);
});

const monthlyChartData = computed(() => ({
  labels: actividadMensual.value.map(m => m.etiqueta),
  datasets: [
    { label: 'Inspecciones Realizadas', backgroundColor: '#3B82F6', borderColor: '#3B82F6', data: actividadMensual.value.map(m => m.realizadas), tension: 0.2 },
    { label: 'Inspecciones Cerradas', backgroundColor: '#22C55E', borderColor: '#22C55E', data: actividadMensual.value.map(m => m.cerradas), tension: 0.2 }
  ]
}));

const monthlyChartOptions = {
  responsive: true, maintainAspectRatio: false,
  plugins: { legend: { position: 'top' }, title: { display: true, text: 'Actividad Mensual (Últimos 12 Meses)' } },
  scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
};

// === DATOS GRÁFICO 2: PRODUCTIVIDAD POR TÉCNICO ===
const informesPorTecnico = computed(() => {
  const conteo = {};
  resumenInspecciones.value.forEach(inspeccion => {
    const tecnico = inspeccion.tecnico_nombre || 'Desconocido';
    if (!conteo[tecnico]) conteo[tecnico] = 0;
    conteo[tecnico]++;
  });
  return Object.entries(conteo).sort(([, a], [, b]) => b - a);
});

const technicianChartData = computed(() => ({
  labels: informesPorTecnico.value.map(([tecnico]) => tecnico),
  datasets: [{ label: 'Informes Realizados', backgroundColor: '#6366F1', borderColor: '#4F46E5', borderWidth: 1, borderRadius: 4, data: informesPorTecnico.value.map(([, count]) => count) }]
}));

const technicianChartOptions = {
  responsive: true, maintainAspectRatio: false,
  plugins: { legend: { display: false } },
  scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
};

// === DATOS LISTA: PUNTOS CRÍTICOS ===
const centrosConMasRojas = computed(() => {
  const centrosConteo = {};
  resumenInspecciones.value.filter(i => i.incidencias_rojas > 0 && i.estado !== 'cerrada').forEach(i => {
    if (!centrosConteo[i.centro_id]) centrosConteo[i.centro_id] = { id: i.centro_id, nombre: i.centro_nombre, rojas: 0 };
    centrosConteo[i.centro_id].rojas += i.incidencias_rojas;
  });
  return Object.values(centrosConteo).sort((a, b) => b.rojas - a.rojas).slice(0, 5);
});

// === DATOS TABLA: ACCIONES PENDIENTES ===
const accionesPendientes = computed(() => {
    return resumenInspecciones.value
        .filter(i => i.estado === 'finalizada')
        .sort((a, b) => new Date(a.fecha_inspeccion) - new Date(b.fecha_inspeccion));
});
</script>

<template>
  <div class="h-full overflow-y-auto p-4 sm:p-8 bg-slate-50">
    <h1 class="text-3xl md:text-4xl font-bold text-slate-800 mb-8">Cuadro de Mando</h1>
    
    <div v-if="loading" class="text-center text-slate-500 py-16">Cargando datos del dashboard...</div>
    
    <div v-else class="space-y-8">
      <!-- 1. Tarjetas de Resumen Global -->
      <section>
        <div class="grid grid-cols-2 lg:grid-cols-5 gap-6">
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-blue-100 p-4 rounded-xl"><BuildingStorefrontIcon class="h-8 w-8 text-blue-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ totalCentros }}</p><p class="text-slate-500 font-semibold">Centros</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-yellow-100 p-4 rounded-xl"><ClockIcon class="h-8 w-8 text-yellow-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesEnProgreso }}</p><p class="text-slate-500 font-semibold">En Progreso</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-purple-100 p-4 rounded-xl"><PaperAirplaneIcon class="h-8 w-8 text-purple-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesPendientesEnvio }}</p><p class="text-slate-500 font-semibold">Pendiente Envío</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-orange-100 p-4 rounded-xl"><ExclamationTriangleIcon class="h-8 w-8 text-orange-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesPendientesSubsanacion }}</p><p class="text-slate-500 font-semibold">Pendiente Subsanación</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-green-100 p-4 rounded-xl"><CheckBadgeIcon class="h-8 w-8 text-green-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesCerradas }}</p><p class="text-slate-500 font-semibold">Cerradas</p></div>
          </div>
        </div>
      </section>

      <!-- 2. NUEVO LAYOUT DE 2 COLUMNAS -->
      <section class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Columna Izquierda: Actividad Mensual -->
        <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
           <div class="h-80">
              <Line :data="monthlyChartData" :options="monthlyChartOptions" />
           </div>
        </div>

        <!-- Columna Derecha: Widgets apilados -->
        <div class="lg:col-span-1 space-y-8">
          <!-- Widget: Productividad por Técnico -->
          <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <h2 class="text-xl font-bold text-slate-800 mb-4">Productividad por Técnico</h2>
            <div class="h-40">
              <Bar :data="technicianChartData" :options="technicianChartOptions" />
            </div>
          </div>

          <!-- Widget: Puntos Críticos -->
          <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            <h2 class="text-xl font-bold text-slate-800 mb-4 flex-shrink-0">Puntos Críticos Activos</h2>
            <ul v-if="centrosConMasRojas.length > 0" class="divide-y divide-slate-100">
              <li v-for="centro in centrosConMasRojas" :key="centro.id" class="py-3 flex justify-between items-center group">
                <div>
                  <p class="font-semibold text-slate-800 group-hover:text-blue-600">{{ centro.nombre }}</p>
                  <p class="text-sm text-slate-500 flex items-center"><span class="h-2.5 w-2.5 rounded-full bg-red-500 mr-2"></span><span class="font-bold text-red-600">{{ centro.rojas }}</span>&nbsp;incidencias graves</p>
                </div>
                <router-link :to="`/centros/${centro.id}/historial`" class="opacity-0 group-hover:opacity-100 px-3 py-1 text-sm font-semibold text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 transition-opacity">Revisar</router-link>
              </li>
            </ul>
            <div v-else class="flex-1 flex flex-col items-center justify-center text-center text-slate-500 p-4">
              <span class="text-2xl mb-2">🎉</span><p class="font-semibold">¡Todo en orden!</p><p class="text-sm">No hay incidencias graves activas.</p>
            </div>
          </div>
        </div>
      </section>

      <!-- 3. Acciones Pendientes -->
       <section class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
        <h2 class="text-xl font-bold text-slate-800 mb-4">Acciones Pendientes (Enviar a Cliente)</h2>
         <div class="overflow-x-auto">
          <table class="min-w-full divide-y divide-slate-200">
             <thead class="bg-slate-50">
              <tr>
                <th class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Centro</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Fecha Finalización</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Técnico</th>
                <th class="relative px-6 py-3"><span class="sr-only">Acción</span></th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-slate-200">
              <tr v-if="accionesPendientes.length === 0">
                  <td colspan="4" class="px-6 py-8 text-center text-slate-500">No hay acciones pendientes. ¡Buen trabajo!</td>
              </tr>
              <tr v-for="inspeccion in accionesPendientes" :key="inspeccion.inspeccion_id" class="hover:bg-slate-50">
                <td class="px-6 py-4 whitespace-nowrap font-semibold text-slate-800">{{ inspeccion.centro_nombre }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-slate-600">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-slate-600">{{ inspeccion.tecnico_nombre }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                  <router-link :to="`/centros/${inspeccion.centro_id}/historial`" class="font-semibold text-purple-600 hover:text-purple-800">Gestionar Envío</router-link>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/DashboardView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroVersionsView.vue ---
<!-- src/views/CentroVersionsView.vue -->
<script setup>
import { ref, onMounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { PlusIcon, PencilIcon, CheckCircleIcon, ArchiveBoxIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const loading = ref(true);
const centro = ref(null);
const versiones = ref([]);
const newVersionName = ref('');

const fetchVersions = async () => {
  loading.value = true;
  const { data: centroData } = await supabase.from('centros').select('nombre').eq('id', centroId).single();
  centro.value = centroData;

  const { data: versionsData } = await supabase
    .from('versiones_plano')
    .select('*')
    .eq('centro_id', centroId)
    .order('fecha_creacion', { ascending: false });
  versiones.value = versionsData || [];
  loading.value = false;
};

const createNewVersion = async () => {
    if (!newVersionName.value.trim()) {
        alert('Por favor, introduce un nombre para la nueva versión.');
        return;
    }

    // Llamamos a una función RPC de Supabase que se encarga de la lógica de duplicación
    // Esta función debería:
    // 1. Poner a `false` la `es_activa` de la versión activa actual.
    // 2. Crear la nueva versión con `es_activa = true`.
    // 3. Duplicar las salas y puntos de la versión anterior a la nueva.
    // 4. Devolver el ID de la nueva versión.
    const { data, error } = await supabase.rpc('crear_nueva_version_plano', {
        centro_id_param: centroId,
        nuevo_nombre_param: newVersionName.value.trim()
    });

    if (error) {
        alert('Error al crear la nueva versión: ' + error.message);
        console.error(error);
    } else {
        alert('Nueva versión creada con éxito.');
        newVersionName.value = '';
        await fetchVersions();
        // Opcionalmente, redirigir directamente a la configuración de la nueva versión
        if (data) {
           router.push(`/versiones/${data}/configurar`);
        }
    }
};

onMounted(fetchVersions);
</script>

<template>
  <div class="p-8">
    <div v-if="loading">Cargando versiones...</div>
    <div v-else-if="centro">
      <div class="flex justify-between items-center mb-8">
        <div>
          <h1 class="text-4xl font-bold text-slate-800">Versiones del Plano</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <router-link to="/centros" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">
          Volver a Centros
        </router-link>
      </div>

      <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 mb-8 max-w-3xl mx-auto">
        <h2 class="text-2xl font-bold text-slate-800 mb-4">Crear Nueva Versión</h2>
        <p class="text-slate-500 mb-4">
          Crea una nueva versión para modificar el plano, añadir o quitar salas y puntos. Se copiará la configuración de la última versión activa.
        </p>
        <form @submit.prevent="createNewVersion" class="flex flex-col sm:flex-row gap-4">
          <input 
            v-model="newVersionName" 
            type="text" 
            placeholder="Ej: Reforma Almacén 2026" 
            required
            class="flex-1 block w-full rounded-md border-slate-300 shadow-sm"
          >
          <button 
            type="submit"
            class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm"
          >
            <PlusIcon class="h-5 w-5" />
            Crear Versión
          </button>
        </form>
      </div>

      <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
        <ul class="divide-y divide-slate-200">
          <li v-if="versiones.length === 0" class="p-8 text-center text-slate-500">
            No se han encontrado versiones para este centro. Crea la primera.
          </li>
          <li v-for="version in versiones" :key="version.id" class="p-4 grid grid-cols-1 md:grid-cols-4 gap-4 items-center">
            <div class="md:col-span-1">
              <p class="font-semibold text-slate-800 text-lg">{{ version.nombre }}</p>
              <p class="text-sm text-slate-500">Creada: {{ new Date(version.fecha_creacion).toLocaleDateString() }}</p>
            </div>
            <div class="md:col-span-1">
              <span v-if="version.es_activa" class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <CheckCircleIcon class="h-4 w-4" />
                Versión Activa
              </span>
              <span v-else class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-600">
                <ArchiveBoxIcon class="h-4 w-4" />
                Archivada
              </span>
            </div>
            <div class="md:col-span-2 flex justify-end items-center gap-2">
              <router-link :to="`/versiones/${version.id}/configurar`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
                <PencilIcon class="h-4 w-4" />
                Configurar Plano
              </router-link>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroVersionsView.vue ---

--- INICIO DEL ARCHIVO: src/views/PlanoPreviewView.vue ---
<!-- src/views/PlanoPreviewView.vue -->
<script setup>
import { ref, onMounted, nextTick } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { fetchReportData } from '../utils/pdf/pdf-data';
import { calculatePlanoLayout } from '../utils/plano-layout';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import PlanoBadge from '../components/PlanoBadge.vue';
import { ArrowDownTrayIcon, ArrowUturnLeftIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const layoutReady = ref(false);
const errorState = ref(null);
const reportData = ref(null);
const labels = ref([]);
const planoContainer = ref(null);
const mapDimensions = ref({ x: 0, y: 0, width: 1, height: 1 });
const isGenerating = ref(false);

const draggedLabel = ref(null);
const dragOffset = ref({ x: 0, y: 0 });

const BADGE_WIDTH_PX = 60; 

onMounted(async () => {
  // --- INICIO DE LA CORRECCIÓN: Solicitamos la imagen del plano SIN optimizar ---
  reportData.value = await fetchReportData(inspeccionId, { optimizePlan: false });
  // --- FIN DE LA CORRECCIÓN ---

  if (!reportData.value) {
    errorState.value = "No se pudieron cargar los datos de la inspección.";
    loading.value = false;
    return;
  }
  loading.value = false;
  await nextTick();
  prepareLayout();
});

const prepareLayout = () => {
  const containerEl = planoContainer.value;
  if (!containerEl) {
    errorState.value = "Error: El contenedor del plano no se encontró en el DOM.";
    return;
  }
  
  const img = new Image();
  img.onload = async () => {
    const containerRatio = containerEl.clientWidth / containerEl.clientHeight;
    const imageRatio = img.width / img.height;
    let imgW, imgH, imgX, imgY;
    if (imageRatio > containerRatio) {
      imgW = containerEl.clientWidth;
      imgH = imgW / imageRatio;
      imgX = 0;
      imgY = (containerEl.clientHeight - imgH) / 2;
    } else {
      imgH = containerEl.clientHeight;
      imgW = imgH * imageRatio;
      imgY = 0;
      imgX = (containerEl.clientWidth - imgW) / 2;
    }
    mapDimensions.value = { x: imgX, y: imgY, width: imgW, height: imgH };

    const allPoints = reportData.value.puntosInspeccionadosData.map(punto => {
      const maestro = reportData.value.puntosMaestrosData.find(pm => pm.id === punto.punto_maestro_id);
      if (!maestro) return null;
      return {
        ...punto,
        nomenclatura: maestro.nomenclatura,
        absX: mapDimensions.value.x + (punto.coordenada_x * mapDimensions.value.width),
        absY: mapDimensions.value.y + (punto.coordenada_y * mapDimensions.value.height),
        counts: reportData.value.incidenceCounts.get(punto.id) || { verde: 0, ambar: 0, rojo: 0 }
      };
    }).filter(Boolean);
    
    const calculatedLabels = calculatePlanoLayout(allPoints, mapDimensions.value, BADGE_WIDTH_PX);
    
    const showLabelsIncrementally = (index = 0) => {
      if (index < calculatedLabels.length) {
        labels.value.push(calculatedLabels[index]);
        requestAnimationFrame(() => showLabelsIncrementally(index + 1));
      } else {
        layoutReady.value = true;
      }
    };
    showLabelsIncrementally();
  };
  
  img.onerror = () => { errorState.value = "No se pudo cargar la imagen del plano."; }
  img.src = reportData.value.planoBase64;
};

const generatePdf = async () => {
    isGenerating.value = true;
    await nextTick();
    const elementToCapture = planoContainer.value;
    
    const canvas = await html2canvas(elementToCapture, { 
        scale: 3,
        useCORS: true,
        logging: false,
        backgroundColor: '#ffffff'
    });

    const imgData = canvas.toDataURL('image/jpeg', 0.95);
    const pdf = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();
    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight, undefined, 'FAST');
    const { inspectionData } = reportData.value;
    const fileName = `Plano_Incidencias_${inspectionData.centros.nombre.replace(/ /g, '_')}_${inspectionData.fecha_inspeccion}.pdf`;
    pdf.save(fileName);
    isGenerating.value = false;
};

const onMouseDown = (label, event) => {
  draggedLabel.value = label;
  const containerRect = planoContainer.value.getBoundingClientRect();
  dragOffset.value = {
    x: event.clientX - containerRect.left - label.position.x,
    y: event.clientY - containerRect.top - label.position.y
  };
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
};

const onMouseMove = (event) => {
  if (!draggedLabel.value) return;
  const containerRect = planoContainer.value.getBoundingClientRect();
  const newX = event.clientX - containerRect.left - dragOffset.value.x;
  const newY = event.clientY - containerRect.top - dragOffset.value.y;
  draggedLabel.value.position.x = newX;
  draggedLabel.value.position.y = newY;
};

const onMouseUp = () => {
  draggedLabel.value = null;
  window.removeEventListener('mousemove', onMouseMove);
  window.removeEventListener('mouseup', onMouseUp);
};
</script>

<template>
  <div class="h-screen w-screen bg-slate-800 flex flex-col">
    <header class="w-full bg-white shadow-md p-3 flex justify-between items-center z-20 flex-shrink-0">
      <div class="text-slate-700">
        <h1 class="font-bold">Editor de Plano</h1>
        <p v-if="reportData" class="text-sm text-slate-500">{{ reportData.inspectionData.centros.nombre }}</p>
      </div>
      <div class="flex items-center gap-4">
        <button @click="$router.go(-1)" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <ArrowUturnLeftIcon class="h-4 w-4" /> Volver
        </button>
        <button @click="generatePdf" :disabled="isGenerating || !layoutReady" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-slate-400">
          <ArrowDownTrayIcon class="h-4 w-4" />
          {{ isGenerating ? 'Generando...' : 'Generar PDF' }}
        </button>
      </div>
    </header>

    <main class="flex-1 p-4 overflow-hidden">
      <div v-if="loading" class="h-full w-full flex items-center justify-center text-white">Cargando previsualización...</div>
      <div v-else-if="errorState" class="h-full w-full flex items-center justify-center text-red-300 bg-red-900/50 p-4 text-center rounded-md">{{ errorState }}</div>
      
      <div v-else ref="planoContainer" class="relative h-full w-full bg-white select-none">
        
        <img
          :src="reportData.planoBase64"
          class="absolute pointer-events-none"
          :style="{ 
            left: `${mapDimensions.x}px`, top: `${mapDimensions.y}px`,
            width: `${mapDimensions.width}px`, height: `${mapDimensions.height}px`
          }"
        >
        
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
          <g v-for="label in labels" :key="'line-' + label.pointData.id">
            <line
              :x1="label.pointData.absX"
              :y1="label.pointData.absY"
              :x2="label.position.x"
              :y2="label.position.y"
              stroke="#94a3b8"
              stroke-width="1"
            />
          </g>
        </svg>
        
        <div 
          v-for="label in labels" 
          :key="'badge-' + label.pointData.id"
          @mousedown.prevent="onMouseDown(label, $event)"
          class="z-20 absolute"
          :style="{ 
            left: `${label.position.x - (label.size.width / 2)}px`,
            top: `${label.position.y - (label.size.height / 2)}px`,
            width: `${label.size.width}px`,
            height: `${label.size.height}px`,
          }"
        >
           <PlanoBadge :pointData="label.pointData" />
        </div>
      </div>
    </main>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/PlanoPreviewView.vue ---

--- INICIO DEL ARCHIVO: src/views/InspeccionesListView.vue ---
<!-- src/views/InspeccionesListView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { supabase } from '../supabase';

const router = useRouter();
const centros = ref([]);
const loading = ref(true);
const isStarting = ref(false);
const searchTerm = ref('');
const tecnicoNombre = ref('');

const filteredCentros = computed(() => {
  if (!searchTerm.value) return centros.value;
  return centros.value.filter(centro =>
    centro.nombre.toLowerCase().includes(searchTerm.value.toLowerCase())
  );
});

// === INICIO DE LA LÓGICA CORREGIDA ===
const startInspection = async (centroId) => {
  if (!tecnicoNombre.value.trim()) {
    alert('Por favor, introduce el nombre del técnico para continuar.');
    return;
  }
  isStarting.value = true;

  // 1. Buscar la VERSIÓN ACTIVA para el centro seleccionado.
  const { data: activeVersion, error: versionError } = await supabase
    .from('versiones_plano')
    .select('id')
    .eq('centro_id', centroId)
    .eq('es_activa', true)
    .single();

  if (versionError || !activeVersion) {
    alert('Error: Este centro no tiene una versión de plano activa. Por favor, configúralo en el Maestro de Centros.');
    console.error("Error buscando versión activa:", versionError);
    isStarting.value = false;
    return;
  }
  const versionId = activeVersion.id;

  // 2. Buscar si ya existe una inspección en progreso para este centro
  let { data: inspection, error: findError } = await supabase
    .from('inspecciones')
    .select('id')
    .eq('centro_id', centroId)
    .eq('estado', 'en_progreso')
    .maybeSingle();
  
  if (findError) {
    alert('Error buscando inspección existente: ' + findError.message);
    isStarting.value = false;
    return;
  }

  // 3. Si no existe, crear una nueva asociándola a la versión activa
  if (!inspection) {
    const { data: newInspection, error: createError } = await supabase
      .from('inspecciones')
      .insert({ 
        centro_id: centroId, 
        version_id: versionId, // <-- Guardamos la versión correcta
        estado: 'en_progreso',
        tecnico_nombre: tecnicoNombre.value.trim(),
        fecha_inspeccion: new Date().toISOString().slice(0, 10)
      })
      .select('id')
      .single();
    
    if (createError) {
      alert('Error creando inspección: ' + createError.message);
      isStarting.value = false;
      return;
    }
    inspection = newInspection;
  } else {
    // Si ya existía, la actualizamos para asegurarnos de que usa la última versión activa
     await supabase.from('inspecciones').update({ 
      tecnico_nombre: tecnicoNombre.value.trim(),
      fecha_inspeccion: new Date().toISOString().slice(0, 10),
      version_id: versionId // <-- Actualizamos también la versión
    }).eq('id', inspection.id);
  }

  // 4. Navegar a la página de detalle
  router.push(`/inspecciones/${inspection.id}`);
};
// === FIN DE LA LÓGICA CORREGIDA ===

onMounted(async () => {
  loading.value = true;
  const { data } = await supabase.from('centros').select('id, nombre').order('nombre');
  if (data) centros.value = data;
  loading.value = false;
});
</script>

<template>
  <div class="p-8">
    <h1 class="text-4xl font-bold text-slate-800 mb-8">Iniciar Inspección</h1>
    <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 max-w-3xl mx-auto">
      
      <div class="mb-6">
        <label for="tecnico" class="block text-sm font-medium text-slate-700 mb-1">Nombre del Técnico</label>
        <input 
          v-model="tecnicoNombre" 
          id="tecnico" 
          type="text" 
          placeholder="Escribe tu nombre..." 
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>

      <div>
        <label for="search" class="block text-sm font-medium text-slate-700 mb-1">Buscar y Seleccionar Centro</label>
        <input 
          v-model="searchTerm" 
          id="search" 
          type="search" 
          placeholder="Escribe para buscar un centro..." 
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>
      
      <div class="mt-4 max-h-60 overflow-y-auto border rounded-md">
        <div v-if="loading" class="p-4 text-center text-slate-500">Cargando centros...</div>
        <ul v-else-if="filteredCentros.length > 0">
          <li v-for="centro in filteredCentros" :key="centro.id" class="border-b last:border-b-0">
            <button 
              @click="startInspection(centro.id)" 
              :disabled="isStarting"
              class="w-full text-left p-4 hover:bg-blue-50 transition-colors disabled:bg-slate-100 disabled:cursor-wait"
            >
              {{ centro.nombre }}
            </button>
          </li>
        </ul>
        <div v-else class="p-4 text-center text-slate-500">No se encontraron centros.</div>
      </div>

    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/InspeccionesListView.vue ---

--- INICIO DEL ARCHIVO: src/views/CentroConfigView.vue ---
<!-- src/views/CentroConfigView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import { ArrowPathIcon, ArrowUpTrayIcon, PlusIcon, TrashIcon, MapIcon, XCircleIcon, PencilIcon, CheckCircleIcon, InformationCircleIcon, BackspaceIcon } from '@heroicons/vue/24/solid';
import NomenclatureModal from '../components/NomenclatureModal.vue';

const route = useRoute();
const router = useRouter();
const versionId = route.params.id;

const loading = ref(true);
const version = ref(null);
const centro = ref(null);
const puntos = ref([]);
const salas = ref([]);
const activeSalaId = ref(null);
const newSalaName = ref('');
const fileInput = ref(null);

const isDrawingMode = ref(false);
const isPointEditingMode = ref(false);
const activeSala = computed(() => salas.value.find(s => s.id === activeSalaId.value));

// --- Lógica para el nuevo modal de nomenclatura ---
const isNomenclatureModalOpen = ref(false);
const newPointCoords = ref(null);

const existingNumbersInActiveSala = computed(() => {
    if (!activeSalaId.value) return [];
    return puntos.value
        .filter(p => p.sala_id === activeSalaId.value)
        .map(p => {
            const match = p.nomenclatura.match(/-(\d+)$/);
            return match ? parseInt(match[1], 10) : 0;
        });
});

const suggestedNextNumber = computed(() => {
    if (existingNumbersInActiveSala.value.length === 0) return 1;
    const sortedNumbers = [...existingNumbersInActiveSala.value].sort((a, b) => a - b);
    for (let i = 0; i < sortedNumbers.length; i++) {
        if (sortedNumbers[i] !== i + 1) {
            return i + 1; // Encontramos un hueco
        }
    }
    return sortedNumbers.length + 1; // No hay huecos, usamos el siguiente
});
// --- Fin de la lógica del modal ---

const instructionText = computed(() => {
    if (isDrawingMode.value) {
        const salaName = activeSala.value?.nombre || 'la sala';
        return `Definiendo área para "${salaName}": Haz clic para añadir puntos. Haz clic en el primer punto para cerrar la forma.`;
    }
    if (isPointEditingMode.value) {
        const salaName = activeSala.value?.nombre || 'NINGUNA';
        return `Modo Edición de Puntos: Haz clic en el plano para añadir puntos en la sala "${salaName.toUpperCase()}".`;
    }
    return null;
});

onMounted(async () => {
  loading.value = true;
  const { data: versionData } = await supabase.from('versiones_plano').select('*, centros(*)').eq('id', versionId).single();
  if (!versionData) {
    alert("Error: No se pudo cargar la versión del plano o no existe.");
    loading.value = false; return;
  }
  version.value = versionData;
  centro.value = versionData.centros;
  const [salasRes, puntosRes] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', versionId).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', versionId)
  ]);
  salas.value = salasRes.data || [];
  puntos.value = puntosRes.data || [];
  if (salas.value.length > 0 && !activeSalaId.value) {
      activeSalaId.value = salas.value[0].id;
  }
  loading.value = false;
});

const togglePointEditingMode = () => {
    if (!isPointEditingMode.value && !activeSalaId.value) {
        alert('Por favor, selecciona primero una sala para empezar a editar sus puntos.');
        return;
    }
    isPointEditingMode.value = !isPointEditingMode.value;
    isDrawingMode.value = false;
};

const cancelAllModes = () => {
    isDrawingMode.value = false;
    isPointEditingMode.value = false;
};

const onFileSelected = (event) => {
    const file = event.target.files[0];
    if (file) handleFileUpload(file);
};
const handleFileUpload = async (file) => {
    // Lógica sin cambios
};

const enterDrawingMode = () => {
  if (!activeSalaId.value) { alert("Selecciona una sala para poder definir su área."); return; }
  isDrawingMode.value = true;
  isPointEditingMode.value = false;
};

const handleAreaDrawn = async (points) => {
  // Lógica sin cambios
};

const clearArea = async () => {
    // Lógica sin cambios
};

// --- Nueva función para abrir el modal ---
const handleMapClick = (coords) => {
  if (isPointEditingMode.value) {
    newPointCoords.value = coords;
    isNomenclatureModalOpen.value = true;
  }
};

// --- La antigua 'handleNewPoint' ahora es 'handleSaveNomenclature' ---
const handleSaveNomenclature = async (pointNumber) => {
  isNomenclatureModalOpen.value = false;
  const coords = newPointCoords.value;
  if (!coords || !activeSalaId.value) return;

  const sala = salas.value.find(s => s.id === activeSalaId.value);
  const newNomenclature = `${sala.nombre}-${pointNumber}`;

  const { data, error } = await supabase.from('puntos_maestros').insert({ 
    version_id: versionId, 
    sala_id: activeSalaId.value, 
    nomenclatura: newNomenclature, 
    coordenada_x: coords.x, 
    coordenada_y: coords.y
  }).select().single();
  
  if (data) {
    puntos.value.push(data);
  } else if (error) {
    alert(error.message);
  }
  newPointCoords.value = null;
};

const handleDeletePoint = async (point) => {
    if (confirm(`¿Estás seguro de que quieres borrar el punto "${point.nomenclatura}" de este plano?`)) {
        const { error } = await supabase.from('puntos_maestros').delete().eq('id', point.id);
        if (error) {
            alert('Error al borrar el punto: ' + error.message);
        } else {
            puntos.value = puntos.value.filter(p => p.id !== point.id);
        }
    }
};

const addSala = async () => {
  // Lógica sin cambios
};
const deleteSala = async (salaId) => {
  // Lógica sin cambios
};
const handleUpdatePosition = async (point) => {
  // Lógica sin cambios
};
const saveSalaColor = async (sala) => {
  // Lógica sin cambios
};
</script>

<template>
  <div class="p-4 sm:p-8 h-full flex flex-col">
    <input type="file" @change="onFileSelected" accept="image/*" class="hidden" ref="fileInput">
    <div v-if="loading" class="flex justify-center items-center h-full">Cargando...</div>
    <div v-else-if="centro && version" class="flex-1 flex flex-col">
      <div v-if="version.url_imagen_plano" class="flex-1 flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-start mb-6 gap-4">
          <div>
            <h1 class="text-3xl font-bold text-slate-800">Configurar: {{ centro.nombre }}</h1>
            <p class="text-slate-600 mt-2">
              Editando versión: <strong class="text-blue-600">{{ version.nombre }}</strong> 
              <span v-if="version.es_activa" class="ml-2 text-xs font-bold text-green-700 bg-green-100 px-2 py-0.5 rounded-full">ACTIVA</span>
              <span v-else class="ml-2 text-xs font-bold text-slate-700 bg-slate-100 px-2 py-0.5 rounded-full">ARCHIVADA</span>
            </p>
          </div>
          <div class="flex gap-2 flex-shrink-0">
             <button @click="fileInput.click()" class="flex items-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <ArrowPathIcon class="h-5 w-5" /> Cambiar Plano
             </button>
             <button v-if="isDrawingMode || isPointEditingMode" @click="cancelAllModes" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
                <XCircleIcon class="h-5 w-5" /> Cancelar
             </button>
            <button @click="router.push(`/centros/${centro.id}/versiones`)" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">Volver a Versiones</button>
          </div>
        </div>
        
        <div class="flex-grow grid grid-cols-1 lg:grid-cols-4 gap-8">
          <div class="lg:col-span-1 lg:sticky lg:top-8 self-start bg-white rounded-xl shadow-sm border border-slate-200 p-4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-slate-800">Salas</h2>
                <button 
                    @click="togglePointEditingMode" 
                    :disabled="salas.length === 0"
                    :class="[
                        'flex items-center gap-1.5 px-2.5 py-1 text-xs font-semibold text-white rounded-md transition-colors',
                        'disabled:bg-slate-400 disabled:cursor-not-allowed',
                        isPointEditingMode ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'
                    ]">
                    <component :is="isPointEditingMode ? CheckCircleIcon : PencilIcon" class="h-4 w-4" />
                    {{ isPointEditingMode ? 'Finalizar Edición' : 'Gestionar Puntos' }}
                </button>
            </div>
            <ul class="space-y-2">
              <li v-for="sala in salas" :key="sala.id">
                <div @click="activeSalaId = sala.id" :class="['w-full p-3 rounded-lg transition-colors flex justify-between items-center group cursor-pointer', activeSalaId === sala.id ? 'bg-blue-100 ring-2 ring-blue-300' : 'hover:bg-slate-100']">
                  <div class="flex items-center gap-3">
                    <input type="color" v-model="sala.color" @input="saveSalaColor(sala)" class="w-6 h-6 p-0 border-none rounded-md cursor-pointer flex-shrink-0">
                    <span class="font-semibold" :class="{'text-blue-800': activeSalaId === sala.id}">{{ sala.nombre }}</span>
                  </div>
                </div>
                <div v-if="activeSalaId === sala.id" class="pl-10 pt-1 pb-2 flex items-center space-x-4">
                    <button @click="enterDrawingMode" :disabled="isPointEditingMode" class="flex items-center gap-1.5 text-xs text-blue-600 hover:text-blue-800 disabled:text-slate-400 disabled:cursor-not-allowed">
                       <MapIcon class="h-4 w-4" /> <span>Definir Área</span>
                    </button>
                    <button v-if="sala.area_puntos" @click="clearArea" :disabled="isPointEditingMode" class="flex items-center gap-1.5 text-xs text-red-600 hover:text-red-800 disabled:text-slate-400 disabled:cursor-not-allowed">
                       <XCircleIcon class="h-4 w-4" /> <span>Limpiar</span>
                    </button>
                    <button @click="deleteSala(sala.id)" :disabled="isPointEditingMode" class="flex items-center gap-1.5 text-xs text-slate-500 hover:text-red-600 disabled:text-slate-400 disabled:cursor-not-allowed">
                       <TrashIcon class="h-4 w-4" /> <span>Borrar</span>
                    </button>
                 </div>
              </li>
            </ul>
            <form @submit.prevent="addSala" class="mt-4 flex-shrink-0 flex gap-2">
              <input v-model="newSalaName" type="text" placeholder="Nueva sala..." class="flex-1 block w-full rounded-md border-slate-300 shadow-sm text-sm">
              <button type="submit" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                <PlusIcon class="h-5 w-5" />
              </button>
            </form>
          </div>
          
          <div class="lg:col-span-3 relative">
            <div v-if="instructionText" class="sticky top-4 left-1/2 -translate-x-1/2 max-w-[90%] bg-blue-600 text-white text-sm font-semibold py-2 px-4 rounded-lg shadow-lg z-20 pointer-events-none flex items-center gap-2">
              <InformationCircleIcon class="h-5 w-5 flex-shrink-0" />
              <span>{{ instructionText }}</span>
            </div>
            <InteractiveMap 
              :image-url="version.url_imagen_plano" 
              :points="puntos" 
              :salas="salas"
              :is-read-only="!isPointEditingMode"
              :is-placement-mode="isPointEditingMode"
              :is-area-drawing-mode="isDrawingMode"
              @add-point="handleMapClick"
              @delete-point="handleDeletePoint" 
              @update-point-position="handleUpdatePosition"
              @area-drawn="handleAreaDrawn"
              @drawing-cancelled="cancelAllModes"
            />
          </div>
        </div>
      </div>
      
      <div v-else class="flex-1 flex flex-col items-center justify-center">
         <div class="max-w-3xl mx-auto text-center">
          <h1 class="text-3xl font-bold text-slate-800">Se necesita un plano para esta versión</h1>
          <p class="text-slate-600 mt-4 text-lg">La versión <strong class="text-blue-600">{{ version.nombre }}</strong> no tiene un plano asignado.</p>
        </div>
        <div class="mt-8 max-w-lg w-full mx-auto bg-white p-8 rounded-lg shadow-md border">
          <button @click="fileInput.click()" class="w-full ...">
            <ArrowUpTrayIcon class="h-10 w-10 text-slate-400" />
            <span class="text-slate-500 font-medium">Haz clic aquí para seleccionar un archivo</span>
          </button>
        </div>
        <div class="text-center mt-8">
          <button @click="router.push(`/centros/${centro.id}/versiones`)" class="font-semibold text-slate-600 hover:text-slate-800">Volver a Versiones</button>
        </div>
      </div>
    </div>

    <NomenclatureModal
      :is-open="isNomenclatureModalOpen"
      :sala-nombre="activeSala?.nombre"
      :suggested-number="suggestedNextNumber"
      :existing-numbers="existingNumbersInActiveSala"
      @close="isNomenclatureModalOpen = false"
      @save="handleSaveNomenclature"
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src/views/CentroConfigView.vue ---

--- INICIO DEL ARCHIVO: src/router/index.js ---
// src/router/index.js

import { createRouter, createWebHistory } from 'vue-router'
import { supabase } from '../supabase'

// Importación de Vistas y Componentes
import DashboardView from '../views/DashboardView.vue'
import Login from '../components/Login.vue'
import CentrosListView from '../views/CentrosListView.vue'
import CentroConfigView from '../views/CentroConfigView.vue'
import InspeccionesListView from '../views/InspeccionesListView.vue'
import InspeccionDetailView from '../views/InspeccionDetailView.vue'
import CentroHistorialView from '../views/CentroHistorialView.vue';
import CentroVersionsView from '../views/CentroVersionsView.vue';
import SubsanacionView from '../views/SubsanacionView.vue';

const routes = [
  { path: '/', name: 'Login', component: Login, meta: { layout: 'Blank' } },
  { path: '/dashboard', name: 'Dashboard', component: DashboardView, meta: { requiresAuth: true } },
  { path: '/centros', name: 'CentrosList', component: CentrosListView, meta: { requiresAuth: true } },
  { path: '/centros/:id/versiones', name: 'CentroVersions', component: CentroVersionsView, meta: { requiresAuth: true } },
  { path: '/versiones/:id/configurar', name: 'VersionConfig', component: CentroConfigView, meta: { requiresAuth: true } },
  { path: '/inspecciones', name: 'InspeccionesList', component: InspeccionesListView, meta: { requiresAuth: true } },
  { path: '/inspecciones/:id', name: 'InspeccionDetail', component: InspeccionDetailView, meta: { requiresAuth: true } },
  { path: '/centros/:id/historial', name: 'CentroHistorial', component: CentroHistorialView, meta: { requiresAuth: true } },
  {
    path: '/inspecciones/:id/plano-preview',
    name: 'PlanoPreview',
    component: () => import('../views/PlanoPreviewView.vue'),
    meta: { layout: 'Blank' }
  },
  {
    path: '/inspecciones/:id/subsanar',
    name: 'SubsanacionDetail',
    component: SubsanacionView,
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

router.beforeEach(async (to, from, next) => {
  // --- LOG DE DEBUG ---
  console.log(`[Router] Navegando de '${from.fullPath}' a '${to.fullPath}'`);
  
  const { data: { session } } = await supabase.auth.getSession()
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth)

  if (requiresAuth && !session) { next({ name: 'Login' }) } 
  else if (session && to.name === 'Login') { next({ name: 'Dashboard' }) }
  else { next() }
})

export default router
--- FIN DEL ARCHIVO: src/router/index.js ---

--- INICIO DEL ARCHIVO: src/layouts/BlankLayout.vue ---
<!-- src/layouts/BlankLayout.vue -->
<script setup>
import { onMounted } from 'vue';
// --- LOGS DE DEBUG ---
onMounted(() => console.log('[BlankLayout.vue] Componente montado en el DOM.'));
</script>

<template>
  <!-- 
    CORRECCIÓN: Se elimina el div contenedor. 
    <router-view> actuará como el elemento raíz de este layout,
    permitiendo que la página que renderiza controle su propio layout al 100%.
  -->
  <router-view />
</template>
--- FIN DEL ARCHIVO: src/layouts/BlankLayout.vue ---

--- INICIO DEL ARCHIVO: src/layouts/DefaultLayout.vue ---
<!-- src/layouts/DefaultLayout.vue -->
<script setup>
import { RouterLink, useRoute } from 'vue-router';
import { HomeIcon, ListBulletIcon, DocumentMagnifyingGlassIcon } from '@heroicons/vue/24/outline';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';

const route = useRoute();
const router = useRouter();

const navigation = [
  { name: 'Menú Principal', href: '/dashboard', icon: HomeIcon },
  { name: 'Maestro de Centros', href: '/centros', icon: ListBulletIcon },
  { name: 'Inspecciones', href: '/inspecciones', icon: DocumentMagnifyingGlassIcon },
];

const isActive = (href) => {
  return route.path === href || (href !== '/dashboard' && route.path.startsWith(href));
};

const handleLogout = async () => {
  await supabase.auth.signOut();
  router.push('/');
};
</script>

<template>
  <div class="flex h-screen bg-slate-100">
    <!-- Barra Lateral Oscura -->
    <aside class="w-64 flex-shrink-0 bg-slate-800 flex flex-col">
      <div class="h-20 flex items-center justify-center">
        <h1 class="text-2xl font-bold text-white tracking-wider">Arsel</h1>
      </div>
      <nav class="flex-1 px-4 py-2 space-y-2">
        <RouterLink
          v-for="item in navigation"
          :key="item.name"
          :to="item.href"
          :class="[
            'flex items-center px-3 py-3 text-sm font-medium rounded-lg transition-colors',
            isActive(item.href)
              ? 'bg-blue-600 text-white shadow-inner'
              : 'text-slate-300 hover:bg-slate-700 hover:text-white',
          ]"
        >
          <component :is="item.icon" class="h-6 w-6 mr-3" />
          {{ item.name }}
        </RouterLink>
      </nav>
      <div class="p-4 border-t border-slate-700">
        <button @click="handleLogout" class="w-full px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
          Cerrar Sesión
        </button>
      </div>
    </aside>

    <!-- Contenido Principal -->
    <div class="flex-1 flex flex-col overflow-hidden">
      <!-- ===== INICIO DE LA CORRECCIÓN: Se añade overflow-y-auto ===== -->
      <main class="flex-1 overflow-y-auto">
      <!-- ===== FIN DE LA CORRECCIÓN ===== -->
        <router-view />
      </main>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src/layouts/DefaultLayout.vue ---

