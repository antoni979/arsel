--- INICIO DEL ARCHIVO: package.json ---
{
  "name": "arsel",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "tailwind:init": "tailwindcss init -p"
  },
  "dependencies": {
    "@heroicons/vue": "^2.2.0",
    "@supabase/supabase-js": "^2.53.1",
    "chart.js": "^4.5.0",
    "html2canvas": "^1.4.1",
    "jspdf": "^3.0.1",
    "jspdf-autotable": "^5.0.2",
    "vue": "^3.5.18",
    "vue-chartjs": "^5.3.2",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "vite": "^7.1.0"
  }
}

--- FIN DEL ARCHIVO: package.json ---

--- INICIO DEL ARCHIVO: vite.config.js ---
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
  server: {
    host: true, // <-- AÑADE ESTA LÍNEA
    hmr: {
      clientPort: 443,
    }
  }
})
--- FIN DEL ARCHIVO: vite.config.js ---

--- INICIO DEL ARCHIVO: src\App.vue ---
<!-- src/App.vue -->
<script setup>
import { computed } from 'vue';
import { useRoute } from 'vue-router';
import DefaultLayout from './layouts/DefaultLayout.vue';
import BlankLayout from './layouts/BlankLayout.vue';

const route = useRoute();
const layout = computed(() => {
  if (route.meta.layout === 'Blank') {
    return BlankLayout;
  }
  return DefaultLayout;
});
</script>

<template>
  <component :is="layout">
    <router-view />
  </component>
</template>
--- FIN DEL ARCHIVO: src\App.vue ---

--- INICIO DEL ARCHIVO: src\main.js ---
// src/main.js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router' // Importamos nuestro router

const app = createApp(App)

app.use(router) // Le decimos a la app que use el router

app.mount('#app')
--- FIN DEL ARCHIVO: src\main.js ---

--- INICIO DEL ARCHIVO: src\style.css ---
/* src/style.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
--- FIN DEL ARCHIVO: src\style.css ---

--- INICIO DEL ARCHIVO: src\supabase.js ---
// src/supabase.js
import { createClient } from '@supabase/supabase-js'

// Estas líneas leen las claves que pusiste en el archivo .env.local
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

// Exportamos el cliente para poder usarlo en toda la aplicación
export const supabase = createClient(supabaseUrl, supabaseAnonKey)
--- FIN DEL ARCHIVO: src\supabase.js ---

--- INICIO DEL ARCHIVO: src\assets\vue.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
--- FIN DEL ARCHIVO: src\assets\vue.svg ---

--- INICIO DEL ARCHIVO: src\components\AddPointForm.vue ---
<!-- src/components/AddPointForm.vue -->
<script setup>
import { ref } from 'vue';

defineProps({
  salas: {
    type: Array,
    required: true
  }
});

const emit = defineEmits(['save', 'cancel']);

const selectedSalaId = ref(null);

const handleSave = () => {
  if (!selectedSalaId.value) {
    alert("Por favor, selecciona una sala.");
    return;
  }
  emit('save', selectedSalaId.value);
};
</script>

<template>
  <div class="p-2 bg-slate-50 rounded-lg">
    <h4 class="font-bold text-sm mb-2">Añadir Nuevo Punto</h4>
    <select v-model="selectedSalaId" class="block w-full rounded-md border-slate-300 shadow-sm text-sm mb-2">
      <option :value="null" disabled>Selecciona una sala...</option>
      <option v-for="sala in salas" :key="sala.id" :value="sala.id">{{ sala.nombre }}</option>
    </select>
    <div class="flex gap-2">
      <button @click="$emit('cancel')" class="w-full text-sm py-1 px-2 rounded bg-white border hover:bg-slate-50">Cancelar</button>
      <button @click="handleSave" class="w-full text-sm py-1 px-2 rounded bg-blue-600 text-white hover:bg-blue-700">Guardar</button>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\AddPointForm.vue ---

--- INICIO DEL ARCHIVO: src\components\CentroFormModal.vue ---
<!-- src/components/CentroFormModal.vue -->
<script setup>
import { ref, watch, nextTick } from 'vue';
import { provincias } from '../utils/provincias';
import { supabase } from '../supabase';
import { ArrowUpTrayIcon } from '@heroicons/vue/24/outline';

const props = defineProps({
  isOpen: Boolean,
  centro: Object,
});

const emit = defineEmits(['close', 'save']);

const form = ref({});
const isUploadingLogo = ref(false);
const logoInput = ref(null); // Referencia para el input de tipo file
const zonas = ['Norte', 'Sur', 'Este', 'Oeste', 'Centro', 'Noreste', 'Noroeste', 'Sureste', 'Islas Baleares', 'Islas Canarias'];

watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    // Usamos un clon del objeto para no modificar el original hasta guardar
    form.value = props.centro ? { ...props.centro } : { nombre: '', direccion: '', responsable_nombre: '', responsable_email: '', provincia: '', zona: '', url_logo_cliente: null };
  }
});

const handleLogoSelected = async (event) => {
  const file = event.target.files[0];
  if (!file || !form.value.id) {
    if(!form.value.id) alert("Guarda primero el centro para poder asignarle un logo.");
    return;
  }
  
  isUploadingLogo.value = true;
  const fileName = `cliente_${form.value.id}/${Date.now()}_${file.name}`;
  
  // Subir el nuevo logo
  const { error: uploadError } = await supabase.storage.from('logos-clientes').upload(fileName, file);
  if (uploadError) {
    alert("Error al subir el logo: " + uploadError.message);
    isUploadingLogo.value = false;
    return;
  }

  // Obtener la URL pública
  const { data: { publicUrl } } = supabase.storage.from('logos-clientes').getPublicUrl(fileName);

  // Actualizar el campo en la BBDD y en el formulario
  const { error: updateError } = await supabase
    .from('centros')
    .update({ url_logo_cliente: publicUrl })
    .eq('id', form.value.id);

  if (updateError) {
    alert("Error al guardar la URL del logo: " + updateError.message);
  } else {
    // Actualizamos el logo en el formulario para que se vea el cambio al instante
    form.value.url_logo_cliente = publicUrl;
  }
  isUploadingLogo.value = false;
};


const handleSubmit = () => {
  // Simplemente emitimos los datos del formulario. La subida del logo es independiente.
  emit('save', form.value);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
      <div class="p-6 border-b">
        <h2 class="text-2xl font-bold text-slate-800">{{ centro ? 'Editar Centro' : 'Agregar Nuevo Centro' }}</h2>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
          <!-- Columna 1 y 2: Campos del formulario -->
          <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="md:col-span-2">
              <label for="nombre" class="block text-sm font-medium text-slate-600">Nombre del Centro</label>
              <input v-model="form.nombre" type="text" id="nombre" required class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div class="md:col-span-2">
              <label for="direccion" class="block text-sm font-medium text-slate-600">Dirección</label>
              <input v-model="form.direccion" type="text" id="direccion" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_nombre" class="block text-sm font-medium text-slate-600">Nombre del Responsable</label>
              <input v-model="form.responsable_nombre" type="text" id="responsable_nombre" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="responsable_email" class="block text-sm font-medium text-slate-600">Email del Responsable</label>
              <input v-model="form.responsable_email" type="email" id="responsable_email" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>
            <div>
              <label for="provincia" class="block text-sm font-medium text-slate-600">Provincia</label>
              <select v-model="form.provincia" id="provincia" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <option disabled value="">Selecciona una provincia</option>
                <option v-for="p in provincias" :key="p" :value="p">{{ p }}</option>
              </select>
            </div>
            <div>
              <label for="zona" class="block text-sm font-medium text-slate-600">Zona</label>
              <select v-model="form.zona" id="zona" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <option disabled value="">Selecciona una zona</option>
                <option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
              </select>
            </div>
          </div>
          
          <!-- Columna 3: Logo del Cliente -->
          <div class="md:col-span-1">
             <input type="file" ref="logoInput" @change="handleLogoSelected" accept="image/*" class="hidden">
             <label class="block text-sm font-medium text-slate-600 mb-1">Logo del Cliente</label>
             <div class="aspect-video bg-slate-100 rounded-md flex items-center justify-center border-2 border-dashed">
                <img v-if="form.url_logo_cliente" :src="form.url_logo_cliente" class="object-contain w-full h-full p-2">
                <div v-else class="text-center text-slate-500 p-4">Sin logo</div>
             </div>
             <button 
                type="button" 
                @click="logoInput.click()" 
                :disabled="!form.id || isUploadingLogo"
                class="mt-2 w-full flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold rounded-md transition-colors
                       disabled:bg-slate-200 disabled:text-slate-500 disabled:cursor-not-allowed
                       text-slate-700 bg-white border border-slate-300 hover:bg-slate-50"
              >
               <ArrowUpTrayIcon class="h-4 w-4" />
               {{ isUploadingLogo ? 'Subiendo...' : (form.url_logo_cliente ? 'Cambiar Logo' : 'Subir Logo') }}
             </button>
             <p v-if="!form.id" class="text-xs text-slate-500 mt-1 text-center">Debes guardar el centro antes de subir un logo.</p>
          </div>
        </div>
        <div class="p-6 bg-slate-50 border-t flex justify-end space-x-4">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar Cambios</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\CentroFormModal.vue ---

--- INICIO DEL ARCHIVO: src\components\ChecklistModal.vue ---
<!-- src/components/ChecklistModal.vue -->
<script setup>
import { ref, watch, computed } from 'vue';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';
import { ArrowUpTrayIcon, CheckCircleIcon, XCircleIcon, PlusCircleIcon, TrashIcon, ArrowTrendingUpIcon, ArrowTrendingDownIcon, StopCircleIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  punto: Object,
  inspeccionId: Number,
});

const emit = defineEmits(['close', 'save']);

const incidencias = ref([]);
const loading = ref(false);
const isUploading = ref(null);
const puntoInspeccionado = ref(null);

const gravedadOptions = [
  { label: 'Leve', value: 'verde' },
  { label: 'Moderado', value: 'ambar' },
  { label: 'Grave', value: 'rojo' },
];

const tienePlaca = computed({
  get: () => puntoInspeccionado.value?.tiene_placa_caracteristicas,
  set: (newValue) => {
    if (puntoInspeccionado.value) {
      puntoInspeccionado.value.tiene_placa_caracteristicas = newValue;
      handlePlacaStatusChange(newValue);
    }
  }
});

const detalleModificacion = computed({
  get: () => puntoInspeccionado.value?.detalle_modificacion,
  set: (newValue) => {
    if (puntoInspeccionado.value) {
      puntoInspeccionado.value.detalle_modificacion = newValue;
      handleModificationChange(newValue);
    }
  }
});

const loadData = async () => {
  if (!props.punto || !props.inspeccionId) return;
  loading.value = true;
  
  const { data: puntoRelacionado, error: findError } = await supabase
    .from('puntos_inspeccionados')
    .select('*')
    .eq('inspeccion_id', props.inspeccionId)
    .eq('punto_maestro_id', props.punto.id)
    .maybeSingle();

  if (findError) {
    console.error("Error buscando punto inspeccionado:", findError);
    loading.value = false;
    return;
  }
  
  if (puntoRelacionado) {
    puntoInspeccionado.value = puntoRelacionado;
  } else {
    const { data: nuevoPunto, error: createError } = await supabase
      .from('puntos_inspeccionados')
      .insert({
        inspeccion_id: props.inspeccionId,
        punto_maestro_id: props.punto.id,
        nomenclatura: props.punto.nomenclatura,
        coordenada_x: props.punto.coordenada_x,
        coordenada_y: props.punto.coordenada_y,
        tiene_placa_caracteristicas: true,
      })
      .select('*')
      .single();
    
    if (createError) {
      console.error("Error crítico al crear el punto de inspección:", createError);
      loading.value = false;
      return;
    }
    puntoInspeccionado.value = nuevoPunto;
  }

  const { data: incidenciasData } = await supabase
    .from('incidencias')
    .select('*')
    .eq('punto_inspeccionado_id', puntoInspeccionado.value.id);
    
  incidencias.value = incidenciasData || [];
  loading.value = false;
};

watch(() => props.isOpen, (newVal) => {
  if (newVal) loadData();
});

const handlePlacaStatusChange = async (status) => {
  if (!puntoInspeccionado.value) return;

  await supabase
    .from('puntos_inspeccionados')
    .update({ tiene_placa_caracteristicas: status })
    .eq('id', puntoInspeccionado.value.id);

  const incidenciasPlaca = getIncidenciasForItem(2).value;

  if (status === true) {
    if (incidenciasPlaca.length > 0) {
      const idsToDelete = incidenciasPlaca.map(inc => inc.id);
      await supabase.from('incidencias').delete().in('id', idsToDelete);
      incidencias.value = incidencias.value.filter(inc => !idsToDelete.includes(inc.id));
    }
  } else {
    if (incidenciasPlaca.length === 0) {
      await addIncidencia(2, {
          gravedad: 'verde',
          observaciones: 'No dispone de placa de características.',
      });
    }
  }
};

const handleModificationChange = async (newStatus) => {
    if (!puntoInspeccionado.value) return;

    await supabase
        .from('puntos_inspeccionados')
        .update({ detalle_modificacion: newStatus })
        .eq('id', puntoInspeccionado.value.id);

    const incidenciasModificacion = getIncidenciasForItem(3).value;
    const idsToDelete = incidenciasModificacion.map(inc => inc.id);

    if (idsToDelete.length > 0) {
        await supabase.from('incidencias').delete().in('id', idsToDelete);
        incidencias.value = incidencias.value.filter(inc => !idsToDelete.includes(inc.id));
    }
    
    if (newStatus === 'aumentado') {
        await addIncidencia(3, {
            gravedad: 'ambar',
            observaciones: 'Se ha aumentado el número de módulos y/o niveles.',
        });
    } else if (newStatus === 'disminuido') {
        await addIncidencia(3, {
            gravedad: 'verde',
            observaciones: 'Se ha disminuido el número de módulos y/o niveles.',
        });
    }
};

const getIncidenciasForItem = (itemId) => {
    return computed(() => incidencias.value.filter(inc => inc.item_checklist === itemId));
};

const addIncidencia = async (itemId, defaults = {}) => {
  if (!puntoInspeccionado.value) return;
  const { data: newIncidencia } = await supabase
    .from('incidencias')
    .insert({
      punto_inspeccionado_id: puntoInspeccionado.value.id,
      inspeccion_id: props.inspeccionId,
      item_checklist: itemId,
      gravedad: defaults.gravedad || 'verde',
      observaciones: defaults.observaciones || null
    }).select().single();
    
  if (newIncidencia) {
    incidencias.value.push(newIncidencia);
  }
};

const deleteIncidencia = async (incidenciaId) => {
    const { error } = await supabase.from('incidencias').delete().eq('id', incidenciaId);
    if (!error) {
      incidencias.value = incidencias.value.filter(inc => inc.id !== incidenciaId);
    } else {
      alert("Error al borrar la incidencia: " + error.message);
    }
}

const toggleItemStatus = async (itemId) => {
    if (itemId === 2 || itemId === 3) {
        alert("El estado de este punto se gestiona automáticamente desde las preguntas superiores.");
        return;
    }
    
    const itemIncidencias = getIncidenciasForItem(itemId).value;

    if (itemIncidencias.length > 0) {
        if (confirm(`¿Marcar este punto como "Satisfactorio"? Se borrarán las ${itemIncidencias.length} incidencias registradas.`)) {
            const idsToDelete = itemIncidencias.map(inc => inc.id);
            const { error } = await supabase.from('incidencias').delete().in('id', idsToDelete);
            if (!error) {
                incidencias.value = incidencias.value.filter(inc => !idsToDelete.includes(inc.id));
            }
        }
    } else {
        await addIncidencia(itemId);
    }
};


const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;
  isUploading.value = incidencia.id;
  const fileName = `inspeccion_${props.inspeccionId}/punto_${puntoInspeccionado.value.id}/${Date.now()}_${file.name}`;
  const { error: uploadError } = await supabase.storage.from('incidencias').upload(fileName, file);
  if (uploadError) {
    alert("Error al subir la foto: " + uploadError.message);
    isUploading.value = null;
    return;
  }
  const { data: { publicUrl } } = supabase.storage.from('incidencias').getPublicUrl(fileName);
  incidencia.url_foto_antes = publicUrl;
  await saveIncidencia(incidencia);
  isUploading.value = null;
};

const saveIncidencia = async (incidencia) => {
  const { id, ...dataToUpdate } = incidencia;
  await supabase.from('incidencias').update(dataToUpdate).eq('id', id);
};

const handleClose = () => {
  emit('save');
  emit('close');
};
</script>

<template>
  <div v-if="isOpen" @click.self="handleClose" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-slate-50 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
      <header class="p-4 border-b bg-white rounded-t-lg flex justify-between items-center">
        <h2 class="text-xl font-bold text-slate-800">Checklist para Punto: {{ punto?.nomenclatura }}</h2>
        <button @click="handleClose" class="text-slate-400 hover:text-slate-600 text-2xl">&times;</button>
      </header>
      
      <main class="flex-1 overflow-y-auto p-6 space-y-3">
        <div v-if="loading" class="text-center p-10">Cargando datos del punto...</div>
        <div v-else>
          <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-6">
            <h3 class="font-bold text-blue-800 mb-3">¿Dispone de placa de características?</h3>
            <div class="flex gap-4">
              <button @click="tienePlaca = true" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === true ? 'bg-green-600 text-white shadow-md ring-2 ring-offset-2 ring-green-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><CheckCircleIcon class="h-5 w-5" />Sí, dispone de placa</button>
              <button @click="tienePlaca = false" :class="['w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', tienePlaca === false ? 'bg-red-600 text-white shadow-md ring-2 ring-offset-2 ring-red-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><XCircleIcon class="h-5 w-5" />No, no dispone de placa</button>
            </div>
            <p v-if="tienePlaca !== null" class="text-xs text-slate-500 mt-3 text-center">El estado del punto "2. Tiene las placas de identificación..." se ha actualizado automáticamente.</p>
          </div>

          <div class="bg-orange-50 border-2 border-orange-200 rounded-lg p-4 mb-6">
            <h3 class="font-bold text-orange-800 mb-3">¿Ha habido alguna modificación en los módulos/niveles?</h3>
            <div class="grid grid-cols-3 gap-4">
              <button @click="detalleModificacion = 'aumentado'" :class="['flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', detalleModificacion === 'aumentado' ? 'bg-amber-500 text-white shadow-md ring-2 ring-offset-2 ring-amber-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><ArrowTrendingUpIcon class="h-5 w-5" />Ha aumentado</button>
              <button @click="detalleModificacion = 'disminuido'" :class="['flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', detalleModificacion === 'disminuido' ? 'bg-teal-500 text-white shadow-md ring-2 ring-offset-2 ring-teal-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><ArrowTrendingDownIcon class="h-5 w-5" />Ha disminuido</button>
              <button @click="detalleModificacion = null" :class="['flex items-center justify-center gap-2 py-2 px-4 rounded-md font-semibold transition-all', detalleModificacion === null ? 'bg-slate-600 text-white shadow-md ring-2 ring-offset-2 ring-slate-500' : 'bg-white border text-slate-700 hover:bg-slate-100']"><StopCircleIcon class="h-5 w-5" />No ha cambiado</button>
            </div>
            <p v-if="detalleModificacion !== undefined" class="text-xs text-slate-500 mt-3 text-center">El estado del punto "3. El número de módulos y niveles..." se ha actualizado automáticamente.</p>
          </div>

          <div v-for="item in checklistItems" :key="item.id" class="bg-white rounded-lg shadow-sm border transition-all duration-300">
            <div class="p-3 flex items-center justify-between">
              <p class="text-slate-700">{{ item.id }}. {{ item.text }}</p>
              <button 
                @click="toggleItemStatus(item.id)"
                :disabled="item.id === 2 || item.id === 3"
                :class="['px-3 py-1 text-xs font-bold rounded-full disabled:cursor-not-allowed disabled:bg-slate-200 disabled:text-slate-500', 
                         getIncidenciasForItem(item.id).value.length > 0 ? 'bg-red-100 text-red-800 hover:bg-red-200' : 'bg-green-100 text-green-800 hover:bg-green-200']"
              >
                {{ getIncidenciasForItem(item.id).value.length > 0 ? 'INSATISFACTORIO' : 'SATISFACTORIO' }}
              </button>
            </div>
            
            <div v-if="getIncidenciasForItem(item.id).value.length > 0" class="border-t bg-slate-50 p-4 space-y-4">
              <div v-if="item.id === 2 || item.id === 3" class="text-center text-sm text-slate-600 bg-slate-200 p-2 rounded-md">
                 Este parámetro se gestiona automáticamente desde las preguntas superiores.
              </div>
              <div v-for="(incidencia, index) in getIncidenciasForItem(item.id).value" :key="incidencia.id" class="bg-white border rounded-lg p-4 shadow-sm relative">
                <div class="flex justify-between items-center mb-3">
                  <h4 class="font-bold text-slate-700">Incidencia #{{ index + 1 }}</h4>
                  <button v-if="item.id !== 2 && item.id !== 3" @click="deleteIncidencia(incidencia.id)" title="Borrar esta incidencia" class="p-1 text-slate-400 hover:text-red-500"><TrashIcon class="h-5 w-5"/></button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div class="space-y-4">
                    <div>
                      <label class="block text-xs font-medium text-slate-600">Gravedad</label>
                      <select v-model="incidencia.gravedad" @change="saveIncidencia(incidencia)" :disabled="item.id === 2 || item.id === 3" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm disabled:bg-slate-200"><option v-for="opt in gravedadOptions" :key="opt.value" :value="opt.value">{{ opt.label }}</option></select>
                    </div>
                    <div>
                      <label class="block text-xs font-medium text-slate-600">Observaciones</label>
                      <textarea v-model="incidencia.observaciones" @blur="saveIncidencia(incidencia)" rows="3" :disabled="item.id === 2 || item.id === 3" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm disabled:bg-slate-200"></textarea>
                    </div>
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-slate-600 mb-1">Foto de la Incidencia</label>
                    <div v-if="item.id === 2" class="aspect-video bg-slate-200 rounded-md flex items-center justify-center text-center p-4"><p class="text-sm text-slate-600">No se requiere fotografía para esta incidencia.</p></div>
                    <div v-else class="aspect-video bg-slate-200 rounded-md flex items-center justify-center overflow-hidden relative group">
                      <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="object-cover w-full h-full">
                      <div v-else class="text-center">
                        <p v-if="isUploading === incidencia.id" class="text-sm text-slate-600">Subiendo...</p>
                        <label v-else :for="'fileInput-' + incidencia.id" class="cursor-pointer flex items-center gap-2 px-3 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700"><ArrowUpTrayIcon class="h-4 w-4" />Subir Foto</label>
                        <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id">
                      </div>
                      <div v-if="incidencia.url_foto_antes" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                         <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-change-' + incidencia.id">
                         <label :for="'fileInput-change-' + incidencia.id" class="cursor-pointer text-white text-sm font-semibold">Cambiar Foto</label>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div v-if="item.id !== 2 && item.id !== 3">
                <button @click="addIncidencia(item.id)" class="w-full flex items-center justify-center gap-2 py-2 text-sm font-semibold text-blue-700 bg-blue-50 rounded-md hover:bg-blue-100 border border-dashed border-blue-300"><PlusCircleIcon class="h-5 w-5"/>Añadir otra incidencia a este parámetro</button>
              </div>

            </div>
          </div>
        </div>
      </main>

      <footer class="p-4 bg-white border-t rounded-b-lg flex justify-end">
        <button @click="handleClose" class="px-5 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Cerrar</button>
      </footer>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\ChecklistModal.vue ---

--- INICIO DEL ARCHIVO: src\components\InteractiveMap.vue ---
<!-- src/components/InteractiveMap.vue -->
<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';

const props = defineProps({
  imageUrl: { type: String, required: true },
  points: { type: Array, default: () => [] },
  salas: { type: Array, default: () => [] },
  isReadOnly: { type: Boolean, default: false },
  isPlacementMode: { type: Boolean, default: false },
  isAreaDrawingMode: { type: Boolean, default: false },
});

const emit = defineEmits(['add-point', 'delete-point', 'update-point-position', 'point-click', 'area-drawn', 'drawing-cancelled']);

const overlayRef = ref(null);
const draggedPointId = ref(null);

// --- INICIO DE CAMBIOS: Lógica de Dibujo Poligonal ---
const drawingPoints = ref([]); // Puntos del polígono que se está dibujando
const mousePosition = ref({ x: 0, y: 0 }); // Posición del ratón para feedback visual

// Resetea el dibujo si el modo cambia desde el padre
watch(() => props.isAreaDrawingMode, (newVal) => {
  if (!newVal) {
    drawingPoints.value = [];
  }
});

// Convierte un array de objetos [{x, y}] a un string "x1,y1 x2,y2..." para SVG
const toSvgPoints = (pointsArray, overlayWidth, overlayHeight) => {
  if (!pointsArray || pointsArray.length === 0) return "";
  return pointsArray.map(p => `${p.x * overlayWidth},${p.y * overlayHeight}`).join(' ');
};

const handleMapClick = (event) => {
  if (!overlayRef.value) return;
  const overlayRect = overlayRef.value.getBoundingClientRect();
  const x = (event.clientX - overlayRect.left) / overlayRect.width;
  const y = (event.clientY - overlayRect.top) / overlayRect.height;
  
  if (props.isAreaDrawingMode) {
    // Si estamos dibujando un área...
    if (drawingPoints.value.length > 2) {
      // Comprobar si se hace clic cerca del primer punto para cerrar el polígono
      const firstPoint = drawingPoints.value[0];
      const distance = Math.sqrt(Math.pow((x - firstPoint.x), 2) + Math.pow((y - firstPoint.y), 2));
      if (distance < 0.02) { // Umbral de "cercanía" (2% del ancho del mapa)
        emit('area-drawn', drawingPoints.value);
        drawingPoints.value = [];
        return;
      }
    }
    drawingPoints.value.push({ x, y });
  } else if (props.isPlacementMode) {
    // Si estamos colocando un punto...
    emit('add-point', { x, y });
  }
};

const handleMouseMove = (event) => {
    if (!props.isAreaDrawingMode || !overlayRef.value) return;
    const overlayRect = overlayRef.value.getBoundingClientRect();
    mousePosition.value.x = event.clientX - overlayRect.left;
    mousePosition.value.y = event.clientY - overlayRect.top;
};

// Atajo de teclado: Esc para cancelar el dibujo
const handleKeydown = (e) => {
    if (e.key === 'Escape' && props.isAreaDrawingMode) {
        drawingPoints.value = [];
        emit('drawing-cancelled');
    }
};

onMounted(() => window.addEventListener('keydown', handleKeydown));
onUnmounted(() => window.removeEventListener('keydown', handleKeydown));

// --- FIN DE CAMBIOS ---

const getSalaColor = (salaId) => {
  const sala = props.salas.find(s => s.id === salaId);
  return sala ? sala.color : '#9CA3AF';
};

const startDrag = (point) => {
  if (props.isReadOnly) return;
  draggedPointId.value = point.id;
};

const onDrag = (event) => {
  if (props.isReadOnly || draggedPointId.value === null || !overlayRef.value) return;
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (!point) return;
  const overlayRect = overlayRef.value.getBoundingClientRect();
  point.coordenada_x = (event.clientX - overlayRect.left) / overlayRect.width;
  point.coordenada_y = (event.clientY - overlayRect.top) / overlayRect.height;
};

const stopDrag = () => {
  if (draggedPointId.value === null) return;
  const point = props.points.find(p => p.id === draggedPointId.value);
  if (point) {
    emit('update-point-position', point);
  }
  draggedPointId.value = null;
};

const handleDeleteClick = (point) => {
  emit('delete-point', point);
};

const handlePointClick = (point) => {
  if (props.isPlacementMode || props.isAreaDrawingMode) return;
  emit('point-click', point);
};
</script>

<template>
  <div 
    class="relative w-full h-full flex justify-center items-center bg-slate-100"
    @mousemove="onDrag"
    @mouseup="stopDrag"
    @mouseleave="stopDrag"
  >
    <div class="relative max-w-full max-h-full">
      <img :src="imageUrl" class="block max-w-full max-h-full object-contain pointer-events-none" alt="Plano del centro">
      <div
        ref="overlayRef"
        class="absolute inset-0"
        :class="{ 'cursor-crosshair': isPlacementMode || isAreaDrawingMode }"
        @click="handleMapClick"
        @mousemove="handleMouseMove"
      >
        <!-- SVG para dibujar áreas poligonales -->
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none">
          <!-- Áreas de Salas guardadas -->
          <template v-for="sala in salas" :key="`sala-area-${sala.id}`">
            <polygon
              v-if="sala.area_puntos && overlayRef"
              :points="toSvgPoints(sala.area_puntos, overlayRef.clientWidth, overlayRef.clientHeight)"
              :style="{ fill: 'transparent', stroke: getSalaColor(sala.id), strokeWidth: '2px' }"
            />
          </template>

          <!-- Dibujo en progreso -->
          <g v-if="isAreaDrawingMode && overlayRef">
            <!-- Líneas entre los puntos ya hechos -->
            <polyline 
              :points="toSvgPoints(drawingPoints, overlayRef.clientWidth, overlayRef.clientHeight)"
              style="fill: none; stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
            <!-- Línea desde el último punto al cursor -->
            <line 
              v-if="drawingPoints.length > 0"
              :x1="drawingPoints[drawingPoints.length - 1].x * overlayRef.clientWidth"
              :y1="drawingPoints[drawingPoints.length - 1].y * overlayRef.clientHeight"
              :x2="mousePosition.x"
              :y2="mousePosition.y"
              style="stroke: #3b82f6; stroke-width: 2px; stroke-dasharray: 4;"
            />
             <!-- Puntos (vértices) del dibujo -->
            <circle
              v-for="(point, index) in drawingPoints"
              :key="`drawing-point-${index}`"
              :cx="point.x * overlayRef.clientWidth"
              :cy="point.y * overlayRef.clientHeight"
              r="5"
              :class="index === 0 ? 'fill-green-500 stroke-white' : 'fill-blue-500 stroke-white'"
              style="stroke-width: 2px;"
            />
          </g>
        </svg>

        <!-- Puntos de Inspección (se mantienen igual) -->
        <div
          v-for="point in points"
          :key="point.id"
          class="absolute w-8 h-8 -translate-x-1/2 -translate-y-1/2 border-2 border-white rounded-full flex items-center justify-center text-white text-xs font-bold group shadow-lg pointer-events-auto"
          :class="{ 
            'cursor-grab active:cursor-grabbing': !isReadOnly, 
            'cursor-pointer hover:scale-110 transition-transform': isReadOnly 
          }"
          :style="{ 
            left: (point.coordenada_x * 100) + '%', 
            top: (point.coordenada_y * 100) + '%',
            backgroundColor: point.color || getSalaColor(point.sala_id)
          }"
          @mousedown.stop="startDrag(point)"
          @click.stop="handlePointClick(point)"
        >
          {{ point.nomenclatura.split('-').pop() || '?' }}
          <button 
            v-if="!isReadOnly && (point.estado === 'nuevo' || point.estado === undefined)"
            @click.stop="handleDeleteClick(point)"
            class="absolute -top-2 -right-2 w-5 h-5 bg-red-600 text-white rounded-full text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
            title="Borrar punto"
          >X</button>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\InteractiveMap.vue ---

--- INICIO DEL ARCHIVO: src\components\Login.vue ---
<!-- src/components/Login.vue -->
<script setup>
import { ref } from 'vue'
import { supabase } from '../supabase'
import { useRouter } from 'vue-router'

const router = useRouter()
const loading = ref(false)
const email = ref('')
const password = ref('')

const handleLogin = async () => {
  try {
    loading.value = true
    const { error } = await supabase.auth.signInWithPassword({
      email: email.value,
      password: password.value,
    })
    if (error) throw error
    router.push('/dashboard')
  } catch (error) {
    alert(error.error_description || error.message)
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <!-- Cambiamos los colores de fondo y texto principales -->
  <div class="flex items-center justify-center min-h-screen bg-gray-100 text-gray-800">
    <!-- El contenedor del formulario ahora es blanco con una sombra sutil -->
    <div class="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
      <h1 class="text-3xl font-bold text-center text-gray-900">Inspección de Estanterías</h1>
      <p class="text-center text-gray-600">Inicia sesión para continuar</p>
      <form @submit.prevent="handleLogin" class="space-y-6">
        <div>
          <label for="email" class="block text-sm font-medium text-gray-700">Email</label>
          <!-- Los inputs ahora tienen un fondo más claro -->
          <input 
            id="email" 
            type="email" 
            v-model="email" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="email"
            required
          />
        </div>
        <div>
          <label for="password" class="block text-sm font-medium text-gray-700">Contraseña</label>
          <input 
            id="password" 
            type="password" 
            v-model="password" 
            class="w-full px-3 py-2 mt-1 text-gray-900 bg-gray-50 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            autocomplete="current-password"
            required
          />
        </div>
        <div>
          <button 
            type="submit" 
            :disabled="loading" 
            class="w-full py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            {{ loading ? 'Cargando...' : 'Acceder' }}
          </button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\Login.vue ---

--- INICIO DEL ARCHIVO: src\components\MarkAsSentModal.vue ---
<!-- src/components/MarkAsSentModal.vue -->
<script setup>
import { ref, watch } from 'vue';
import { PaperAirplaneIcon } from '@heroicons/vue/24/solid';

const props = defineProps({
  isOpen: Boolean,
  inspeccionId: Number,
});

const emit = defineEmits(['close', 'save']);

const formData = ref({
  fecha_envio: '',
  responsable_envio: '',
});

// Cuando el modal se abre, pre-rellenamos la fecha con el día de hoy
watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    formData.value = {
      fecha_envio: new Date().toISOString().slice(0, 10), // Formato YYYY-MM-DD
      responsable_envio: '',
    };
  }
});

const handleSubmit = () => {
  if (!formData.value.fecha_envio || !formData.value.responsable_envio) {
    alert('Por favor, completa todos los campos.');
    return;
  }
  emit('save', formData.value);
};
</script>

<template>
  <div v-if="isOpen" class="fixed inset-0 bg-black bg-opacity-60 z-50 flex justify-center items-center p-4">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md transform transition-all">
      <div class="p-6 border-b border-slate-200 text-center">
        <div class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
            <PaperAirplaneIcon class="h-6 w-6 text-blue-600" aria-hidden="true" />
        </div>
        <h2 class="mt-4 text-xl font-bold text-slate-800">Confirmar Envío a Cliente</h2>
        <p class="text-sm text-slate-500 mt-1">Registra la fecha y el responsable del envío.</p>
      </div>
      <form @submit.prevent="handleSubmit">
        <div class="p-6 space-y-4">
          <div>
            <label for="fecha_envio" class="block text-sm font-medium text-slate-600">Fecha de Envío</label>
            <input 
              v-model="formData.fecha_envio" 
              type="date" 
              id="fecha_envio" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
          <div>
            <label for="responsable_envio" class="block text-sm font-medium text-slate-600">Enviado por</label>
            <input 
              v-model="formData.responsable_envio" 
              type="text" 
              id="responsable_envio" 
              placeholder="Nombre del responsable" 
              required 
              class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            >
          </div>
        </div>
        <div class="p-4 bg-slate-50 border-t border-slate-200 flex justify-end space-x-3">
          <button type="button" @click="$emit('close')" class="px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Cancelar</button>
          <button type="submit" class="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Guardar y Marcar</button>
        </div>
      </form>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\MarkAsSentModal.vue ---

--- INICIO DEL ARCHIVO: src\components\PlanoBadge.vue ---
<!-- src/components/PlanoBadge.vue -->
<template>
  <div
    class="w-full h-full p-1 flex flex-col items-center bg-white rounded shadow-lg border border-gray-300 cursor-move"
    style="font-family: sans-serif;"
  >
    <div class="font-bold text-center text-[7px] text-[#333]">Punto {{ pointNumber }}</div>
    <hr class="w-full my-[0.5px] border-t border-gray-200">
    
    <div v-if="stateText" class="font-bold text-center text-[5.5px] text-[#555]">
      {{ stateText }}
    </div>

    <div class="flex-1 w-full flex flex-col justify-center items-center space-y-[1px] px-1">
      <div v-for="item in semaphoreItems" :key="item.label" class="w-full flex justify-between items-center">
        <div class="w-[6px] h-[6px] rounded-full" :style="{ backgroundColor: item.color }"></div>
        <div class="font-normal text-right text-[6px] text-[#555]">{{ item.count }}</div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  pointData: Object,
  position: Object,
  size: Object
});

const pointNumber = computed(() => props.pointData.nomenclatura.split('-').pop() || '?');

const stateText = computed(() => {
  if (props.pointData.estado === 'nuevo') return 'NUEVA';
  if (props.pointData.estado === 'suprimido') return 'SUPRIMIDA';
  if (props.pointData.detalle_modificacion === 'aumentado') return 'AUMENTADA';
  if (props.pointData.detalle_modificacion === 'disminuido') return 'DISMINUIDA';
  return null;
});

const semaphoreItems = computed(() => [
  { label: 'verde', color: '#22C55E', count: props.pointData.counts.verde },
  { label: 'ambar', color: '#F59E0B', count: props.pointData.counts.ambar },
  { label: 'rojo', color: '#EF4444', count: props.pointData.counts.rojo },
]);
</script>
--- FIN DEL ARCHIVO: src\components\PlanoBadge.vue ---

--- INICIO DEL ARCHIVO: src\components\PointList.vue ---
<!-- src/components/PointList.vue -->
<script setup>
import { ref } from 'vue';
import { EyeSlashIcon, ArrowUturnLeftIcon, TrashIcon, ChevronDownIcon } from '@heroicons/vue/24/solid';

defineProps({
  groupedPoints: {
    type: Array,
    required: true
  }
});

defineEmits(['select-point', 'update-state', 'delete-new-point']);

const openSalaId = ref(null);

const toggleSala = (salaId) => {
  openSalaId.value = openSalaId.value === salaId ? null : salaId;
};
</script>

<template>
  <div class="space-y-2">
    <div v-for="grupo in groupedPoints" :key="grupo.id">
      <!-- Encabezado de la Sala (clickeable) -->
      <button @click="toggleSala(grupo.id)" class="w-full flex justify-between items-center p-3 rounded-lg text-left" :class="openSalaId === grupo.id ? 'bg-blue-50' : 'hover:bg-slate-50'">
        <h3 class="font-bold text-slate-700">{{ grupo.nombre }}</h3>
        <ChevronDownIcon class="h-5 w-5 text-slate-400 transition-transform" :class="{'rotate-180': openSalaId === grupo.id}" />
      </button>

      <!-- Lista de Puntos (se muestra si la sala está abierta) -->
      <ul v-if="openSalaId === grupo.id" class="space-y-1 pl-4 border-l-2 ml-3">
        <li v-for="punto in grupo.puntos" :key="punto.id">
          <div :class="['p-2 rounded-lg flex items-center justify-between group', { 'bg-slate-100': punto.estado === 'suprimido' }]">
            <button @click="$emit('select-point', punto)" 
                    :disabled="punto.estado === 'suprimido'"
                    class="flex-1 text-left disabled:cursor-not-allowed">
              <div class="flex items-center">
                <span class="w-3 h-3 rounded-full flex-shrink-0" :style="{ backgroundColor: punto.color }"></span>
                <span :class="['font-semibold ml-3', { 'line-through text-slate-500': punto.estado === 'suprimido', 'text-slate-700': punto.estado !== 'suprimido' }]">
                  {{ punto.nomenclatura }}
                </span>
                <span v-if="punto.estado === 'nuevo'" class="ml-2 text-xs font-bold text-green-600 bg-green-100 px-2 py-0.5 rounded-full">NUEVO</span>
              </div>
            </button>
            <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
              <button v-if="punto.estado === 'nuevo'" @click="$emit('delete-new-point', punto)" class="p-1 text-slate-400 hover:text-red-500" title="Borrar punto nuevo">
                <TrashIcon class="h-5 w-5" />
              </button>
              
              <button v-if="punto.estado !== 'suprimido'" @click="$emit('update-state', punto, 'suprimido')" class="p-1 text-slate-400 hover:text-red-500" title="Marcar como suprimido">
                <EyeSlashIcon class="h-5 w-5" />
              </button>
              <button v-else @click="$emit('update-state', punto, 'existente')" class="p-1 text-slate-500 hover:text-blue-500" title="Reactivar punto">
                <ArrowUturnLeftIcon class="h-5 w-5" />
              </button>
            </div>
          </div>
        </li>
      </ul>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\components\PointList.vue ---

--- INICIO DEL ARCHIVO: src\layouts\BlankLayout.vue ---
<!-- src/layouts/BlankLayout.vue -->
<template>
  <router-view />
</template>
--- FIN DEL ARCHIVO: src\layouts\BlankLayout.vue ---

--- INICIO DEL ARCHIVO: src\layouts\DefaultLayout.vue ---
<!-- src/layouts/DefaultLayout.vue -->
<script setup>
import { RouterLink, useRoute } from 'vue-router';
import { HomeIcon, ListBulletIcon, DocumentMagnifyingGlassIcon } from '@heroicons/vue/24/outline';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';

const route = useRoute();
const router = useRouter();

const navigation = [
  { name: 'Menú Principal', href: '/dashboard', icon: HomeIcon },
  { name: 'Maestro de Centros', href: '/centros', icon: ListBulletIcon },
  { name: 'Inspecciones', href: '/inspecciones', icon: DocumentMagnifyingGlassIcon },
];

const isActive = (href) => {
  return route.path === href || (href !== '/dashboard' && route.path.startsWith(href));
};

const handleLogout = async () => {
  await supabase.auth.signOut();
  router.push('/');
};
</script>

<template>
  <div class="flex h-screen bg-slate-100">
    <!-- Barra Lateral Oscura -->
    <aside class="w-64 flex-shrink-0 bg-slate-800 flex flex-col">
      <div class="h-20 flex items-center justify-center">
        <h1 class="text-2xl font-bold text-white tracking-wider">Arsel</h1>
      </div>
      <nav class="flex-1 px-4 py-2 space-y-2">
        <RouterLink
          v-for="item in navigation"
          :key="item.name"
          :to="item.href"
          :class="[
            'flex items-center px-3 py-3 text-sm font-medium rounded-lg transition-colors',
            isActive(item.href)
              ? 'bg-blue-600 text-white shadow-inner'
              : 'text-slate-300 hover:bg-slate-700 hover:text-white',
          ]"
        >
          <component :is="item.icon" class="h-6 w-6 mr-3" />
          {{ item.name }}
        </RouterLink>
      </nav>
      <div class="p-4 border-t border-slate-700">
        <button @click="handleLogout" class="w-full px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
          Cerrar Sesión
        </button>
      </div>
    </aside>

    <!-- Contenido Principal -->
    <div class="flex-1 flex flex-col overflow-hidden">
      <main class="flex-1 overflow-hidden">
        <router-view />
      </main>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\layouts\DefaultLayout.vue ---

--- INICIO DEL ARCHIVO: src\router\index.js ---
// src/router/index.js

import { createRouter, createWebHistory } from 'vue-router'
import { supabase } from '../supabase'

// Importación de Vistas y Componentes
import DashboardView from '../views/DashboardView.vue'
import Login from '../components/Login.vue'
import CentrosListView from '../views/CentrosListView.vue'
import CentroConfigView from '../views/CentroConfigView.vue'
import InspeccionesListView from '../views/InspeccionesListView.vue'
import InspeccionDetailView from '../views/InspeccionDetailView.vue'
import CentroHistorialView from '../views/CentroHistorialView.vue';
import CentroVersionsView from '../views/CentroVersionsView.vue';
import SubsanacionView from '../views/SubsanacionView.vue';

const routes = [
  { path: '/', name: 'Login', component: Login, meta: { layout: 'Blank' } },
  { path: '/dashboard', name: 'Dashboard', component: DashboardView, meta: { requiresAuth: true } },
  { path: '/centros', name: 'CentrosList', component: CentrosListView, meta: { requiresAuth: true } },
  { path: '/centros/:id/versiones', name: 'CentroVersions', component: CentroVersionsView, meta: { requiresAuth: true } },
  { path: '/versiones/:id/configurar', name: 'VersionConfig', component: CentroConfigView, meta: { requiresAuth: true } },
  { path: '/inspecciones', name: 'InspeccionesList', component: InspeccionesListView, meta: { requiresAuth: true } },
  { path: '/inspecciones/:id', name: 'InspeccionDetail', component: InspeccionDetailView, meta: { requiresAuth: true } },
  { path: '/centros/:id/historial', name: 'CentroHistorial', component: CentroHistorialView, meta: { requiresAuth: true } },
  {
    path: '/inspecciones/:id/plano-preview',
    name: 'PlanoPreview',
    component: () => import('../views/PlanoPreviewView.vue'),
    meta: { layout: 'Blank' }
  },
  {
    path: '/inspecciones/:id/subsanar',
    name: 'SubsanacionDetail',
    component: SubsanacionView,
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

router.beforeEach(async (to, from, next) => {
  // --- LOG DE DEBUG ---
  console.log(`[Router] Navegando de '${from.fullPath}' a '${to.fullPath}'`);
  
  const { data: { session } } = await supabase.auth.getSession()
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth)

  if (requiresAuth && !session) { next({ name: 'Login' }) } 
  else if (session && to.name === 'Login') { next({ name: 'Dashboard' }) }
  else { next() }
})

export default router
--- FIN DEL ARCHIVO: src\router\index.js ---

--- INICIO DEL ARCHIVO: src\utils\checklist.js ---
// src/utils/checklist.js
export const checklistItems = [
  { id: 1, text: "Existe copia de la documentación de validación" },
  { id: 2, text: "Tiene las placas de identificación correctamente colocadas y son legibles." },
  { id: 3, text: "El número de módulos y niveles se corresponde con el establecido en el documento de validación." },
  { id: 4, text: "Los niveles de altura están dentro de los límites establecidos." },
  { id: 5, text: "El tipo de puntal se corresponde con el del documento de validación." },
  { id: 6, text: "La verticalidad de los puntales está dentro de los límites permitidos." },
  { id: 7, text: "Las placas base no presentan deterioro y tienen todos los tornillos de fijación previsto." },
  { id: 8, text: "Las placas base no presentan descalce." },
  { id: 9, text: "La estantería no está fijada a otros elementos." },
  { id: 10, text: "La estantería no sirve de soporte a otros elementos." },
  { id: 11, text: "Los puntales no presentan deterioro." },
  { id: 12, text: "Las diagonales y horizontales de bastidores no presentan deterioro." },
  { id: 13, text: "El tipo de larguero se corresponde con el del documento de validación." },
  { id: 14, text: "Los largueros no presentan deterioro." },
  { id: 15, text: "Los largueros están montados horizontales y a la misma altura que el larguero opuesto." },
  { id: 16, text: "La flecha de los largueros está dentro de los límites establecidos en el documento de validación." },
  { id: 17, text: "Los largueros tienen puesto correctamente el dispositivo de fijación (horquillas)." },
  { id: 18, text: "No se aprecia en inspección visual grietas en soldadura o material base." },
  { id: 19, text: "Los elementos del sistema no presentan degradación por pérdida de pintura de protección y/o oxidación." },
  { id: 20, text: "El estado de las protecciones en el bastidor es correcto (mantienen distancia de seguridad y están correctamente fijadas al suelo)." },
  { id: 21, text: "Las cargas se ajustan a las dimensiones estandarizadas para las paletas." },
  { id: 22, text: "Las cargas a nivel de suelo no sobresalen de la alineación, respetando los anchos de pasillo." },
  { id: 23, text: "La iluminación es adecuada." },
  { id: 24, text: "En estanterías de picking las barandillas de segundo nivel están en perfecto estado, tienen pasamanos superior, intermedio y rodapié." },
  { id: 25, text: "En estanterías de picking se mantienen todos los elementos de los niveles previstos y en caso contrario se mantiene los largueros y/o baldas superiores y se ha señalizado correctamente 'no utilizar'." },
  { id: 26, text: "La carga se distribuye uniformemente y de forma ordenada." },
  { id: 27, text: "Las cargas están dentro de los límites establecidos en las placas identificativas." },
];
--- FIN DEL ARCHIVO: src\utils\checklist.js ---

--- INICIO DEL ARCHIVO: src\utils\plano-layout.js ---
// src/utils/plano-layout.js

/**
 * Lógica centralizada para calcular el layout del plano de incidencias.
 * Esta función es "pura": recibe datos y devuelve la estructura del layout.
 */
export function calculatePlanoLayout(allPointsData, mapDimensions) {
    const placedObstacles = allPointsData.map(p => ({
        x: p.absX - 5,
        y: p.absY - 5,
        width: 10,
        height: 10
    }));

    const labelsToDraw = [];

    const mapCenterX = mapDimensions.x + mapDimensions.width / 2;
    const mapCenterY = mapDimensions.y + mapDimensions.height / 2;
    
    // Clonamos y ordenamos los puntos
    const sortedPoints = [...allPointsData].sort((a, b) => {
        const distA = Math.sqrt(Math.pow(a.absX - mapCenterX, 2) + Math.pow(a.absY - mapCenterY, 2));
        const distB = Math.sqrt(Math.pow(b.absX - mapCenterX, 2) + Math.pow(b.absY - mapCenterY, 2));
        return distA - distB;
    });

    for (const point of sortedPoints) {
        const needsBadge = point.estado !== 'existente' || point.detalle_modificacion !== null ||
            (point.counts.verde > 0 || point.counts.ambar > 0 || point.counts.rojo > 0);

        if (!needsBadge) continue;

        let badgeHeight = (1.2 * 2) + (4 * 3) + (7 + 1.2 + 1);
        if (point.estado !== 'existente' || point.detalle_modificacion !== null) {
            badgeHeight += 5.5 + 1.2;
        }
        const badgeSize = { width: 14, height: badgeHeight };

        const finalPosition = findNonOverlappingPosition(point, badgeSize, placedObstacles, mapDimensions);

        const badgeRect = {
            x: finalPosition.x - badgeSize.width / 2,
            y: finalPosition.y - badgeSize.height / 2,
            ...badgeSize
        };

        placedObstacles.push(badgeRect);
        
        // Almacenamos la posición reactiva
        labelsToDraw.push({
            pointData: point,
            position: { x: finalPosition.x, y: finalPosition.y },
            size: badgeSize
        });
    }

    return labelsToDraw;
}


function findNonOverlappingPosition(point, badgeSize, obstacles, pageBounds) {
    const isOverlapping = (rect1, rect2) => {
        const margin = 2;
        return !(rect1.x > rect2.x + rect2.width + margin ||
            rect1.x + rect1.width + margin < rect2.x ||
            rect1.y > rect2.y + rect2.height + margin ||
            rect1.y + rect1.height + margin < rect2.y);
    };

    const isWithinBounds = (rect) => {
        return rect.x >= pageBounds.x &&
            rect.y >= pageBounds.y &&
            rect.x + rect.width <= pageBounds.x + pageBounds.width &&
            rect.y + rect.height <= pageBounds.y + pageBounds.height;
    };

    const checkPosition = (pos) => {
        const candidateRect = {
            x: pos.x - badgeSize.width / 2,
            y: pos.y - badgeSize.height / 2,
            width: badgeSize.width,
            height: badgeSize.height
        };
        if (isWithinBounds(candidateRect) && !obstacles.some(obs => isOverlapping(candidateRect, obs))) {
            return pos;
        }
        return null;
    };

    const preferredOffsets = [
        { x: 0, y: -(badgeSize.height / 2 + 8) }, { x: 0, y: (badgeSize.height / 2 + 8) },
        { x: (badgeSize.width / 2 + 8), y: 0 },   { x: -(badgeSize.width / 2 + 8), y: 0 },
        { x: 15, y: -15 }, { x: -15, y: -15 }, { x: 15, y: 15 }, { x: -15, y: 15 }
    ];

    for (const offset of preferredOffsets) {
        const position = checkPosition({ x: point.absX + offset.x, y: point.absY + offset.y });
        if (position) return position;
    }

    let x = point.absX;
    let y = point.absY;
    let dx = 0;
    let dy = -1;
    let stepSize = 5;
    let stepsInSegment = 1;
    let turnCounter = 0;

    for (let i = 0; i < 5000; i++) {
        for (let j = 0; j < Math.floor(stepsInSegment); j++) {
            x += dx * stepSize;
            y += dy * stepSize;
            const position = checkPosition({ x, y });
            if (position) return position;
        }
        [dx, dy] = [-dy, dx];
        turnCounter++;
        if (turnCounter % 2 === 0) {
            stepsInSegment += 1;
        }
    }
    
    return { x: point.absX, y: point.absY - 25 };
}
--- FIN DEL ARCHIVO: src\utils\plano-layout.js ---

--- INICIO DEL ARCHIVO: src\utils\provincias.js ---
// src/utils/provincias.js
export const provincias = [
  'Álava', 'Albacete', 'Alicante', 'Almería', 'Asturias', 'Ávila', 'Badajoz', 'Barcelona', 'Burgos', 'Cáceres', 
  'Cádiz', 'Cantabria', 'Castellón', 'Ciudad Real', 'Córdoba', 'La Coruña', 'Cuenca', 'Gerona', 'Granada', 'Guadalajara', 
  'Guipúzcoa', 'Huelva', 'Huesca', 'Islas Baleares', 'Jaén', 'León', 'Lérida', 'Lugo', 'Madrid', 'Málaga', 'Murcia', 
  'Navarra', 'Orense', 'Palencia', 'Las Palmas', 'Pontevedra', 'La Rioja', 'Salamanca', 'Segovia', 'Sevilla', 
  'Soria', 'Tarragona', 'Santa Cruz de Tenerife', 'Teruel', 'Toledo', 'Valencia', 'Valladolid', 'Vizcaya', 'Zamora', 'Zaragoza'
];
--- FIN DEL ARCHIVO: src\utils\provincias.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\index.js ---
// src/utils/pdf/index.js

import jsPDF from 'jspdf';
import { fetchReportData } from './pdf-data';
import { buildTextPages } from './pdf-module-text';
import { buildInitialPhotoAnnex, buildRemediationPhotoAnnex } from './pdf-module-photos';
import { buildChecklistAnnex } from './pdf-module-checklist';
import { buildSummaryAnnex } from './pdf-module-summary';

/**
 * Genera el informe en PDF con texto, fotos y checklists, pero SIN el plano visual.
 * @param {number} inspeccionId - El ID de la inspección.
 * @param {string} reportType - 'initial' o 'remediation'.
 */
export async function generateTextReport(inspeccionId, reportType = 'initial') {
  try {
    console.log("Iniciando generación de Informe de Texto...");
    const reportData = await fetchReportData(inspeccionId); // <-- Ahora contiene todo lo necesario
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    console.log("Construyendo páginas de texto...");
    await buildTextPages(pdf, reportData);
    
    if (reportType === 'initial') {
      console.log("Construyendo anexo de fotos inicial...");
      await buildInitialPhotoAnnex(pdf, reportData);
    } else if (reportType === 'remediation') {
      console.log("Construyendo anexo de fotos de subsanación...");
      await buildRemediationPhotoAnnex(pdf, reportData);
    }
    
    console.log("Construyendo anexo de checklist...");
    await buildChecklistAnnex(pdf, reportData);
    
    const { inspectionData } = reportData;
    const reportTypeName = reportType === 'initial' ? 'Informe' : 'Subsanacion';
    const fileName = `${reportTypeName}_${inspectionData.centros.nombre.replace(/ /g, '_')}_${inspectionData.fecha_inspeccion}.pdf`;
    
    console.log(`Guardando PDF como: ${fileName}`);
    pdf.save(fileName);

  } catch (err) {
    console.error("Error generando el Informe de Texto:", err);
    alert(`Hubo un error al generar el informe. Revisa la consola: ${err.message}`);
  }
}

/**
 * Genera un PDF que contiene ÚNICAMENTE el plano visual de incidencias.
 * @param {number} inspeccionId - El ID de la inspección.
 */
export async function generatePlanPdf(inspeccionId) {
  try {
    console.log("Iniciando generación de PDF del Plano...");
    const reportData = await fetchReportData(inspeccionId); // <-- Ahora contiene todo lo necesario, incluyendo planoBase64
    
    // --- INICIO DE CORRECCIÓN ---
    // Comprobamos si el plano se pudo cargar
    if (!reportData.planoBase64) {
        throw new Error("No se pudo cargar la imagen del plano para esta inspección.");
    }
    // --- FIN DE CORRECCIÓN ---

    const pdf = new jsPDF('l', 'mm', 'a4'); // Apaisado
    
    console.log("Construyendo anexo de resumen visual...");
    await buildSummaryAnnex(pdf, reportData); // Pasamos el objeto completo
    
    const { inspectionData } = reportData;
    const fileName = `Plano_Incidencias_${inspectionData.centros.nombre.replace(/ /g, '_')}_${inspectionData.fecha_inspeccion}.pdf`;
    
    console.log(`Guardando PDF como: ${fileName}`);
    pdf.save(fileName);

  } catch (err) {
    console.error("Error generando el PDF del Plano:", err);
    alert(`Hubo un error al generar el plano. Revisa la consola: ${err.message}`);
  }
}
--- FIN DEL ARCHIVO: src\utils\pdf\index.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\pdf-data.js ---
// src/utils/pdf/pdf-data.js

import { supabase } from '../../supabase';
import { loadImageAsBase64 } from './pdf-helpers';

export async function fetchReportData(inspeccionId) {
  // --- LOG DE DEBUG ---
  console.log(`[fetchReportData] Iniciando búsqueda de datos para la inspección ID: ${inspeccionId}`);
  
  try {
    const { data: inspectionData, error: inspectionError } = await supabase
      .from('inspecciones')
      .select('*, centros(*), versiones_plano(*)')
      .eq('id', inspeccionId)
      .single();
    
    // --- LOG DE DEBUG ---
    if (inspectionError) {
      console.error('[fetchReportData] ¡ERROR CRÍTICO al obtener la inspección!', inspectionError);
      throw new Error(`Error al obtener la inspección: ${inspectionError.message}`);
    }
    console.log('[fetchReportData] Datos de la inspección principal obtenidos:', inspectionData);
    
    if (!inspectionData.centros) {
      console.error('[fetchReportData] ¡ERROR! La inspección no tiene un centro asociado.');
      throw new Error('Datos del centro no encontrados para esta inspección.');
    }

    const versionId = inspectionData.versiones_plano?.id;
    // --- LOG DE DEBUG ---
    console.log(`[fetchReportData] Usando la versión de plano ID: ${versionId}`);

    const planoUrl = inspectionData.versiones_plano?.url_imagen_plano;
    const planoBase64 = planoUrl ? await loadImageAsBase64(planoUrl) : null;
    // --- LOG DE DEBUG ---
    console.log(`[fetchReportData] ¿Se cargó la imagen del plano? -> ${planoBase64 ? 'Sí' : 'No'}`);

    const [
      { data: salasData, error: salasError },
      { data: puntosMaestrosData, error: puntosMaestrosError },
      { data: puntosInspeccionadosData, error: puntosInspeccionadosError },
      { data: incidenciasData, error: incidenciasError }
    ] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', versionId).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', versionId),
      supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId),
      supabase.from('incidencias').select('*').eq('inspeccion_id', inspeccionId)
    ]);

    if (salasError || puntosMaestrosError || puntosInspeccionadosError || incidenciasError) {
      console.error('[fetchReportData] ¡ERROR en una de las consultas en paralelo!', { salasError, puntosMaestrosError, puntosInspeccionadosError, incidenciasError });
      throw new Error('Error al obtener datos relacionados con la inspección.');
    }
    // --- LOG DE DEBUG ---
    console.log('[fetchReportData] Datos relacionados obtenidos:', {
        salas: salasData?.length,
        puntosMaestros: puntosMaestrosData?.length,
        puntosInspeccionados: puntosInspeccionadosData?.length,
        incidencias: incidenciasData?.length
    });
    
    const incidenceCounts = new Map();
    (puntosInspeccionadosData || []).forEach(pi => {
        incidenceCounts.set(pi.id, { verde: 0, ambar: 0, rojo: 0 });
    });
    (incidenciasData || []).forEach(inc => {
        const counts = incidenceCounts.get(inc.punto_inspeccionado_id);
        if (counts && counts[inc.gravedad] !== undefined) {
            counts[inc.gravedad]++;
        }
    });

    const result = {
      inspectionData,
      salasData: salasData || [],
      puntosMaestrosData: puntosMaestrosData || [],
      puntosInspeccionadosData: puntosInspeccionadosData || [],
      incidenciasData: incidenciasData || [],
      planoBase64,
      incidenceCounts,
    };
    
    // --- LOG DE DEBUG ---
    console.log('[fetchReportData] Búsqueda de datos completada con éxito.');
    return result;

  } catch (error) {
    console.error('[fetchReportData] La función ha fallado con una excepción:', error);
    // Devolvemos null para que el componente que llama sepa que algo fue mal
    return null;
  }
}
--- FIN DEL ARCHIVO: src\utils\pdf\pdf-data.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\pdf-helpers.js ---
// src/utils/pdf/pdf-helpers.js

// --- CONSTANTES ---
export const MARGIN = 15;
export const DOC_WIDTH = 210;
export const DOC_WIDTH_LANDSCAPE = 297;
export const FONT_SIZES = { annexTitle: 22, title: 16, h1: 14, h2: 12, body: 11, small: 8 };
export const ARSEL_LOGO_URL = "https://bgltxcklvjumltuktdvv.supabase.co/storage/v1/object/public/logos-clientes/logo.PNG";

// --- FUNCIÓN DE AYUDA PARA CARGAR IMÁGENES ---
export async function loadImageAsBase64(url) {
  if (!url || !url.startsWith('http')) return null;
  try {
    const response = await fetch(url);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.startsWith("image/")) {
      console.warn(`La URL no devolvió una imagen: ${url}`);
      return null;
    }
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.error("Error cargando imagen para PDF:", url, error);
    return null;
  }
}

// --- CABECERA PRINCIPAL (REUTILIZABLE EN TODO EL PDF) ---
export async function drawHeader(pdf, inspectionData) {
  const [clientLogoBase64, arselLogoBase64] = await Promise.all([
    loadImageAsBase64(inspectionData.centros.url_logo_cliente),
    loadImageAsBase64(ARSEL_LOGO_URL)
  ]);

  // === INICIO DE LA CORRECCIÓN: Usamos el método oficial de jsPDF ===
  const pageSize = pdf.internal.pageSize;
  const pageWidth = pageSize.getWidth();
  // === FIN DE LA CORRECCIÓN ===

  const headerY = MARGIN - 8;
  const headerHeight = 20;
  const contentWidth = pageWidth - (MARGIN * 2); 
  const cell1Width = 40;
  const cell3Width = 40;
  const cell2Width = contentWidth - cell1Width - cell3Width;

  pdf.rect(MARGIN, headerY, contentWidth, headerHeight);
  pdf.line(MARGIN, headerY + 8, pageWidth - MARGIN, headerY + 8);
  pdf.line(MARGIN + cell1Width, headerY + 8, MARGIN + cell1Width, headerY + headerHeight);
  pdf.line(MARGIN + cell1Width + cell2Width, headerY + 8, MARGIN + cell1Width + cell2Width, headerY + headerHeight);

  pdf.setFontSize(FONT_SIZES.h2).setFont(undefined, 'bold');
  pdf.text(`HIPERMERCADO ${inspectionData.centros.nombre.toUpperCase()}`, pageWidth / 2, headerY + 5.5, { align: 'center' });

  if (clientLogoBase64) {
    pdf.addImage(clientLogoBase64, 'PNG', MARGIN + 2, headerY + 9.5, cell1Width - 4, 9, undefined, 'FAST');
  }

  pdf.setFontSize(FONT_SIZES.small).setFont(undefined, 'normal');
  const titleText = 'INFORME VISITA INSPECCIÓN DEL SISTEMA DE ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES';
  pdf.text(titleText, MARGIN + cell1Width + (cell2Width / 2), headerY + 12.5, {
    maxWidth: cell2Width - 4,
    align: 'center',
    lineHeightFactor: 1.2
  });
  
  if (arselLogoBase64) {
    pdf.addImage(arselLogoBase64, 'PNG', MARGIN + cell1Width + cell2Width + 2, headerY + 9.5, cell3Width - 4, 9, undefined, 'FAST');
  }
} 
--- FIN DEL ARCHIVO: src\utils\pdf\pdf-helpers.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\pdf-module-checklist.js ---
// src/utils/pdf/pdf-module-checklist.js

import autoTable from 'jspdf-autotable';
import { checklistItems } from '../checklist';
import { MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

// Helper para determinar la gravedad máxima de un grupo de incidencias
function getHighestSeverity(incidencias) {
    if (incidencias.some(inc => inc.gravedad === 'rojo')) return 'rojo';
    if (incidencias.some(inc => inc.gravedad === 'ambar')) return 'ambar';
    if (incidencias.some(inc => inc.gravedad === 'verde')) return 'verde';
    return null;
}

export async function buildChecklistAnnex(pdf, reportData) {
    const { inspectionData, salasData, puntosMaestrosData, puntosInspeccionadosData, incidenciasData } = reportData;

    // --- INICIO DEL CAMBIO: Lógica de filtrado principal ---
    // 1. Si no hay ninguna incidencia en todo el informe, no generamos este anexo en absoluto.
    if (!incidenciasData || incidenciasData.length === 0) {
        return;
    }

    // 2. Creamos un conjunto (Set) para buscar eficientemente los IDs de los puntos maestros que SÍ tienen incidencias.
    const puntosInspeccionadosConIncidenciasIds = new Set(incidenciasData.map(inc => inc.punto_inspeccionado_id));
    const puntosMaestrosConIncidenciasIds = new Set(
        puntosInspeccionadosData
            .filter(pi => puntosInspeccionadosConIncidenciasIds.has(pi.id))
            .map(pi => pi.punto_maestro_id)
    );

    // 3. Si, por alguna razón, no encontramos puntos maestros correspondientes, salimos.
    if (puntosMaestrosConIncidenciasIds.size === 0) {
        return;
    }
    // --- FIN DEL CAMBIO ---

    // Solo si hemos pasado los filtros, creamos la página de portada del anexo.
    pdf.addPage();
    autoTable(pdf, {
        body: [['ANEXO 02:\nCHECKLIST']],
        startY: 145,
        theme: 'plain',
        styles: { 
            fontSize: FONT_SIZES.annexTitle, 
            fontStyle: 'bold', 
            halign: 'center' 
        },
        margin: { left: MARGIN, right: MARGIN }
    });

    for (const sala of salasData) {
        // --- INICIO DEL CAMBIO: Filtramos los puntos de la sala para incluir solo los que tienen incidencias ---
        const puntosDeLaSala = puntosMaestrosData
            .filter(pm => pm.sala_id === sala.id && puntosMaestrosConIncidenciasIds.has(pm.id))
            .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}));
        
        // Si en esta sala no hay ningún punto con incidencias, la saltamos por completo.
        if (puntosDeLaSala.length === 0) {
            continue;
        }
        // --- FIN DEL CAMBIO ---

        for (const puntoMaestro of puntosDeLaSala) {
            // Ya no necesitamos comprobar si hay incidencias aquí, porque el bucle solo itera sobre puntos que SÍ las tienen.
            pdf.addPage();

            autoTable(pdf, {
                body: [['FORMATO DE INSPECCIÓN DEL SISTEMA DE ALMACENAJE']],
                startY: 25,
                theme: 'plain',
                styles: { fontSize: FONT_SIZES.h2, fontStyle: 'bold', halign: 'center' },
                margin: { left: MARGIN, right: MARGIN }
            });

            autoTable(pdf, {
                body: [[
                    `HIPERMERCADO: ${inspectionData.centros.nombre.toUpperCase()}`,
                    `Reserva: ${sala.nombre.toUpperCase()}`,
                    `Alineación: ${puntoMaestro.nomenclatura.split('-').pop()}`
                ]],
                startY: pdf.lastAutoTable.finalY + 1,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.body, fontStyle: 'normal', lineColor: 0, lineWidth: 0.1 },
                headStyles: { fillColor: [255, 192, 0] },
                columnStyles: {
                    0: { cellWidth: 100 },
                    1: { cellWidth: 40 },
                    2: { cellWidth: 40, halign: 'left' }
                },
                margin: { left: MARGIN, right: MARGIN }
            });

            const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.punto_maestro_id === puntoMaestro.id);
            const puntoInspeccionadoId = puntoInspeccionado ? puntoInspeccionado.id : null;
            const head = [
                [{ content: 'Parámetro de control', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } },
                { content: 'S', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } },
                { content: 'I', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } }, 
                { content: 'N', rowSpan: 2, styles: { halign: 'center', valign: 'middle' } },
                { content: 'RIESGO', colSpan: 3, styles: { halign: 'center' } }],
                ['V', 'A', 'R']
            ];
            
            const body = checklistItems.map(item => {
                const itemIncidencias = incidenciasData.filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && inc.item_checklist === item.id);
                const tieneIncidencias = itemIncidencias.length > 0;
                const maxSeverity = tieneIncidencias ? getHighestSeverity(itemIncidencias) : null;
                
                return [
                    `${item.id}. ${item.text}`,
                    !tieneIncidencias ? 'X' : '',
                    tieneIncidencias ? 'X' : '',
                    '', // N/A
                    maxSeverity === 'verde' ? 'X' : '',
                    maxSeverity === 'ambar' ? 'X' : '',
                    maxSeverity === 'rojo' ? 'X' : '',
                ];
            });

            autoTable(pdf, {
                head, body, 
                startY: pdf.lastAutoTable.finalY, 
                margin: { left: MARGIN, right: MARGIN }, 
                theme: 'grid',
                headStyles: { fillColor: [255, 192, 0], textColor: 0, fontStyle: 'bold', halign: 'center', fontSize: 7, lineColor: 0, lineWidth: 0.1 },
                styles: { fontSize: 7, cellPadding: 1.5, overflow: 'linebreak', lineColor: 0, lineWidth: 0.1 },
                columnStyles: {
                    0: { cellWidth: 129 }, 1: { cellWidth: 7, halign: 'center' }, 2: { cellWidth: 7, halign: 'center' }, 3: { cellWidth: 7, halign: 'center' },
                    4: { cellWidth: 10, halign: 'center' }, 5: { cellWidth: 10, halign: 'center' }, 6: { cellWidth: 10, halign: 'center' },
                },
            });

            let finalY = pdf.lastAutoTable.finalY;

            const observacionesDelPunto = incidenciasData
                .filter(inc => inc.punto_inspeccionado_id === puntoInspeccionadoId && inc.observaciones && inc.observaciones.trim() !== '')
                .map((obs) => {
                    const itemIncidencias = incidenciasData.filter(i => i.punto_inspeccionado_id === puntoInspeccionadoId && i.item_checklist === obs.item_checklist);
                    const obsIndex = itemIncidencias.findIndex(i => i.id === obs.id);
                    const numTotal = itemIncidencias.length;
                    const countStr = numTotal > 1 ? ` (${obsIndex + 1}/${numTotal})` : '';

                    return `Parámetro ${obs.item_checklist}${countStr}: ${obs.observaciones}`;
                })
                .join('\n');
            
            autoTable(pdf, {
                body: [[{ content: `Observaciones:\n${observacionesDelPunto}`, styles: { fontStyle: 'bold', valign: 'top' } }]],
                startY: finalY,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 20 },
                margin: { left: MARGIN, right: MARGIN }
            });

            const fechaInspeccion = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
            autoTable(pdf, {
                body: [[
                    `Fecha revisión: ${fechaInspeccion}\n\nFirma de Arsel Ingenieria S.L.:`,
                    `Firma del PRSES:`
                ]],
                startY: pdf.lastAutoTable.finalY,
                theme: 'grid',
                styles: { fontSize: FONT_SIZES.small, lineColor: 0, lineWidth: 0.1, minCellHeight: 15, valign: 'top' },
                columnStyles: { 1: { halign: 'left' } },
                margin: { left: MARGIN, right: MARGIN }
            });

            autoTable(pdf, {
                body: [['S: Satisfactorio, I: Insatisfactorio, N: No aplica; V: Verde, A: Ámbar, R: Rojo']],
                startY: pdf.lastAutoTable.finalY,
                theme: 'plain',
                styles: { fontSize: 7, halign: 'left' },
                margin: { left: MARGIN, right: MARGIN }
            });
        }
    }
}
--- FIN DEL ARCHIVO: src\utils\pdf\pdf-module-checklist.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\pdf-module-photos.js ---
// src/utils/pdf/pdf-module-photos.js

import html2canvas from 'html2canvas'; // Asegúrate de tener html2canvas si no se usa
import { checklistItems } from '../checklist';
import { drawHeader, loadImageAsBase64, MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

// --- ANEXO DE FOTOS INICIAL (Sin cambios, lo dejamos como está) ---
export async function buildInitialPhotoAnnex(pdf, reportData) {
  // ... (Esta función se mantiene igual, no es necesario copiarla de nuevo si no ha cambiado)
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;
  
  const incidenciasConFoto = incidenciasData.filter(inc => 
    inc.url_foto_antes && inc.item_checklist !== 2
  );
  if (incidenciasConFoto.length === 0) return;

  const puntoMaestroASalaMap = new Map(puntosMaestrosData.map(pm => [pm.id, salasData.find(s => s.id === pm.sala_id)]));
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const getSortInfoForIncidencia = (inc) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(inc.punto_inspeccionado_id);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    return {
      salaNombre: sala ? sala.nombre : 'ZZZ',
      puntoNumero: puntoMaestro ? parseInt(puntoMaestro.nomenclatura.split('-').pop() || 0) : 9999
    };
  };

  incidenciasConFoto.sort((a, b) => {
    const infoA = getSortInfoForIncidencia(a);
    const infoB = getSortInfoForIncidencia(b);
    const comparacionSala = infoA.salaNombre.localeCompare(infoB.salaNombre);
    if (comparacionSala !== 0) return comparacionSala;
    return infoA.puntoNumero - infoB.puntoNumero;
  });

  pdf.addPage();
  await drawHeader(pdf, inspectionData);
  
  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont(undefined, 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  pdf.text('REPORTAJE FOTOGRÁFICO', DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont(undefined, 'normal');

  for (const incidencia of incidenciasConFoto) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;

    pdf.addPage();
    await drawHeader(pdf, inspectionData);
    
    let currentY = 45;
    pdf.setFontSize(FONT_SIZES.h2);
    pdf.text(`Alineación: ${puntoMaestro.nomenclatura}`, MARGIN, currentY);
    currentY += 8;

    const checklistItem = checklistItems.find(item => item.id === incidencia.item_checklist);
    if (checklistItem) {
      pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'italic');
      pdf.setTextColor(100);
      const itemText = `Incidencia: ${checklistItem.id}. ${checklistItem.text}`;
      const splitText = pdf.splitTextToSize(itemText, DOC_WIDTH - (MARGIN * 2));
      pdf.text(splitText, MARGIN, currentY);
      currentY += (splitText.length * 5) + 5;
      pdf.setTextColor(0);
      pdf.setFont(undefined, 'normal');
    }

    const fotoAntesBase64 = await loadImageAsBase64(incidencia.url_foto_antes);
    if(fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN, currentY, 180, 100, undefined, 'FAST');
    }

    let obsBlockY = currentY + 100 + 10;
    pdf.setFontSize(FONT_SIZES.body);
    const obsText = incidencia.observaciones || '';
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight);

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont(undefined, 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont(undefined, 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 10);
  }
}


// --- ANEXO DE FOTOS DE SUBSANACIÓN (MODIFICADO Y CORREGIDO) ---
export async function buildRemediationPhotoAnnex(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData } = reportData;
  
  // Filtramos solo las incidencias que tienen foto de ANTES y DESPUÉS
  const incidenciasSubsanadas = incidenciasData.filter(inc => inc.url_foto_antes && inc.url_foto_despues);
  if (incidenciasSubsanadas.length === 0) return;

  pdf.addPage();
  await drawHeader(pdf, inspectionData);

  pdf.setFontSize(FONT_SIZES.annexTitle);
  pdf.setFont(undefined, 'bold');
  pdf.text('ANEXO 01:', DOC_WIDTH / 2, 145, { align: 'center' });
  const remediationTitleLines = pdf.splitTextToSize('REPORTAJE FOTOGRÁFICO DE SUBSANACIÓN', 180);
  pdf.text(remediationTitleLines, DOC_WIDTH / 2, 155, { align: 'center' });
  pdf.setFont(undefined, 'normal');
  
  for (const incidencia of incidenciasSubsanadas) {
    const puntoInspeccionado = puntosInspeccionadosData.find(pi => pi.id === incidencia.punto_inspeccionado_id);
    const puntoMaestro = puntoInspeccionado ? puntosMaestrosData.find(pm => pm.id === puntoInspeccionado.punto_maestro_id) : null;
    if (!puntoMaestro) continue;
    
    pdf.addPage();
    await drawHeader(pdf, inspectionData);
    pdf.setFontSize(FONT_SIZES.h2).text(`Subsanación de Incidencia: ${puntoMaestro.nomenclatura}`, MARGIN, 45);

    // === INICIO DE LA CORRECCIÓN: Carga y dibuja las imágenes ===
    
    // 1. Cargar ambas imágenes en paralelo
    const [fotoAntesBase64, fotoDespuesBase64] = await Promise.all([
      loadImageAsBase64(incidencia.url_foto_antes),
      loadImageAsBase64(incidencia.url_foto_despues)
    ]);
    
    // Dimensiones y posiciones de los recuadros
    const photoBoxY = 65;
    const photoBoxSize = 85;
    const photoPadding = 2; // Pequeño margen interno

    // Dibuja el recuadro y la foto de "ANTES"
    pdf.text('ANTES', MARGIN + (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(MARGIN, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoAntesBase64) {
      pdf.addImage(fotoAntesBase64, 'JPEG', MARGIN + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'FAST');
    }
    
    // Dibuja el recuadro y la foto de "DESPUÉS"
    pdf.text('DESPUÉS', DOC_WIDTH - MARGIN - (photoBoxSize / 2), 60, { align: 'center' });
    pdf.rect(DOC_WIDTH / 2 + 5, photoBoxY, photoBoxSize, photoBoxSize);
    if (fotoDespuesBase64) {
      pdf.addImage(fotoDespuesBase64, 'JPEG', (DOC_WIDTH / 2 + 5) + photoPadding, photoBoxY + photoPadding, photoBoxSize - (photoPadding * 2), photoBoxSize - (photoPadding * 2), undefined, 'FAST');
    }
    
    // === FIN DE LA CORRECCIÓN ===
    
    let obsBlockY = 160;
    pdf.setFontSize(FONT_SIZES.body);
    const obsText = incidencia.observaciones || '';
    const splitObs = pdf.splitTextToSize(obsText, DOC_WIDTH - (MARGIN * 2) - 4);
    const requiredTextHeight = splitObs.length * 5;
    const minBoxHeight = 20;
    const headerHeight = 8;
    const boxHeight = Math.max(minBoxHeight, requiredTextHeight + headerHeight);

    pdf.setDrawColor(0);
    pdf.rect(MARGIN, obsBlockY, DOC_WIDTH - (MARGIN * 2), boxHeight);
    pdf.setFont(undefined, 'bold');
    pdf.text('Observaciones:', MARGIN + 2, obsBlockY + 5);
    pdf.setFont(undefined, 'normal');
    pdf.text(splitObs, MARGIN + 2, obsBlockY + 10);
  }
}
--- FIN DEL ARCHIVO: src\utils\pdf\pdf-module-photos.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\pdf-module-summary.js ---
// src/utils/pdf/pdf-module-summary.js

import { drawHeader, MARGIN } from './pdf-helpers';

// --- (No hay cambios en esta función de posicionamiento, sigue siendo la correcta) ---
function findNonOverlappingPosition(point, badgeSize, obstacles, pageBounds) {
    const isOverlapping = (rect1, rect2) => {
        const margin = 2; 
        return !(rect1.x > rect2.x + rect2.width + margin ||
                 rect1.x + rect1.width + margin < rect2.x ||
                 rect1.y > rect2.y + rect2.height + margin ||
                 rect1.y + rect1.height + margin < rect2.y);
    };

    const isWithinBounds = (rect) => {
        return rect.x >= pageBounds.x &&
               rect.y >= pageBounds.y &&
               rect.x + rect.width <= pageBounds.x + pageBounds.width &&
               rect.y + rect.height <= pageBounds.y + pageBounds.height;
    };

    const checkPosition = (pos) => {
        const candidateRect = {
            x: pos.x - badgeSize.width / 2,
            y: pos.y - badgeSize.height / 2,
            width: badgeSize.width,
            height: badgeSize.height
        };
        if (isWithinBounds(candidateRect) && !obstacles.some(obs => isOverlapping(candidateRect, obs))) {
            return pos;
        }
        return null;
    };

    const preferredOffsets = [
        { x: 0, y: -(badgeSize.height / 2 + 8) }, { x: 0, y: (badgeSize.height / 2 + 8) },
        { x: (badgeSize.width / 2 + 8), y: 0 },   { x: -(badgeSize.width / 2 + 8), y: 0 },
        { x: 15, y: -15 }, { x: -15, y: -15 }, { x: 15, y: 15 }, { x: -15, y: 15 }
    ];

    for (const offset of preferredOffsets) {
        const position = checkPosition({ x: point.absX + offset.x, y: point.absY + offset.y });
        if (position) return position;
    }

    let x = point.absX;
    let y = point.absY;
    let dx = 0;
    let dy = -1;
    let stepSize = 5; 
    let stepsInSegment = 1;
    let turnCounter = 0;

    for (let i = 0; i < 5000; i++) {
        for (let j = 0; j < Math.floor(stepsInSegment); j++) {
            x += dx * stepSize;
            y += dy * stepSize;
            const position = checkPosition({ x, y });
            if (position) return position;
        }
        [dx, dy] = [-dy, dx];
        turnCounter++;
        if (turnCounter % 2 === 0) {
            stepsInSegment += 1;
        }
    }

    console.warn("El algoritmo en espiral no encontró una posición. Colocando en la posición por defecto.");
    return { x: point.absX, y: point.absY - 25 };
}


function drawSalaPolygons(pdf, salas, planoX, planoY, planoW, planoH) {
    // (Esta función no necesita cambios)
    for (const sala of salas) {
        if (sala.area_puntos && sala.area_puntos.length > 2) {
            const rgb = ((hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
            })(sala.color);
            if (rgb) {
                pdf.setDrawColor(rgb[0], rgb[1], rgb[2]);
                pdf.setLineWidth(0.8);
                const absolutePoints = sala.area_puntos.map(p => ({ x: planoX + (p.x * planoW), y: planoY + (p.y * planoH) }));
                for (let i = 0; i < absolutePoints.length; i++) {
                    const p1 = absolutePoints[i];
                    const p2 = absolutePoints[(i + 1) % absolutePoints.length];
                    pdf.line(p1.x, p1.y, p2.x, p2.y);
                }
            }
        }
    }
}

// --- MEJORA 3: CÍRCULO DE ANCLAJE EN EL MAPA ---
function drawPointNumberOnMap(pdf, point) {
    const pointNumber = (point.nomenclatura && typeof point.nomenclatura === 'string')
        ? point.nomenclatura.split('-').pop() || '?'
        : '?';

    // Parsear el color de la sala para el borde
    const salaColorRGB = ((hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [128, 128, 128];
    })(point.salaColor);

    pdf.setFontSize(7).setFont(undefined, 'bold');
    pdf.setTextColor(salaColorRGB[0], salaColorRGB[1], salaColorRGB[2]);
    
    const textWidth = pdf.getStringUnitWidth(pointNumber) * 7 / pdf.internal.scaleFactor;
    const circleRadius = textWidth / 2 + 1.5; // Radio del círculo

    // Dibuja el círculo con borde y fondo blanco
    pdf.setFillColor(255, 255, 255);
    pdf.setDrawColor(salaColorRGB[0], salaColorRGB[1], salaColorRGB[2]);
    pdf.setLineWidth(0.4);
    pdf.circle(point.absX, point.absY, circleRadius, 'FD'); // FD = Fill and Draw (Stroke)
    
    // Dibuja el número en el centro
    pdf.text(pointNumber, point.absX, point.absY, { align: 'center', baseline: 'middle' });
}
// --- FIN DE MEJORA 3 ---


// --- MEJORA 1: NÚMERO DEL PUNTO EN LA TARJETA ---
function drawInfoBadge(pdf, position, point) {
    const FONT_SIZE_STATE = 5.5;
    const FONT_SIZE_SEMAPHORE = 6;
    const FONT_SIZE_PUNTO = 7;
    const PADDING_V = 1.2;
    const BADGE_WIDTH = 14; // Un poco más ancha para el número

    // Extraer el número del punto
    const pointNumber = point.nomenclatura.split('-').pop() || '?';

    let stateText = null;
    if (point.estado === 'nuevo') stateText = 'NUEVA';
    else if (point.estado === 'suprimido') stateText = 'SUPRIMIDA';
    else if (point.detalle_modificacion === 'aumentado') stateText = 'AUMENTADA';
    else if (point.detalle_modificacion === 'disminuido') stateText = 'DISMINUIDA';

    // Calcular altura dinámicamente
    const pointNumberHeight = FONT_SIZE_PUNTO + PADDING_V + 1; // +1 para la línea separadora
    const stateTextHeight = stateText ? FONT_SIZE_STATE + PADDING_V : 0;
    const semaphoreHeight = 3 * 4;
    const badgeHeight = pointNumberHeight + stateTextHeight + semaphoreHeight + (PADDING_V * 2);
    
    const startX = position.x - (BADGE_WIDTH / 2);
    let currentY = position.y - (badgeHeight / 2);

    // Dibuja el cuerpo del badge
    pdf.setFillColor(255, 255, 255);
    pdf.setDrawColor(150, 150, 150); // Borde un poco más oscuro
    pdf.setLineWidth(0.3);
    pdf.roundedRect(startX, currentY, BADGE_WIDTH, badgeHeight, 2, 2, 'FD');

    // Sección del Número del Punto
    currentY += PADDING_V + (FONT_SIZE_PUNTO / 2);
    pdf.setFontSize(FONT_SIZE_PUNTO).setFont(undefined, 'bold');
    pdf.setTextColor(50, 50, 50);
    pdf.text(`Punto ${pointNumber}`, position.x, currentY + 1, { align: 'center' });
    currentY += (FONT_SIZE_PUNTO / 2) + PADDING_V;
    pdf.setDrawColor(220, 220, 220);
    pdf.line(startX + 1, currentY, startX + BADGE_WIDTH - 1, currentY);
    currentY += 1;

    // Sección de Estado (si aplica)
    if (stateText) {
        currentY += PADDING_V;
        pdf.setFontSize(FONT_SIZE_STATE).setFont(undefined, 'bold');
        pdf.setTextColor(80, 80, 80);
        pdf.text(stateText, position.x, currentY + stateTextHeight / 2 - 0.2, { align: 'center', baseline: 'middle' });
        currentY += stateTextHeight;
    }

    // Sección del Semáforo
    const items = [
        { color: [34, 197, 94], count: point.counts.verde },
        { color: [245, 158, 11], count: point.counts.ambar },
        { color: [239, 68, 68], count: point.counts.rojo },
    ];

    items.forEach(item => {
        const itemCenterY = currentY + 4 / 2;
        pdf.setFillColor(item.color[0], item.color[1], item.color[2]);
        pdf.circle(startX + 4, itemCenterY, 1.5, 'F'); // Círculos en lugar de cuadrados
        pdf.setTextColor(80, 80, 80);
        pdf.setFontSize(FONT_SIZE_SEMAPHORE).setFont(undefined, 'normal');
        pdf.text(String(item.count), startX + BADGE_WIDTH - 4, itemCenterY, { align: 'center', baseline: 'middle' });
        currentY += 4;
    });
    
    return { x: startX, y: position.y - (badgeHeight/2), width: BADGE_WIDTH, height: badgeHeight };
}
// --- FIN DE MEJORA 1 ---


// --- MEJORA 2: LÍNEAS GUÍA MÁS ELEGANTES ---
function drawLeaderLine(pdf, from, to, badgeRect) {
    // Usar línea sólida, fina y gris
    pdf.setDrawColor(180, 180, 180);
    pdf.setLineWidth(0.2);
    // Quitar el patrón de guiones: pdf.setLineDashPattern([1, 1], 0);

    const badgeCenterX = badgeRect.x + badgeRect.width / 2;
    const badgeCenterY = badgeRect.y + badgeRect.height / 2;
    
    // Lógica para conectar al borde más cercano del badge
    const dx = from.x - badgeCenterX;
    const dy = from.y - badgeCenterY;
    const halfW = badgeRect.width / 2;
    const halfH = badgeRect.height / 2;
    
    let targetX, targetY;
    const slopeY = halfW * (dy / dx);
    const slopeX = halfH * (dx / dy);

    if (Math.abs(dy) <= halfH) { // Intersecta con lados verticales
      targetX = dx > 0 ? badgeRect.x + badgeRect.width : badgeRect.x;
      targetY = badgeCenterY + slopeY;
    } else { // Intersecta con lados horizontales
      targetY = dy > 0 ? badgeRect.y + badgeRect.height : badgeRect.y;
      targetX = badgeCenterX + slopeX;
    }

    pdf.line(from.x, from.y, targetX, targetY);
}
// --- FIN DE MEJORA 2 ---


export async function buildSummaryAnnex(pdf, reportData) {
    const { salasData, puntosInspeccionadosData, puntosMaestrosData, planoBase64, incidenceCounts } = reportData;

    const PAGE_WIDTH = pdf.internal.pageSize.getWidth();
    const PAGE_HEIGHT = pdf.internal.pageSize.getHeight();
    const HEADER_HEIGHT = 15;
    const MARGIN_V = 10;
    
    const pageBounds = {
        x: MARGIN,
        y: HEADER_HEIGHT,
        width: PAGE_WIDTH - MARGIN * 2,
        height: PAGE_HEIGHT - HEADER_HEIGHT - MARGIN_V
    };

    const imgProps = pdf.getImageProperties(planoBase64);
    const canvasAspectRatio = pageBounds.width / pageBounds.height;
    const imageAspectRatio = imgProps.width / imgProps.height;

    let imgWidth, imgHeight;
    if (imageAspectRatio > canvasAspectRatio) {
        imgWidth = pageBounds.width;
        imgHeight = imgWidth / imageAspectRatio;
    } else {
        imgHeight = pageBounds.height;
        imgWidth = imgHeight * imageAspectRatio;
    }

    const planoStartX = (PAGE_WIDTH - imgWidth) / 2;
    const planoStartY = HEADER_HEIGHT + (pageBounds.height - imgHeight) / 2;

    pdf.addImage(planoBase64, 'JPEG', planoStartX, planoStartY, imgWidth, imgHeight);
    drawSalaPolygons(pdf, salasData, planoStartX, planoStartY, imgWidth, imgHeight);

    const puntoMaestroMap = new Map(puntosMaestrosData.map(pm => [pm.id, pm]));
    const salaMap = new Map(salasData.map(s => [s.id, s]));

    const allPoints = puntosInspeccionadosData.map(punto => {
        const puntoMaestro = puntoMaestroMap.get(punto.punto_maestro_id);
        if (!puntoMaestro) return null;
        const sala = salaMap.get(puntoMaestro.sala_id);
        const salaColor = sala ? sala.color : '#808080';
        const absX = planoStartX + (punto.coordenada_x * imgWidth);
        const absY = planoStartY + (punto.coordenada_y * imgHeight);
        const counts = incidenceCounts.get(punto.id) || { verde: 0, ambar: 0, rojo: 0 };
        return { ...punto, nomenclatura: puntoMaestro.nomenclatura, sala, salaColor, absX, absY, counts };
    }).filter(Boolean);
    
    const placedObstacles = allPoints.map(p => ({ x: p.absX - 5, y: p.absY - 5, width: 10, height: 10 })); // Usar el círculo de anclaje como obstáculo
    const labelsToDraw = [];
    
    const mapCenterX = planoStartX + imgWidth / 2;
    const mapCenterY = planoStartY + imgHeight / 2;
    allPoints.sort((a, b) => {
        const distA = Math.sqrt(Math.pow(a.absX - mapCenterX, 2) + Math.pow(a.absY - mapCenterY, 2));
        const distB = Math.sqrt(Math.pow(b.absX - mapCenterX, 2) + Math.pow(b.absY - mapCenterY, 2));
        return distA - distB;
    });

    for (const point of allPoints) {
        const needsBadge = point.estado !== 'existente' || point.detalle_modificacion !== null ||
            (point.counts.verde > 0 || point.counts.ambar > 0 || point.counts.rojo > 0);

        if (!needsBadge) continue;
        
        // --- (Código actualizado para calcular el tamaño del badge) ---
        let badgeHeight = (1.2 * 2) + (4 * 3) + (7 + 1.2 + 1);
        if (point.estado !== 'existente' || point.detalle_modificacion !== null) {
            badgeHeight += 5.5 + 1.2;
        }
        const badgeSize = { width: 14, height: badgeHeight };
        
        const finalPosition = findNonOverlappingPosition(point, badgeSize, placedObstacles, pageBounds);

        const badgeRect = {
            x: finalPosition.x - badgeSize.width / 2,
            y: finalPosition.y - badgeSize.height / 2,
            ...badgeSize
        };
        
        placedObstacles.push(badgeRect);
        labelsToDraw.push({ point, position: finalPosition, finalBadgeRect: badgeRect });
    }

    // Dibujar primero todos los números/anclajes de los puntos
    allPoints.forEach(point => drawPointNumberOnMap(pdf, point));
    
    // Luego, dibujar los badges y sus líneas guía
    labelsToDraw.forEach(({point, position, finalBadgeRect}) => {
        drawInfoBadge(pdf, position, point);
        drawLeaderLine(pdf, {x: point.absX, y: point.absY}, position, finalBadgeRect);
    });
}
--- FIN DEL ARCHIVO: src\utils\pdf\pdf-module-summary.js ---

--- INICIO DEL ARCHIVO: src\utils\pdf\pdf-module-text.js ---
// src/utils/pdf/pdf-module-text.js

import { drawHeader, loadImageAsBase64, ARSEL_LOGO_URL } from './pdf-helpers';
import { MARGIN, DOC_WIDTH, FONT_SIZES } from './pdf-helpers';

export async function buildTextPages(pdf, reportData) {
  const { inspectionData, incidenciasData, puntosMaestrosData, puntosInspeccionadosData, salasData } = reportData;

  const fecha = new Date(inspectionData.fecha_inspeccion).toLocaleDateString('es-ES');
  const puntoMaestroASalaMap = new Map();
  puntosMaestrosData.forEach(pm => {
    const sala = salasData.find(s => s.id === pm.sala_id);
    if (sala) puntoMaestroASalaMap.set(pm.id, sala);
  });
  const puntoInspeccionadoAMaestroMap = new Map(puntosInspeccionadosData.map(pi => [pi.id, pi.punto_maestro_id]));
  
  const agruparPuntosPorPropiedad = (propiedad, valor) => {
    const puntosFiltrados = puntosInspeccionadosData.filter(pi => pi[propiedad] === valor);
    const grupos = {};
    puntosFiltrados.forEach(pi => {
      const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
      if (sala) {
        if (!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
        grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
      }
    });
    return Object.keys(grupos).sort().map(nombreSala =>
      `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
    ).join('\n');
  };

  const agruparPuntosConPlacaPorSala = () => {
      const puntosConPlaca = puntosInspeccionadosData.filter(pi => 
          pi.tiene_placa_caracteristicas === true &&
          pi.detalle_modificacion !== 'aumentado' &&
          pi.detalle_modificacion !== 'disminuido' &&
          pi.estado === 'existente'
      );
      const grupos = {};
      puntosConPlaca.forEach(pi => {
          const sala = puntoMaestroASalaMap.get(pi.punto_maestro_id);
          if(sala) {
              if(!grupos[sala.nombre]) grupos[sala.nombre] = new Set();
              grupos[sala.nombre].add(pi.nomenclatura.split('-').pop());
          }
      });
      return Object.keys(grupos).sort().map(nombreSala => 
        `${nombreSala.toUpperCase()}: ${[...grupos[nombreSala]].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`
      ).join('\n');
  };

  const lineasSuprimidas = agruparPuntosPorPropiedad('estado', 'suprimido');
  const lineasNuevas = agruparPuntosPorPropiedad('estado', 'nuevo');
  const lineasAumentadas = agruparPuntosPorPropiedad('detalle_modificacion', 'aumentado');
  const lineasDisminuidas = agruparPuntosPorPropiedad('detalle_modificacion', 'disminuido');
  const lineasConPlaca = agruparPuntosConPlacaPorSala();
  
  const getSalaYNumeroDeIncidencia = (incidencia) => {
    const puntoMaestroId = puntoInspeccionadoAMaestroMap.get(incidencia.punto_inspeccionado_id);
    if (!puntoMaestroId) return null;
    const sala = puntoMaestroASalaMap.get(puntoMaestroId);
    const puntoMaestro = puntosMaestrosData.find(pm => pm.id === puntoMaestroId);
    if (!sala || !puntoMaestro) return null;
    return { nombreSala: sala.nombre, numeroPunto: puntoMaestro.nomenclatura.split('-').pop() };
  };

  const agruparIncidenciasPorSala = (incidencias) => {
    const grupos = {};
    incidencias.forEach(inc => {
      const info = getSalaYNumeroDeIncidencia(inc);
      if (info) {
        if (!grupos[info.nombreSala]) grupos[info.nombreSala] = new Set();
        grupos[info.nombreSala].add(info.numeroPunto);
      }
    });
    const nombresDeSalasOrdenados = Object.keys(grupos).sort((a, b) => a.localeCompare(b));
    if (nombresDeSalasOrdenados.length === 1 && nombresDeSalasOrdenados[0].toLowerCase() === 'única') {
        const numerosSet = grupos[nombresDeSalasOrdenados[0]];
        return `Única: ${[...numerosSet].sort((a, b) => parseInt(a) - parseInt(b)).join(', ')}`;
    }
    return nombresDeSalasOrdenados.map(nombreSala => {
      const numerosSet = grupos[nombreSala];
      const numerosOrdenados = [...numerosSet].sort((a, b) => parseInt(a) - parseInt(b)).join(', ');
      return `${nombreSala}: ${numerosOrdenados}`;
    }).join('\n');
  };

  const incidenciasVerdeAmbarReales = incidenciasData.filter(i => i.gravedad === 'verde' || i.gravedad === 'ambar');
  const puntosModificados = puntosInspeccionadosData.filter(pi => pi.estado === 'nuevo' || pi.estado === 'suprimido');
  const puntosYaIncluidosIds = new Set(incidenciasVerdeAmbarReales.map(i => i.punto_inspeccionado_id));
  const incidenciasSinteticas = puntosModificados
    .filter(pi => !puntosYaIncluidosIds.has(pi.id))
    .map(pi => ({ punto_inspeccionado_id: pi.id }));
  const incidenciasVerdeAmbarCombinadas = [...incidenciasVerdeAmbarReales, ...incidenciasSinteticas];
  const textoVerdeAmbar = agruparIncidenciasPorSala(incidenciasVerdeAmbarCombinadas);
  const incidenciasRojo = incidenciasData.filter(i => i.gravedad === 'rojo');
  const textoRojo = agruparIncidenciasPorSala(incidenciasRojo);

  // --- PÁGINA 1 ---
  await drawHeader(pdf, inspectionData);
  let currentY = 50;
  
  const titulo = `INFORME VISITA INSPECCIÓN DEL SISTEMA DE ALMACENAJE PARA CARGAS PALETIZADAS Y MANUALES DEL Hipermercado ${inspectionData.centros.nombre.toUpperCase()}`;
  pdf.setFontSize(FONT_SIZES.h2).setFont(undefined, 'bold');
  const tituloLines = pdf.splitTextToSize(titulo, DOC_WIDTH - (MARGIN * 2));
  pdf.text(tituloLines, DOC_WIDTH / 2, currentY, { align: 'center' });
  currentY += (tituloLines.length * 7) + 15;

  pdf.setFontSize(FONT_SIZES.h2).setFont(undefined, 'bold'); pdf.text('1. OBJETO', MARGIN, currentY); currentY += 8; pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal'); pdf.text(`Con motivo de la visita programada para la inspección del sistema de almacenaje para cargas paletizadas y manuales del ${inspectionData.centros.nombre}, se redacta el presente informe que recoge de forma somera el resultado de la visita.`, MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 25;
  pdf.setFontSize(FONT_SIZES.h2).setFont(undefined, 'bold'); pdf.text('2. ANTECEDENTES', MARGIN, currentY); currentY += 8; pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal'); pdf.text('Para realizar la inspección del sistema de almacenaje de cargas paletizadas y manuales ubicadas en las reservas se toma como base la memoria técnica previa de evaluación de dichos sistemas facilitada al centro para la realización de las correcciones oportunas. Este documento establece los parámetros dimensionales y de carga, así como los elementos y medidas de seguridad que deben contemplar los sistemas de almacenaje para garantizar su estabilidad y uso seguro.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 40; pdf.text('La inspección consiste en la revisión visual del sistema llevada a cabo por un técnico cualificado, con la comprobación de los puntos recogidos en el checklist previsto para tal fin en la memoria de evaluación previa, con el consiguiente registro escrito de los resultados obtenidos.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 30;
  pdf.setFontSize(FONT_SIZES.h2).setFont(undefined, 'bold'); pdf.text('3. RESULTADO DE LA VISITA', MARGIN, currentY); currentY += 8; pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal'); pdf.text('En rasgos generales los sistemas de almacenaje cumplen los parámetros establecidos en la memoria técnica de evaluación.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 15; pdf.text('Se han detectado anomalías de riesgo verde y/o ámbar, tal y como se refleja en los listados de inspección elaborados durante la visita en:', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 });
  
  // --- PÁGINA 2 ---
  pdf.addPage();
  await drawHeader(pdf, inspectionData);
  currentY = 50;
  
  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'bold');
  if (textoVerdeAmbar) { pdf.text(textoVerdeAmbar, MARGIN, currentY, { lineHeightFactor: 1.5 }); currentY += (textoVerdeAmbar.split('\n').length * 5) + 5; }
  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal'); currentY = Math.max(currentY, 65); pdf.text('Estas anomalías, si bien no comprometen de forma inmediata la estabilidad ni seguridad del sistema, deben subsanarse lo antes posible para evitar que puedan derivar en un riesgo mayor. (Se adjuntan listados de chequeo y reportaje fotográfico de la visita).', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 30;
  pdf.text('Puntualmente, se han detectado anomalías de riesgo rojo en:', MARGIN, currentY); currentY += 8;
  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'bold');
  if (textoRojo) { pdf.text(textoRojo, MARGIN, currentY, { lineHeightFactor: 1.5 }); currentY += (textoRojo.split('\n').length * 5) + 5; }
  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal'); currentY = Math.max(currentY, 130); const textoRiesgoRojo = 'Estas anomalías deben subsanarse inmediatamente para evitar el colapso de las estanterías en el caso de una combinación de cargas desfavorables, procediendo a la descarga de la mercancía de los módulos afectados y señalizando la zona para que no se almacene producto en los mismos hasta que puedan ser sustituidos los elementos dañados. La sustitución se llevará a cabo con nuevo material que se tiene que solicitar si no cuenta con repuesto en el centro.'; const textLines = pdf.splitTextToSize(textoRiesgoRojo, DOC_WIDTH - (MARGIN * 2)); pdf.text(textLines, MARGIN, currentY, { lineHeightFactor: 1.5 }); currentY += textLines.length * 5 + 15;

  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal');
  pdf.text('Alineaciones que disponen de sus fichas de características:', MARGIN, currentY);
  currentY += 8;
  pdf.setFont(undefined, 'bold');
  if (lineasConPlaca) {
    pdf.text(lineasConPlaca, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (lineasConPlaca.split('\n').length * 5) + 5;
  } else {
    pdf.text('Ninguna', MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += 10;
  }
  currentY += 5;

  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal');
  pdf.text('Alineaciones con módulos AUMENTADOS desde la inspección anterior:', MARGIN, currentY);
  currentY += 8;
  pdf.setFont(undefined, 'bold');
  if (lineasAumentadas) {
    pdf.text(lineasAumentadas, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (lineasAumentadas.split('\n').length * 5) + 5;
  } else {
    pdf.text('Ninguna', MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += 10;
  }
  currentY += 5;

  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal');
  pdf.text('Alineaciones con módulos DISMINUIDOS desde la inspección anterior:', MARGIN, currentY);
  currentY += 8;
  pdf.setFont(undefined, 'bold');
  if (lineasDisminuidas) {
    pdf.text(lineasDisminuidas, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (lineasDisminuidas.split('\n').length * 5) + 5;
  } else {
    pdf.text('Ninguna', MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += 10;
  }
  currentY += 5;

  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal');
  pdf.text('Alineaciones desmontadas desde la inspección anterior:', MARGIN, currentY);
  currentY += 8;
  pdf.setFont(undefined, 'bold');
  if (lineasSuprimidas) {
    pdf.text(lineasSuprimidas, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += (lineasSuprimidas.split('\n').length * 5) + 5;
  } else {
    pdf.text('Ninguna', MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
    currentY += 10;
  }
  currentY += 5;

  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal');
  pdf.text('Alineaciones nuevas montadas desde la inspección anterior:', MARGIN, currentY);
  currentY += 8;
  pdf.setFont(undefined, 'bold');
  if (lineasNuevas) {
    pdf.text(lineasNuevas, MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
  } else {
    pdf.text('Ninguna', MARGIN + 5, currentY, { lineHeightFactor: 1.5 });
  }

  // --- PÁGINA 3 ---
  pdf.addPage();
  await drawHeader(pdf, inspectionData);
  currentY = 50;
  pdf.setFontSize(FONT_SIZES.body).setFont(undefined, 'normal');
  pdf.text('Para cerrar el proceso de inspección completo, el centro subsanará las deficiencias de menor grado detectadas en los próximos días, comunicando la resolución de las mismas mediante correo electrónico a ARSEL Ingeniería y al Técnico de Prevención Regional.', MARGIN, currentY, { maxWidth: DOC_WIDTH - (MARGIN * 2), lineHeightFactor: 1.5 }); currentY += 40;
  pdf.text('Informe realizado por:', MARGIN, currentY); currentY += 15;
  const arselLogoBase64 = await loadImageAsBase64(ARSEL_LOGO_URL);
  if (arselLogoBase64) {
      pdf.addImage(arselLogoBase64, 'PNG', MARGIN, currentY, 35, 15, undefined, 'FAST');
      currentY += 18;
  }
  pdf.setFont(undefined, 'bold');
  pdf.text('ARSEL INGENIERIA', MARGIN, currentY);
  currentY += 5;
  pdf.setFont(undefined, 'normal');
  pdf.text(`Valencia, ${fecha}`, MARGIN, currentY);
}
--- FIN DEL ARCHIVO: src\utils\pdf\pdf-module-text.js ---

--- INICIO DEL ARCHIVO: src\views\CentroConfigView.vue ---
<!-- src/views/CentroConfigView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import { ArrowPathIcon, ArrowUpTrayIcon, PlusIcon, TrashIcon, MapIcon, XCircleIcon, PencilIcon, CheckCircleIcon, InformationCircleIcon, BackspaceIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const versionId = route.params.id;

const loading = ref(true);
const version = ref(null);
const centro = ref(null);
const puntos = ref([]);
const salas = ref([]);
const activeSalaId = ref(null);
const newSalaName = ref('');
const fileInput = ref(null);

// --- INICIO DE CAMBIOS: Nuevos estados de edición ---
const isDrawingMode = ref(false);
const isPointEditingMode = ref(false);
const activeSala = computed(() => salas.value.find(s => s.id === activeSalaId.value));

const instructionText = computed(() => {
    if (isDrawingMode.value) {
        const salaName = activeSala.value?.nombre || 'la sala';
        return `Definiendo área para "${salaName}": Haz clic para añadir puntos. Haz clic en el primer punto para cerrar la forma.`;
    }
    if (isPointEditingMode.value) {
        const salaName = activeSala.value?.nombre || 'NINGUNA';
        return `Modo Edición de Puntos: Haz clic en el plano para añadir puntos en la sala "${salaName.toUpperCase()}".`;
    }
    return null;
});
// --- FIN DE CAMBIOS ---

onMounted(async () => {
  loading.value = true;
  const { data: versionData } = await supabase.from('versiones_plano').select('*, centros(*)').eq('id', versionId).single();
  if (!versionData) {
    alert("Error: No se pudo cargar la versión del plano o no existe.");
    loading.value = false; return;
  }
  version.value = versionData;
  centro.value = versionData.centros;
  const [salasRes, puntosRes] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', versionId).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', versionId)
  ]);
  salas.value = salasRes.data || [];
  puntos.value = puntosRes.data || [];
  if (salas.value.length > 0 && !activeSalaId.value) {
      activeSalaId.value = salas.value[0].id;
  }
  loading.value = false;
});

const togglePointEditingMode = () => {
    if (!isPointEditingMode.value && !activeSalaId.value) {
        alert('Por favor, selecciona primero una sala para empezar a editar sus puntos.');
        return;
    }
    isPointEditingMode.value = !isPointEditingMode.value;
    isDrawingMode.value = false; // Asegurarse de que el otro modo está desactivado
};

const cancelAllModes = () => {
    isDrawingMode.value = false;
    isPointEditingMode.value = false;
};

const onFileSelected = (event) => {
    const file = event.target.files[0];
    if (file) handleFileUpload(file);
};
const handleFileUpload = async (file) => {
    if (!version.value) return;
    const fileName = `planos/${centro.value.id}/version_${version.value.id}_${Date.now()}_${file.name}`;
    const { error: uploadError } = await supabase.storage.from('planos-centros').upload(fileName, file);
    if (uploadError) { alert("Error al subir el plano: " + uploadError.message); return; }
    const { data: { publicUrl } } = supabase.storage.from('planos-centros').getPublicUrl(fileName);
    const { error: updateError } = await supabase.from('versiones_plano').update({ url_imagen_plano: publicUrl }).eq('id', version.value.id);
    if (updateError) { alert("Error al guardar la URL del plano: " + updateError.message); } 
    else {
        version.value.url_imagen_plano = publicUrl;
        alert("Plano actualizado correctamente.");
    }
};

// --- INICIO DE CAMBIOS: Lógica de dibujo y guardado ---
const enterDrawingMode = () => {
  if (!activeSalaId.value) { alert("Selecciona una sala para poder definir su área."); return; }
  isDrawingMode.value = true;
  isPointEditingMode.value = false;
};

const handleAreaDrawn = async (points) => {
  isDrawingMode.value = false;
  const { error } = await supabase.from('salas').update({ area_puntos: points }).eq('id', activeSalaId.value);
  if (error) { 
    alert("Error al guardar el área: " + error.message); 
  } else {
    const salaIndex = salas.value.findIndex(s => s.id === activeSalaId.value);
    if (salaIndex !== -1) { 
      salas.value[salaIndex].area_puntos = points;
    }
  }
};

const clearArea = async () => {
    if (!activeSalaId.value || !confirm("¿Estás seguro de que quieres borrar el área dibujada para esta sala?")) return;
    const { error } = await supabase.from('salas').update({ area_puntos: null }).eq('id', activeSalaId.value);
    if (error) {
        alert("Error al limpiar el área: " + error.message);
    } else {
        const salaIndex = salas.value.findIndex(s => s.id === activeSalaId.value);
        if (salaIndex !== -1) {
            salas.value[salaIndex].area_puntos = null;
        }
    }
};
// --- FIN DE CAMBIOS ---

const handleNewPoint = async (coords) => {
  if (!activeSalaId.value) { alert("Error: No se ha seleccionado ninguna sala para añadir el punto."); return; };
  const sala = salas.value.find(s => s.id === activeSalaId.value);
  if (!sala) { alert("Error: La sala seleccionada no es válida."); return; }
  
  const puntosDeLaSala = puntos.value.filter(p => p.sala_id === activeSalaId.value);
  const existingNumbers = puntosDeLaSala.map(p => {
    const match = p.nomenclatura.match(/-(\d+)$/);
    return match ? parseInt(match[1], 10) : 0;
  });
  const maxNumber = Math.max(0, ...existingNumbers);
  const newNomenclature = `${sala.nombre}-${maxNumber + 1}`;

  const { data, error } = await supabase.from('puntos_maestros').insert({ 
    version_id: versionId, 
    sala_id: activeSalaId.value, 
    nomenclatura: newNomenclature, 
    coordenada_x: coords.x, 
    coordenada_y: coords.y
  }).select().single();
  
  if (data) {
    puntos.value.push(data);
  } else if (error) {
    alert(error.message);
  }
};

const handleDeletePoint = async (point) => {
    if (confirm(`¿Estás seguro de que quieres borrar el punto "${point.nomenclatura}" de este plano?`)) {
        const { error } = await supabase.from('puntos_maestros').delete().eq('id', point.id);
        if (error) {
            alert('Error al borrar el punto: ' + error.message);
        } else {
            puntos.value = puntos.value.filter(p => p.id !== point.id);
        }
    }
};

const addSala = async () => {
  if (!newSalaName.value.trim()) return;
  const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
  const { data, error } = await supabase.from('salas').insert({ version_id: versionId, nombre: newSalaName.value.trim(), color: randomColor }).select().single();
  if (data) { salas.value.push(data); activeSalaId.value = data.id; newSalaName.value = ''; } 
  else if (error) { alert("Error al crear la sala: " + error.message); }
};

const deleteSala = async (salaId) => {
  if (confirm('¿Estás seguro de que quieres borrar esta sala? Se borrarán TODOS los puntos que contiene.')) {
    const { error } = await supabase.from('salas').delete().eq('id', salaId);
    if (error) { alert("Error al borrar la sala: " + error.message); } 
    else {
      salas.value = salas.value.filter(s => s.id !== salaId);
      puntos.value = puntos.value.filter(p => p.sala_id !== salaId);
      if (activeSalaId.value === salaId) { activeSalaId.value = salas.value.length > 0 ? salas.value[0].id : null; }
    }
  }
};

const handleUpdatePosition = async (point) => {
  const { error } = await supabase.from('puntos_maestros').update({ coordenada_x: point.coordenada_x, coordenada_y: point.coordenada_y }).eq('id', point.id);
  if (error) alert('Error al guardar la nueva posición: ' + error.message);
};

const saveSalaColor = async (sala) => {
  const { error } = await supabase.from('salas').update({ color: sala.color }).eq('id', sala.id);
  if (error) alert("Error al guardar el color: " + error.message);
};
</script>

<template>
  <div class="p-4 sm:p-8 h-full flex flex-col">
    <input type="file" @change="onFileSelected" accept="image/*" class="hidden" ref="fileInput">
    <div v-if="loading" class="flex justify-center items-center h-full">Cargando...</div>
    <div v-else-if="centro && version" class="flex-1 flex flex-col">
      <div v-if="version.url_imagen_plano" class="flex-1 flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-start mb-6 gap-4">
          <div>
            <h1 class="text-3xl font-bold text-slate-800">Configurar: {{ centro.nombre }}</h1>
            <p class="text-slate-600 mt-2">
              Editando versión: <strong class="text-blue-600">{{ version.nombre }}</strong> 
              <span v-if="version.es_activa" class="ml-2 text-xs font-bold text-green-700 bg-green-100 px-2 py-0.5 rounded-full">ACTIVA</span>
              <span v-else class="ml-2 text-xs font-bold text-slate-700 bg-slate-100 px-2 py-0.5 rounded-full">ARCHIVADA</span>
            </p>
          </div>
          <div class="flex gap-2 flex-shrink-0">
             <button @click="fileInput.click()" class="flex items-center gap-2 px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <ArrowPathIcon class="h-5 w-5" /> Cambiar Plano
             </button>
             <button v-if="isDrawingMode || isPointEditingMode" @click="cancelAllModes" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
                <XCircleIcon class="h-5 w-5" /> Cancelar
             </button>
            <button @click="router.push(`/centros/${centro.id}/versiones`)" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">Volver a Versiones</button>
          </div>
        </div>
        
        <div class="flex-1 grid grid-cols-1 lg:grid-cols-4 gap-8 overflow-hidden">
          <div class="lg:col-span-1 bg-white rounded-xl shadow-sm border border-slate-200 p-4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-slate-800">Salas</h2>
                <button 
                    @click="togglePointEditingMode" 
                    :disabled="salas.length === 0"
                    :class="[
                        'flex items-center gap-1.5 px-2.5 py-1 text-xs font-semibold text-white rounded-md transition-colors',
                        'disabled:bg-slate-400 disabled:cursor-not-allowed',
                        isPointEditingMode ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'
                    ]">
                    <component :is="isPointEditingMode ? CheckCircleIcon : PencilIcon" class="h-4 w-4" />
                    {{ isPointEditingMode ? 'Finalizar Edición' : 'Gestionar Puntos' }}
                </button>
            </div>
            <div class="flex-1 overflow-y-auto -mr-4 pr-4">
              <ul class="space-y-2">
                <li v-for="sala in salas" :key="sala.id">
                  <div @click="activeSalaId = sala.id" :class="['w-full p-3 rounded-lg transition-colors flex justify-between items-center group cursor-pointer', activeSalaId === sala.id ? 'bg-blue-100 ring-2 ring-blue-300' : 'hover:bg-slate-100']">
                    <div class="flex items-center gap-3">
                      <input type="color" v-model="sala.color" @input="saveSalaColor(sala)" class="w-6 h-6 p-0 border-none rounded-md cursor-pointer flex-shrink-0">
                      <span class="font-semibold" :class="{'text-blue-800': activeSalaId === sala.id}">{{ sala.nombre }}</span>
                    </div>
                  </div>
                  <!-- Botones de acción para la sala activa -->
                   <div v-if="activeSalaId === sala.id" class="pl-10 -mt-2 mb-2 flex items-center gap-2">
                      <button @click="enterDrawingMode" :disabled="isPointEditingMode" class="flex items-center gap-1 text-xs text-blue-600 hover:text-blue-800 disabled:text-slate-400">
                         <MapIcon class="h-4 w-4" /> Definir Área
                      </button>
                      <button v-if="sala.area_puntos" @click="clearArea" :disabled="isPointEditingMode" class="flex items-center gap-1 text-xs text-red-600 hover:text-red-800 disabled:text-slate-400">
                         <BackspaceIcon class="h-4 w-4" /> Limpiar
                      </button>
                      <button @click="deleteSala(sala.id)" :disabled="isPointEditingMode" class="flex items-center gap-1 text-xs text-slate-500 hover:text-red-600 disabled:text-slate-400">
                         <TrashIcon class="h-4 w-4" /> Borrar Sala
                      </button>
                   </div>
                </li>
              </ul>
            </div>
            <form @submit.prevent="addSala" class="mt-4 flex-shrink-0 flex gap-2">
              <input v-model="newSalaName" type="text" placeholder="Nueva sala..." class="flex-1 block w-full rounded-md border-slate-300 shadow-sm text-sm">
              <button type="submit" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                <PlusIcon class="h-5 w-5" />
              </button>
            </form>
          </div>
          
          <div class="lg:col-span-3 bg-white rounded-lg shadow-sm border border-slate-200 relative">
            <div v-if="instructionText" class="absolute top-4 left-1/2 -translate-x-1/2 max-w-[90%] bg-blue-600 text-white text-sm font-semibold py-2 px-4 rounded-lg shadow-lg z-20 pointer-events-none flex items-center gap-2">
              <InformationCircleIcon class="h-5 w-5 flex-shrink-0" />
              <span>{{ instructionText }}</span>
            </div>
            
            <InteractiveMap 
              :image-url="version.url_imagen_plano" 
              :points="puntos" 
              :salas="salas"
              :is-read-only="!isPointEditingMode"
              :is-placement-mode="isPointEditingMode"
              :is-area-drawing-mode="isDrawingMode"
              @add-point="handleNewPoint" 
              @delete-point="handleDeletePoint" 
              @update-point-position="handleUpdatePosition"
              @area-drawn="handleAreaDrawn"
              @drawing-cancelled="cancelAllModes"
            />
          </div>
        </div>
      </div>
      
      <div v-else class="flex-1 flex flex-col items-center justify-center">
         <div class="max-w-3xl mx-auto text-center">
          <h1 class="text-3xl font-bold text-slate-800">Se necesita un plano para esta versión</h1>
          <p class="text-slate-600 mt-4 text-lg">La versión <strong class="text-blue-600">{{ version.nombre }}</strong> no tiene un plano asignado. Sube una imagen para empezar a definir los puntos.</p>
        </div>
        <div class="mt-8 max-w-lg w-full mx-auto bg-white p-8 rounded-lg shadow-md border">
          <button @click="fileInput.click()" class="w-full flex flex-col items-center justify-center gap-4 px-6 py-10 border-2 border-dashed border-slate-300 rounded-lg hover:border-blue-500 transition-colors">
            <ArrowUpTrayIcon class="h-10 w-10 text-slate-400" />
            <span class="text-slate-500 font-medium">Haz clic aquí para seleccionar un archivo</span>
          </button>
        </div>
        <div class="text-center mt-8">
          <button @click="router.push(`/centros/${centro.id}/versiones`)" class="font-semibold text-slate-600 hover:text-slate-800">Volver a Versiones sin guardar</button>
        </div>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\CentroConfigView.vue ---

--- INICIO DEL ARCHIVO: src\views\CentroHistorialView.vue ---
<!-- src/views/CentroHistorialView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { EyeIcon, TrashIcon, CheckBadgeIcon, DocumentTextIcon, PaperAirplaneIcon, WrenchScrewdriverIcon, MapIcon } from '@heroicons/vue/24/outline';
import { generateTextReport } from '../utils/pdf';
import MarkAsSentModal from '../components/MarkAsSentModal.vue';

const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const loading = ref(true);
const centro = ref(null);
const inspecciones = ref([]);
const isGeneratingPdf = ref(false);
const isSentModalOpen = ref(false);
const selectedInspeccion = ref(null);

const estadoInfo = computed(() => (estado) => {
  switch (estado) {
    case 'en_progreso': return { text: 'En Progreso', class: 'bg-blue-100 text-blue-800' };
    case 'finalizada': return { text: 'Pendiente de Envío', class: 'bg-orange-100 text-orange-800' };
    case 'pendiente_subsanacion': return { text: 'Pendiente de Subsanación', class: 'bg-yellow-100 text-yellow-800' };
    case 'cerrada': return { text: 'Cerrada y Subsanada', class: 'bg-green-100 text-green-800' };
    default: return { text: estado, class: 'bg-slate-100 text-slate-800' };
  }
});

const openSentModal = (inspeccion) => {
  selectedInspeccion.value = inspeccion;
  isSentModalOpen.value = true;
};

const handleMarkAsSent = async (formData) => {
  if (!selectedInspeccion.value) return;
  const { error } = await supabase
    .from('inspecciones')
    .update({ 
      fecha_envio_cliente: formData.fecha_envio, 
      responsable_envio_cliente: formData.responsable_envio,
      estado: 'pendiente_subsanacion'
    })
    .eq('id', selectedInspeccion.value.id)
  
  if (error) {
    alert('Error al marcar como enviado: ' + error.message);
  } else {
    isSentModalOpen.value = false;
    fetchData();
  }
};

const handleGenerateTextReport = async (inspeccionId, reportType) => {
  isGeneratingPdf.value = true;
  await generateTextReport(inspeccionId, reportType);
  isGeneratingPdf.value = false;
};

const fetchData = async () => {
  loading.value = true;
  const { data: centroData } = await supabase.from('centros').select('nombre').eq('id', centroId).single();
  centro.value = centroData;
  const { data: inspeccionesData } = await supabase.from('vista_historial_inspecciones').select('*').eq('centro_id', centroId);
  inspecciones.value = inspeccionesData || [];
  loading.value = false;
};

const handleDelete = async (inspeccionId) => {
  if (confirm('¿Estás seguro de que quieres borrar esta inspección? Esta acción es permanente y eliminará todos los datos y fotos asociados.')) {
    try {
      const { data: incidencias, error: getError } = await supabase.from('incidencias').select('url_foto_antes, url_foto_despues').eq('inspeccion_id', inspeccionId);
      if (getError) throw getError;

      const filesToDelete = [];
      if (incidencias && incidencias.length > 0) {
        incidencias.forEach(inc => {
          if (inc.url_foto_antes) { const filePath = inc.url_foto_antes.split('/incidencias/')[1]; if (filePath) filesToDelete.push(filePath); }
          if (inc.url_foto_despues) { const filePath = inc.url_foto_despues.split('/incidencias/')[1]; if (filePath) filesToDelete.push(filePath); }
        });
      }

      if (filesToDelete.length > 0) {
        const { error: storageError } = await supabase.storage.from('incidencias').remove(filesToDelete);
        if (storageError) { alert('Advertencia: No se pudieron borrar algunas fotos asociadas. Error: ' + storageError.message); }
      }

      const { error: deleteError } = await supabase.from('inspecciones').delete().eq('id', inspeccionId);
      if (deleteError) throw deleteError;

      inspecciones.value = inspecciones.value.filter(i => i.id !== inspeccionId);
      alert('Inspección borrada con éxito.');

    } catch (error) {
      alert('Ocurrió un error al borrar la inspección: ' + error.message);
    }
  }
};

onMounted(fetchData);
</script>

<template>
  <div class="p-8">
    <div v-if="loading">Cargando...</div>
    <div v-else-if="centro">
      <div class="flex justify-between items-center mb-8">
        <div>
          <h1 class="text-4xl font-bold text-slate-800">Historial de Inspecciones</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <button @click="router.push('/centros')" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">Volver</button>
      </div>

      <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
        <ul class="divide-y divide-slate-200">
          <li v-if="inspecciones.length === 0" class="p-8 text-center text-slate-500">No hay inspecciones.</li>
          
          <li v-for="inspeccion in inspecciones" :key="inspeccion.id" class="p-4 grid grid-cols-1 lg:grid-cols-5 gap-6 items-center">
            
            <div class="lg:col-span-1">
              <p class="font-semibold text-slate-800">Fecha Inspección:</p>
              <p class="text-slate-600">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</p>
            </div>
            
            <div class="lg:col-span-1">
               <p class="font-semibold text-slate-800">Estado General:</p>
               <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium capitalize" :class="estadoInfo(inspeccion.estado).class">
                  {{ estadoInfo(inspeccion.estado).text }}
               </span>
            </div>
            
            <div class="lg:col-span-1">
              <p class="font-semibold text-slate-800 mb-1">Resumen Incidencias:</p>
              <div class="flex items-center gap-x-3">
                  <div class="flex items-center gap-1.5" title="Leves"><span class="h-2.5 w-2.5 rounded-full bg-green-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.incidencias_verdes }}</span></div>
                  <div class="flex items-center gap-1.5" title="Moderadas"><span class="h-2.5 w-2.5 rounded-full bg-amber-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.incidencias_ambares }}</span></div>
                  <div class="flex items-center gap-1.5" title="Graves"><span class="h-2.5 w-2.5 rounded-full bg-red-500"></span><span class="font-bold text-sm text-slate-700">{{ inspeccion.incidencias_rojas }}</span></div>
              </div>
            </div>
            
            <div class="lg:col-span-2 flex justify-end items-center flex-wrap gap-2">
              <button v-if="inspeccion.estado === 'finalizada'" @click="openSentModal(inspeccion)" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-blue-700 bg-blue-50 hover:bg-blue-100 border border-blue-200"><PaperAirplaneIcon class="h-4 w-4" /> Marcar Envío </button>
              
              <router-link v-if="inspeccion.estado === 'pendiente_subsanacion'" :to="`/inspecciones/${inspeccion.id}/subsanar`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-purple-700 bg-purple-50 hover:bg-purple-100 border border-purple-200"><WrenchScrewdriverIcon class="h-4 w-4" /> Subsanar </router-link>

              <!-- === INICIO DE LA CORRECCIÓN === -->
              <!-- Cambiado de <button> a <router-link> para navegar a la nueva vista de previsualización -->
              <router-link :to="`/inspecciones/${inspeccion.id}/plano-preview`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-teal-700 bg-teal-50 hover:bg-teal-100 border border-teal-200">
                  <MapIcon class="h-4 w-4"/>Plano
              </router-link>
              <!-- === FIN DE LA CORRECCIÓN === -->
              
              <button @click="handleGenerateTextReport(inspeccion.id, 'initial')" :disabled="isGeneratingPdf" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-slate-600 bg-slate-100 hover:bg-slate-200 border border-slate-200 disabled:opacity-50"><DocumentTextIcon class="h-4 w-4"/>Informe Inicial</button>
              
              <button v-if="inspeccion.estado === 'cerrada'" @click="handleGenerateTextReport(inspeccion.id, 'remediation')" :disabled="isGeneratingPdf" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold rounded-md text-green-700 bg-green-100 hover:bg-green-200 border border-green-200 disabled:opacity-50"><CheckBadgeIcon class="h-4 w-4"/>Informe Subsanación</button>
              
              <div class="flex items-center gap-1 border-l pl-2 ml-2">
                <router-link :to="`/inspecciones/${inspeccion.id}`" class="p-2 text-slate-500 hover:text-blue-600" title="Ver Inspección"><EyeIcon class="h-5 w-5" /></router-link>
                <button @click="handleDelete(inspeccion.id)" class="p-2 text-slate-500 hover:text-red-600" title="Borrar Inspección"><TrashIcon class="h-5 w-5" /></button>
              </div>
            </div>
          </li>
        </ul>
      </div>
    </div>
    <MarkAsSentModal :is-open="isSentModalOpen" :inspeccion-id="selectedInspeccion?.id" @close="isSentModalOpen = false" @save="handleMarkAsSent" />
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\CentroHistorialView.vue ---

--- INICIO DEL ARCHIVO: src\views\CentrosListView.vue ---
<!-- src/views/CentrosListView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import { PlusIcon, PencilIcon, MapPinIcon, ArchiveBoxIcon, DocumentDuplicateIcon } from '@heroicons/vue/24/solid';
import CentroFormModal from '../components/CentroFormModal.vue';

const centros = ref([]);
const loading = ref(true);
const isModalOpen = ref(false);
const selectedCentro = ref(null);
const filterZona = ref('');

const zonas = ['Norte', 'Sur', 'Este', 'Oeste', 'Centro', 'Noreste', 'Noroeste', 'Sureste', 'Islas Baleares', 'Islas Canarias'];

const filteredCentros = computed(() => {
  if (!filterZona.value) return centros.value;
  return centros.value.filter(c => c.zona === filterZona.value);
});

const openCreateModal = () => {
  selectedCentro.value = null;
  isModalOpen.value = true;
};

const openEditModal = (centro) => {
  selectedCentro.value = centro;
  isModalOpen.value = true;
};

const handleSaveCentro = async (centroData) => {
  const dataToSave = { ...centroData };
  let error;
  if (dataToSave.id) {
    const { error: updateError } = await supabase.from('centros').update(dataToSave).eq('id', dataToSave.id);
    error = updateError;
  } else {
    delete dataToSave.id;
    const { error: insertError } = await supabase.from('centros').insert(dataToSave);
    error = insertError;
  }
  if (error) alert(error.message);
  else {
    isModalOpen.value = false;
    fetchCentros();
  }
};

const fetchCentros = async () => {
  loading.value = true;
  const { data } = await supabase.from('centros').select('*').order('nombre');
  if (data) centros.value = data;
  loading.value = false;
};

onMounted(fetchCentros);
</script>

<template>
  <div class="p-8">
    <div class="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
      <h1 class="text-4xl font-bold text-slate-800">Maestro de Centros</h1>
      <div class="flex items-center gap-4">
        <select v-model="filterZona" class="rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm">
          <option value="">Todas las Zonas</option>
          <option v-for="z in zonas" :key="z" :value="z">{{ z }}</option>
        </select>
        <button @click="openCreateModal" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm">
          <PlusIcon class="h-5 w-5" />
          Agregar Centro
        </button>
      </div>
    </div>
    
    <div v-if="loading" class="text-center text-slate-500">Cargando...</div>
    <div v-else class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
      <div class="min-w-full">
        <div class="hidden md:grid grid-cols-12 gap-4 px-6 py-4 bg-slate-50 border-b border-slate-200">
          <div class="col-span-4 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Centro / Dirección</div>
          <div class="col-span-3 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Responsable</div>
          <div class="col-span-2 text-left text-xs font-semibold text-slate-500 uppercase tracking-wider">Zona</div>
          <div class="col-span-3 text-right text-xs font-semibold text-slate-500 uppercase tracking-wider">Acciones</div>
        </div>

        <ul class="divide-y divide-slate-200">
          <li v-for="centro in filteredCentros" :key="centro.id" class="px-6 py-4 grid grid-cols-1 md:grid-cols-12 gap-4 items-center">
            <div class="col-span-1 md:col-span-4">
              <p class="text-lg font-bold text-slate-900">{{ centro.nombre }}</p>
              <p class="text-sm text-slate-500">{{ centro.direccion }}</p>
            </div>
            <div class="col-span-1 md:col-span-3">
              <p class="text-sm font-medium text-slate-800">{{ centro.responsable_nombre }}</p>
              <p class="text-sm text-slate-500">{{ centro.responsable_email }}</p>
            </div>
            <div class="col-span-1 md:col-span-2">
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800">
                {{ centro.zona }}
              </span>
            </div>
            <div class="col-span-1 md:col-span-3 flex justify-end items-center flex-wrap gap-2">
              <button @click="openEditModal(centro)" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <PencilIcon class="h-4 w-4" />
                Editar
              </button>
              <router-link :to="`/centros/${centro.id}/historial`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                <ArchiveBoxIcon class="h-4 w-4" />
                Historial
              </router-link>
              <!-- === CAMBIO: El botón ahora apunta a la nueva vista de versiones === -->
              <router-link :to="`/centros/${centro.id}/versiones`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
                <DocumentDuplicateIcon class="h-4 w-4" />
                Planos
              </router-link>
            </div>
          </li>
        </ul>
      </div>
    </div>

    <CentroFormModal :is-open="isModalOpen" :centro="selectedCentro" @close="isModalOpen = false" @save="handleSaveCentro" />
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\CentrosListView.vue ---

--- INICIO DEL ARCHIVO: src\views\CentroVersionsView.vue ---
<!-- src/views/CentroVersionsView.vue -->
<script setup>
import { ref, onMounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { PlusIcon, PencilIcon, CheckCircleIcon, ArchiveBoxIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const centroId = route.params.id;

const loading = ref(true);
const centro = ref(null);
const versiones = ref([]);
const newVersionName = ref('');

const fetchVersions = async () => {
  loading.value = true;
  const { data: centroData } = await supabase.from('centros').select('nombre').eq('id', centroId).single();
  centro.value = centroData;

  const { data: versionsData } = await supabase
    .from('versiones_plano')
    .select('*')
    .eq('centro_id', centroId)
    .order('fecha_creacion', { ascending: false });
  versiones.value = versionsData || [];
  loading.value = false;
};

const createNewVersion = async () => {
    if (!newVersionName.value.trim()) {
        alert('Por favor, introduce un nombre para la nueva versión.');
        return;
    }

    // Llamamos a una función RPC de Supabase que se encarga de la lógica de duplicación
    // Esta función debería:
    // 1. Poner a `false` la `es_activa` de la versión activa actual.
    // 2. Crear la nueva versión con `es_activa = true`.
    // 3. Duplicar las salas y puntos de la versión anterior a la nueva.
    // 4. Devolver el ID de la nueva versión.
    const { data, error } = await supabase.rpc('crear_nueva_version_plano', {
        centro_id_param: centroId,
        nuevo_nombre_param: newVersionName.value.trim()
    });

    if (error) {
        alert('Error al crear la nueva versión: ' + error.message);
        console.error(error);
    } else {
        alert('Nueva versión creada con éxito.');
        newVersionName.value = '';
        await fetchVersions();
        // Opcionalmente, redirigir directamente a la configuración de la nueva versión
        if (data) {
           router.push(`/versiones/${data}/configurar`);
        }
    }
};

onMounted(fetchVersions);
</script>

<template>
  <div class="p-8">
    <div v-if="loading">Cargando versiones...</div>
    <div v-else-if="centro">
      <div class="flex justify-between items-center mb-8">
        <div>
          <h1 class="text-4xl font-bold text-slate-800">Versiones del Plano</h1>
          <p class="text-xl text-slate-600 mt-2">{{ centro.nombre }}</p>
        </div>
        <router-link to="/centros" class="px-4 py-2 font-semibold text-white bg-slate-600 rounded-md hover:bg-slate-700">
          Volver a Centros
        </router-link>
      </div>

      <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 mb-8 max-w-3xl mx-auto">
        <h2 class="text-2xl font-bold text-slate-800 mb-4">Crear Nueva Versión</h2>
        <p class="text-slate-500 mb-4">
          Crea una nueva versión para modificar el plano, añadir o quitar salas y puntos. Se copiará la configuración de la última versión activa.
        </p>
        <form @submit.prevent="createNewVersion" class="flex flex-col sm:flex-row gap-4">
          <input 
            v-model="newVersionName" 
            type="text" 
            placeholder="Ej: Reforma Almacén 2026" 
            required
            class="flex-1 block w-full rounded-md border-slate-300 shadow-sm"
          >
          <button 
            type="submit"
            class="flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 shadow-sm"
          >
            <PlusIcon class="h-5 w-5" />
            Crear Versión
          </button>
        </form>
      </div>

      <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
        <ul class="divide-y divide-slate-200">
          <li v-if="versiones.length === 0" class="p-8 text-center text-slate-500">
            No se han encontrado versiones para este centro. Crea la primera.
          </li>
          <li v-for="version in versiones" :key="version.id" class="p-4 grid grid-cols-1 md:grid-cols-4 gap-4 items-center">
            <div class="md:col-span-1">
              <p class="font-semibold text-slate-800 text-lg">{{ version.nombre }}</p>
              <p class="text-sm text-slate-500">Creada: {{ new Date(version.fecha_creacion).toLocaleDateString() }}</p>
            </div>
            <div class="md:col-span-1">
              <span v-if="version.es_activa" class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <CheckCircleIcon class="h-4 w-4" />
                Versión Activa
              </span>
              <span v-else class="inline-flex items-center gap-1.5 px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-600">
                <ArchiveBoxIcon class="h-4 w-4" />
                Archivada
              </span>
            </div>
            <div class="md:col-span-2 flex justify-end items-center gap-2">
              <router-link :to="`/versiones/${version.id}/configurar`" class="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-green-600 rounded-md hover:bg-green-700">
                <PencilIcon class="h-4 w-4" />
                Configurar Plano
              </router-link>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\CentroVersionsView.vue ---

--- INICIO DEL ARCHIVO: src\views\DashboardView.vue ---
<!-- src/views/DashboardView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { supabase } from '../supabase';
import { useRouter } from 'vue-router';
import { 
  BuildingStorefrontIcon, 
  ExclamationTriangleIcon, 
  ClockIcon,
  PaperAirplaneIcon,
  CheckBadgeIcon
} from '@heroicons/vue/24/outline';
import { Line, Bar } from 'vue-chartjs';
import { Chart as ChartJS, Title, Tooltip, Legend, LineElement, BarElement, PointElement, CategoryScale, LinearScale } from 'chart.js';

ChartJS.register(Title, Tooltip, Legend, LineElement, BarElement, PointElement, CategoryScale, LinearScale);

const loading = ref(true);
const centros = ref([]);
const resumenInspecciones = ref([]);
const router = useRouter();

onMounted(async () => {
  loading.value = true;
  const [centrosRes, resumenRes] = await Promise.all([
    supabase.from('centros').select('id', { count: 'exact' }),
    supabase.from('vista_resumen_inspecciones').select('*')
  ]);
  
  centros.value = centrosRes.data || [];
  resumenInspecciones.value = resumenRes.data || [];
  loading.value = false;
});

// === DATOS PARA LAS TARJETAS DE RESUMEN ===
const totalCentros = computed(() => centros.value.length);
const inspeccionesEnProgreso = computed(() => resumenInspecciones.value.filter(i => i.estado === 'en_progreso').length);
const inspeccionesPendientesEnvio = computed(() => resumenInspecciones.value.filter(i => i.estado === 'finalizada').length);
const inspeccionesPendientesSubsanacion = computed(() => resumenInspecciones.value.filter(i => i.estado === 'pendiente_subsanacion').length);
const inspeccionesCerradas = computed(() => resumenInspecciones.value.filter(i => i.estado === 'cerrada').length);

// === DATOS GRÁFICO 1: ACTIVIDAD MENSUAL ===
const actividadMensual = computed(() => {
    const meses = {};
    const hoy = new Date();
    for (let i = 11; i >= 0; i--) {
        const d = new Date(hoy.getFullYear(), hoy.getMonth() - i, 1);
        const clave = d.toISOString().slice(0, 7);
        const etiqueta = d.toLocaleString('es-ES', { month: 'short', year: '2-digit' });
        meses[clave] = { etiqueta, realizadas: 0, cerradas: 0 };
    }
    resumenInspecciones.value.forEach(inspeccion => {
        const claveMes = inspeccion.fecha_inspeccion.slice(0, 7);
        if (meses[claveMes]) {
            meses[claveMes].realizadas++;
            if (inspeccion.estado === 'cerrada') meses[claveMes].cerradas++;
        }
    });
    return Object.values(meses);
});

const monthlyChartData = computed(() => ({
  labels: actividadMensual.value.map(m => m.etiqueta),
  datasets: [
    { label: 'Inspecciones Realizadas', backgroundColor: '#3B82F6', borderColor: '#3B82F6', data: actividadMensual.value.map(m => m.realizadas), tension: 0.2 },
    { label: 'Inspecciones Cerradas', backgroundColor: '#22C55E', borderColor: '#22C55E', data: actividadMensual.value.map(m => m.cerradas), tension: 0.2 }
  ]
}));

const monthlyChartOptions = {
  responsive: true, maintainAspectRatio: false,
  plugins: { legend: { position: 'top' }, title: { display: true, text: 'Actividad Mensual (Últimos 12 Meses)' } },
  scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
};

// === DATOS GRÁFICO 2: PRODUCTIVIDAD POR TÉCNICO ===
const informesPorTecnico = computed(() => {
  const conteo = {};
  resumenInspecciones.value.forEach(inspeccion => {
    const tecnico = inspeccion.tecnico_nombre || 'Desconocido';
    if (!conteo[tecnico]) conteo[tecnico] = 0;
    conteo[tecnico]++;
  });
  return Object.entries(conteo).sort(([, a], [, b]) => b - a);
});

const technicianChartData = computed(() => ({
  labels: informesPorTecnico.value.map(([tecnico]) => tecnico),
  datasets: [{ label: 'Informes Realizados', backgroundColor: '#6366F1', borderColor: '#4F46E5', borderWidth: 1, borderRadius: 4, data: informesPorTecnico.value.map(([, count]) => count) }]
}));

const technicianChartOptions = {
  responsive: true, maintainAspectRatio: false,
  plugins: { legend: { display: false } },
  scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
};

// === DATOS LISTA: PUNTOS CRÍTICOS ===
const centrosConMasRojas = computed(() => {
  const centrosConteo = {};
  resumenInspecciones.value.filter(i => i.incidencias_rojas > 0 && i.estado !== 'cerrada').forEach(i => {
    if (!centrosConteo[i.centro_id]) centrosConteo[i.centro_id] = { id: i.centro_id, nombre: i.centro_nombre, rojas: 0 };
    centrosConteo[i.centro_id].rojas += i.incidencias_rojas;
  });
  return Object.values(centrosConteo).sort((a, b) => b.rojas - a.rojas).slice(0, 5);
});

// === DATOS TABLA: ACCIONES PENDIENTES ===
const accionesPendientes = computed(() => {
    return resumenInspecciones.value
        .filter(i => i.estado === 'finalizada')
        .sort((a, b) => new Date(a.fecha_inspeccion) - new Date(b.fecha_inspeccion));
});
</script>

<template>
  <div class="h-full overflow-y-auto p-4 sm:p-8 bg-slate-50">
    <h1 class="text-3xl md:text-4xl font-bold text-slate-800 mb-8">Cuadro de Mando</h1>
    
    <div v-if="loading" class="text-center text-slate-500 py-16">Cargando datos del dashboard...</div>
    
    <div v-else class="space-y-8">
      <!-- 1. Tarjetas de Resumen Global -->
      <section>
        <div class="grid grid-cols-2 lg:grid-cols-5 gap-6">
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-blue-100 p-4 rounded-xl"><BuildingStorefrontIcon class="h-8 w-8 text-blue-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ totalCentros }}</p><p class="text-slate-500 font-semibold">Centros</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-yellow-100 p-4 rounded-xl"><ClockIcon class="h-8 w-8 text-yellow-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesEnProgreso }}</p><p class="text-slate-500 font-semibold">En Progreso</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-purple-100 p-4 rounded-xl"><PaperAirplaneIcon class="h-8 w-8 text-purple-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesPendientesEnvio }}</p><p class="text-slate-500 font-semibold">Pendiente Envío</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-orange-100 p-4 rounded-xl"><ExclamationTriangleIcon class="h-8 w-8 text-orange-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesPendientesSubsanacion }}</p><p class="text-slate-500 font-semibold">Pendiente Subsanación</p></div>
          </div>
          <div class="bg-gradient-to-br from-white to-slate-50 p-6 rounded-2xl shadow-sm border border-slate-200 flex items-center gap-5">
            <div class="bg-green-100 p-4 rounded-xl"><CheckBadgeIcon class="h-8 w-8 text-green-600" /></div>
            <div><p class="text-4xl font-bold text-slate-800">{{ inspeccionesCerradas }}</p><p class="text-slate-500 font-semibold">Cerradas</p></div>
          </div>
        </div>
      </section>

      <!-- 2. NUEVO LAYOUT DE 2 COLUMNAS -->
      <section class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Columna Izquierda: Actividad Mensual -->
        <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
           <div class="h-80">
              <Line :data="monthlyChartData" :options="monthlyChartOptions" />
           </div>
        </div>

        <!-- Columna Derecha: Widgets apilados -->
        <div class="lg:col-span-1 space-y-8">
          <!-- Widget: Productividad por Técnico -->
          <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <h2 class="text-xl font-bold text-slate-800 mb-4">Productividad por Técnico</h2>
            <div class="h-40">
              <Bar :data="technicianChartData" :options="technicianChartOptions" />
            </div>
          </div>

          <!-- Widget: Puntos Críticos -->
          <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 flex flex-col">
            <h2 class="text-xl font-bold text-slate-800 mb-4 flex-shrink-0">Puntos Críticos Activos</h2>
            <ul v-if="centrosConMasRojas.length > 0" class="divide-y divide-slate-100">
              <li v-for="centro in centrosConMasRojas" :key="centro.id" class="py-3 flex justify-between items-center group">
                <div>
                  <p class="font-semibold text-slate-800 group-hover:text-blue-600">{{ centro.nombre }}</p>
                  <p class="text-sm text-slate-500 flex items-center"><span class="h-2.5 w-2.5 rounded-full bg-red-500 mr-2"></span><span class="font-bold text-red-600">{{ centro.rojas }}</span>&nbsp;incidencias graves</p>
                </div>
                <router-link :to="`/centros/${centro.id}/historial`" class="opacity-0 group-hover:opacity-100 px-3 py-1 text-sm font-semibold text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 transition-opacity">Revisar</router-link>
              </li>
            </ul>
            <div v-else class="flex-1 flex flex-col items-center justify-center text-center text-slate-500 p-4">
              <span class="text-2xl mb-2">🎉</span><p class="font-semibold">¡Todo en orden!</p><p class="text-sm">No hay incidencias graves activas.</p>
            </div>
          </div>
        </div>
      </section>

      <!-- 3. Acciones Pendientes -->
       <section class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
        <h2 class="text-xl font-bold text-slate-800 mb-4">Acciones Pendientes (Enviar a Cliente)</h2>
         <div class="overflow-x-auto">
          <table class="min-w-full divide-y divide-slate-200">
             <thead class="bg-slate-50">
              <tr>
                <th class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Centro</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Fecha Finalización</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Técnico</th>
                <th class="relative px-6 py-3"><span class="sr-only">Acción</span></th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-slate-200">
              <tr v-if="accionesPendientes.length === 0">
                  <td colspan="4" class="px-6 py-8 text-center text-slate-500">No hay acciones pendientes. ¡Buen trabajo!</td>
              </tr>
              <tr v-for="inspeccion in accionesPendientes" :key="inspeccion.inspeccion_id" class="hover:bg-slate-50">
                <td class="px-6 py-4 whitespace-nowrap font-semibold text-slate-800">{{ inspeccion.centro_nombre }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-slate-600">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-slate-600">{{ inspeccion.tecnico_nombre }}</td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                  <router-link :to="`/centros/${inspeccion.centro_id}/historial`" class="font-semibold text-purple-600 hover:text-purple-800">Gestionar Envío</router-link>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\DashboardView.vue ---

--- INICIO DEL ARCHIVO: src\views\InspeccionDetailView.vue ---
<!-- src/views/InspeccionDetailView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import InteractiveMap from '../components/InteractiveMap.vue';
import ChecklistModal from '../components/ChecklistModal.vue';
import PointList from '../components/PointList.vue';
import AddPointForm from '../components/AddPointForm.vue';
import { CheckCircleIcon, PlusIcon, XCircleIcon, ChevronDownIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const inspeccion = ref(null);
const centro = ref(null);
const version = ref(null);
const salas = ref([]);
const puntosMaestros = ref([]);
const puntosInspeccionados = ref([]);
const isModalOpen = ref(false);
const selectedPunto = ref(null);
const showAddPointForm = ref(false);
const isPlacementMode = ref(false);
const newPointSalaId = ref(null);

const canEditInspection = computed(() => {
  return inspeccion.value?.estado === 'en_progreso';
});

onMounted(async () => {
  loading.value = true;
  const { data: inspectionData, error: inspectionError } = await supabase.from('inspecciones').select('*, centros(*), versiones_plano(*)').eq('id', inspeccionId).single();
  if (inspectionError || !inspectionData || !inspectionData.versiones_plano) {
      alert('Error: No se pudo cargar la inspección. Puede que no tenga una versión de plano asignada.');
      loading.value = false; return;
  }
  inspeccion.value = inspectionData;
  centro.value = inspectionData.centros;
  version.value = inspectionData.versiones_plano;
  if (version.value) {
    const [salasRes, puntosMaestrosRes] = await Promise.all([
      supabase.from('salas').select('*').eq('version_id', version.value.id).order('nombre'),
      supabase.from('puntos_maestros').select('*').eq('version_id', version.value.id)
    ]);
    salas.value = salasRes.data || [];
    puntosMaestros.value = puntosMaestrosRes.data || [];
    await initializeInspectionPoints();
  }
  loading.value = false;
});

const initializeInspectionPoints = async () => {
  const { data: existingPoints } = await supabase.from('puntos_inspeccionados').select('*').eq('inspeccion_id', inspeccionId);
  puntosInspeccionados.value = existingPoints || [];
  if (puntosInspeccionados.value.length === 0 && puntosMaestros.value.length > 0) {
    const pointsToCreate = puntosMaestros.value.map(pm => ({
      inspeccion_id: inspeccionId,
      punto_maestro_id: pm.id,
      nomenclatura: pm.nomenclatura,
      coordenada_x: pm.coordenada_x,
      coordenada_y: pm.coordenada_y,
      estado: 'existente',
      tiene_placa_caracteristicas: true // <-- ¡AQUÍ ESTÁ LA CORRECCIÓN CLAVE!
    }));
    if (pointsToCreate.length > 0) {
      const { data: newPoints } = await supabase.from('puntos_inspeccionados').insert(pointsToCreate).select();
      if (newPoints) puntosInspeccionados.value = newPoints;
    }
  }
};

const getSalaColor = (salaId) => {
  const sala = salas.value.find(s => s.id === salaId);
  return sala ? sala.color : '#9CA3AF';
};
const puntosParaMostrar = computed(() => {
  if (!puntosInspeccionados.value || !puntosMaestros.value) return [];
  return puntosInspeccionados.value.map(pi => {
    const maestro = puntosMaestros.value.find(pm => pm.id === pi.punto_maestro_id);
    return { ...pi, sala_id: maestro?.sala_id, color: getSalaColor(maestro?.sala_id) };
  });
});
const puntosAgrupadosPorSala = computed(() => {
  if (!salas.value.length || !puntosParaMostrar.value.length) return [];
  return salas.value.map(sala => ({
    ...sala,
    puntos: puntosParaMostrar.value
      .filter(p => p.sala_id === sala.id)
      .sort((a,b) => a.nomenclatura.localeCompare(b.nomenclatura, undefined, {numeric: true}))
  })).filter(g => g.puntos.length > 0);
});
const createNewPointAt = async (coords, salaId) => {
  isPlacementMode.value = false;
  newPointSalaId.value = null;
  const salaSeleccionada = salas.value.find(s => s.id === salaId);
  const puntosDeLaSala = puntosMaestros.value.filter(p => p.sala_id === salaId);
  const ultimoNumero = Math.max(0, ...puntosDeLaSala.map(p => parseInt(p.nomenclatura.split('-').pop() || 0)));
  const nuevaNomenclatura = `${salaSeleccionada.nombre}-${ultimoNumero + 1}`;
  const { data: nuevoPuntoMaestro, error: maestroError } = await supabase.from('puntos_maestros').insert({ version_id: version.value.id, sala_id: salaId, nomenclatura: nuevaNomenclatura, coordenada_x: coords.x, coordenada_y: coords.y }).select().single();
  if (maestroError) { alert("Error al crear el punto maestro: " + maestroError.message); return; }
  puntosMaestros.value.push(nuevoPuntoMaestro);
  const { data: nuevoPuntoIns } = await supabase.from('puntos_inspeccionados').insert({
    inspeccion_id: inspeccionId,
    punto_maestro_id: nuevoPuntoMaestro.id,
    nomenclatura: nuevoPuntoMaestro.nomenclatura,
    coordenada_x: nuevoPuntoMaestro.coordenada_x,
    coordenada_y: nuevoPuntoMaestro.coordenada_y,
    estado: 'nuevo',
    tiene_placa_caracteristicas: true // <-- También aquí por consistencia
  }).select().single();
  if (nuevoPuntoIns) puntosInspeccionados.value.push(nuevoPuntoIns);
};
const updatePuntoEstado = async (punto, nuevoEstado) => {
    const { error } = await supabase.from('puntos_inspeccionados').update({ estado: nuevoEstado }).eq('id', punto.id);
    if (!error) {
        const puntoIndex = puntosInspeccionados.value.findIndex(p => p.id === punto.id);
        if (puntoIndex !== -1) puntosInspeccionados.value[puntoIndex].estado = nuevoEstado;
    }
};
const startPlacementMode = (salaId) => {
  showAddPointForm.value = false;
  newPointSalaId.value = salaId;
  isPlacementMode.value = true;
};
const cancelPlacementMode = () => {
  isPlacementMode.value = false;
  newPointSalaId.value = null;
};
const handleDeleteNewPoint = async (punto) => {
    if (confirm(`¿Estás seguro de que quieres borrar permanentemente el punto "${punto.nomenclatura}"? Esta acción no se puede deshacer.`)) {
        const { error: inspError } = await supabase.from('puntos_inspeccionados').delete().eq('id', punto.id);
        if (inspError) { alert("Error al borrar el punto de la inspección: " + inspError.message); return; }
        const { error: maestroError } = await supabase.from('puntos_maestros').delete().eq('id', punto.punto_maestro_id);
        if (maestroError) { alert("Advertencia: El punto se borró de la inspección pero no del plano maestro."); }
        puntosInspeccionados.value = puntosInspeccionados.value.filter(p => p.id !== punto.id);
        puntosMaestros.value = puntosMaestros.value.filter(p => p.id !== punto.punto_maestro_id);
    }
};
const openChecklistFor = (punto) => {
  if (isPlacementMode.value) return;
  selectedPunto.value = puntosMaestros.value.find(pm => pm.id === punto.punto_maestro_id);
  isModalOpen.value = true;
};
const handleMapClick = (coords) => {
  if (isPlacementMode.value) { createNewPointAt(coords, newPointSalaId.value); }
};
const finalizarInspeccion = async () => {
    if (confirm('¿Estás seguro de que quieres finalizar esta inspección? El estado cambiará a "Pendiente de Envío".')) {
        const { error } = await supabase.from('inspecciones').update({ estado: 'finalizada' }).eq('id', inspeccionId);
        if (error) { alert('Error al finalizar la inspección: ' + error.message); }
        else { router.push(`/centros/${centro.value.id}/historial`); }
    }
};
</script>

<template>
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex items-center justify-center text-slate-500">Cargando datos de la inspección...</div>
    
    <div v-else-if="inspeccion && centro && version" class="flex-1 flex flex-col min-h-0">
      
      <!-- Encabezado Fijo -->
      <header class="flex-shrink-0 px-8 pt-8 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col md:flex-row justify-between items-start gap-4">
          <div>
            <h1 class="text-3xl font-bold text-slate-800 mb-1">Inspección: {{ centro.nombre }}</h1>
            <p class="text-slate-500 text-sm">
              Técnico: <span class="font-medium">{{ inspeccion.tecnico_nombre }}</span> | 
              Fecha: <span class="font-medium">{{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</span> |
              Plano: <strong class="text-blue-600">{{ version.nombre }}</strong>
            </p>
          </div>
          <button v-if="canEditInspection" @click="finalizarInspeccion" class="flex items-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 shadow-sm">
            <CheckCircleIcon class="h-5 w-5" />
            Finalizar Inspección
          </button>
        </div>
      </header>
      
      <!-- Contenido Principal: Panel Lateral y Mapa -->
      <div class="flex-1 flex overflow-hidden">
        
        <!-- Panel Izquierdo Desplegable y con Scroll -->
        <aside class="w-80 lg:w-96 flex-shrink-0 bg-white border-r border-slate-200 flex flex-col">
          <div class="p-4 flex-shrink-0">
             <div v-if="canEditInspection">
                <AddPointForm 
                   v-if="showAddPointForm"
                   :salas="salas"
                   @save="startPlacementMode"
                   @cancel="showAddPointForm = false"
                />
                <button v-else-if="!isPlacementMode" @click="showAddPointForm = true" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-slate-600 bg-slate-100 rounded-md hover:bg-slate-200">
                   <PlusIcon class="h-5 w-5" />
                   Agregar Punto Nuevo
                </button>
                <button v-if="isPlacementMode" @click="cancelPlacementMode" class="w-full flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700">
                   <XCircleIcon class="h-5 w-5" />
                   Cancelar Colocación
                </button>
             </div>
          </div>

          <div class="flex-1 overflow-y-auto px-4 pb-4">
            <PointList 
              :grouped-points="puntosAgrupadosPorSala"
              @select-point="openChecklistFor"
              @update-state="updatePuntoEstado"
              @delete-new-point="handleDeleteNewPoint"
            />
          </div>
        </aside>
        
        <!-- Mapa (Ocupa el resto del espacio) -->
        <main class="flex-1 bg-slate-100 min-w-0">
          <InteractiveMap 
            :image-url="version.url_imagen_plano" 
            :points="puntosParaMostrar.filter(p => p.estado !== 'suprimido')"
            :salas="salas"
            :is-read-only="!canEditInspection || isPlacementMode"
            :is-placement-mode="isPlacementMode"
            @point-click="openChecklistFor"
            @add-point="handleMapClick"
            @delete-point="handleDeleteNewPoint"
          />
        </main>
      </div>
    </div>
    
    <div v-else class="flex-1 flex items-center justify-center text-red-500">No se encontraron datos válidos para esta inspección.</div>

    <ChecklistModal 
      :is-open="isModalOpen" 
      :punto="selectedPunto"
      :inspeccion-id="inspeccionId" 
      @close="isModalOpen = false" 
    />
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\InspeccionDetailView.vue ---

--- INICIO DEL ARCHIVO: src\views\InspeccionesListView.vue ---
<!-- src/views/InspeccionesListView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { supabase } from '../supabase';

const router = useRouter();
const centros = ref([]);
const loading = ref(true);
const isStarting = ref(false);
const searchTerm = ref('');
const tecnicoNombre = ref('');

const filteredCentros = computed(() => {
  if (!searchTerm.value) return centros.value;
  return centros.value.filter(centro =>
    centro.nombre.toLowerCase().includes(searchTerm.value.toLowerCase())
  );
});

// === INICIO DE LA LÓGICA CORREGIDA ===
const startInspection = async (centroId) => {
  if (!tecnicoNombre.value.trim()) {
    alert('Por favor, introduce el nombre del técnico para continuar.');
    return;
  }
  isStarting.value = true;

  // 1. Buscar la VERSIÓN ACTIVA para el centro seleccionado.
  const { data: activeVersion, error: versionError } = await supabase
    .from('versiones_plano')
    .select('id')
    .eq('centro_id', centroId)
    .eq('es_activa', true)
    .single();

  if (versionError || !activeVersion) {
    alert('Error: Este centro no tiene una versión de plano activa. Por favor, configúralo en el Maestro de Centros.');
    console.error("Error buscando versión activa:", versionError);
    isStarting.value = false;
    return;
  }
  const versionId = activeVersion.id;

  // 2. Buscar si ya existe una inspección en progreso para este centro
  let { data: inspection, error: findError } = await supabase
    .from('inspecciones')
    .select('id')
    .eq('centro_id', centroId)
    .eq('estado', 'en_progreso')
    .maybeSingle();
  
  if (findError) {
    alert('Error buscando inspección existente: ' + findError.message);
    isStarting.value = false;
    return;
  }

  // 3. Si no existe, crear una nueva asociándola a la versión activa
  if (!inspection) {
    const { data: newInspection, error: createError } = await supabase
      .from('inspecciones')
      .insert({ 
        centro_id: centroId, 
        version_id: versionId, // <-- Guardamos la versión correcta
        estado: 'en_progreso',
        tecnico_nombre: tecnicoNombre.value.trim(),
        fecha_inspeccion: new Date().toISOString().slice(0, 10)
      })
      .select('id')
      .single();
    
    if (createError) {
      alert('Error creando inspección: ' + createError.message);
      isStarting.value = false;
      return;
    }
    inspection = newInspection;
  } else {
    // Si ya existía, la actualizamos para asegurarnos de que usa la última versión activa
     await supabase.from('inspecciones').update({ 
      tecnico_nombre: tecnicoNombre.value.trim(),
      fecha_inspeccion: new Date().toISOString().slice(0, 10),
      version_id: versionId // <-- Actualizamos también la versión
    }).eq('id', inspection.id);
  }

  // 4. Navegar a la página de detalle
  router.push(`/inspecciones/${inspection.id}`);
};
// === FIN DE LA LÓGICA CORREGIDA ===

onMounted(async () => {
  loading.value = true;
  const { data } = await supabase.from('centros').select('id, nombre').order('nombre');
  if (data) centros.value = data;
  loading.value = false;
});
</script>

<template>
  <div class="p-8">
    <h1 class="text-4xl font-bold text-slate-800 mb-8">Iniciar Inspección</h1>
    <div class="bg-white p-8 rounded-xl shadow-sm border border-slate-200 max-w-3xl mx-auto">
      
      <div class="mb-6">
        <label for="tecnico" class="block text-sm font-medium text-slate-700 mb-1">Nombre del Técnico</label>
        <input 
          v-model="tecnicoNombre" 
          id="tecnico" 
          type="text" 
          placeholder="Escribe tu nombre..." 
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>

      <div>
        <label for="search" class="block text-sm font-medium text-slate-700 mb-1">Buscar y Seleccionar Centro</label>
        <input 
          v-model="searchTerm" 
          id="search" 
          type="search" 
          placeholder="Escribe para buscar un centro..." 
          class="block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        >
      </div>
      
      <div class="mt-4 max-h-60 overflow-y-auto border rounded-md">
        <div v-if="loading" class="p-4 text-center text-slate-500">Cargando centros...</div>
        <ul v-else-if="filteredCentros.length > 0">
          <li v-for="centro in filteredCentros" :key="centro.id" class="border-b last:border-b-0">
            <button 
              @click="startInspection(centro.id)" 
              :disabled="isStarting"
              class="w-full text-left p-4 hover:bg-blue-50 transition-colors disabled:bg-slate-100 disabled:cursor-wait"
            >
              {{ centro.nombre }}
            </button>
          </li>
        </ul>
        <div v-else class="p-4 text-center text-slate-500">No se encontraron centros.</div>
      </div>

    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\InspeccionesListView.vue ---

--- INICIO DEL ARCHIVO: src\views\PlanoPreviewView.vue ---
<!-- src/views/PlanoPreviewView.vue -->
<script setup>
import { ref, onMounted, nextTick } from 'vue';
import { useRoute } from 'vue-router';
import { fetchReportData } from '../utils/pdf/pdf-data';
import { calculatePlanoLayout } from '../utils/plano-layout';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import PlanoBadge from '../components/PlanoBadge.vue';
import { ArrowDownTrayIcon, ArrowUturnLeftIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const errorState = ref(null);
const reportData = ref(null);
const labels = ref([]);
const planoContainer = ref(null);
const mapDimensions = ref({ x: 0, y: 0, width: 1, height: 1 });
const isGenerating = ref(false);
const isScalingForPdf = ref(false);

const draggedLabel = ref(null);
const dragOffset = ref({ x: 0, y: 0 });

onMounted(async () => {
  reportData.value = await fetchReportData(inspeccionId);
  
  if (!reportData.value) {
    errorState.value = "No se pudieron cargar los datos de la inspección.";
    loading.value = false;
    return;
  }

  loading.value = false;
  await nextTick();
  prepareLayout();
});

// --- INICIO DE LA CORRECCIÓN CLAVE ---
// La función ahora es asíncrona y procesa el layout sin bloquear el navegador.
const prepareLayout = async () => {
  const containerEl = planoContainer.value;
  if (!containerEl) {
    errorState.value = "Error: El contenedor del plano no se encontró en el DOM.";
    return;
  }
  
  const img = new Image();
  img.onload = async () => {
    const containerRatio = containerEl.clientWidth / containerEl.clientHeight;
    const imageRatio = img.width / img.height;

    let imgW, imgH, imgX, imgY;
    if (imageRatio > containerRatio) {
      imgW = containerEl.clientWidth;
      imgH = imgW / imageRatio;
      imgX = 0;
      imgY = (containerEl.clientHeight - imgH) / 2;
    } else {
      imgH = containerEl.clientHeight;
      imgW = imgH * imageRatio;
      imgY = 0;
      imgX = (containerEl.clientWidth - imgW) / 2;
    }
    mapDimensions.value = { x: imgX, y: imgY, width: imgW, height: imgH };

    const allPoints = reportData.value.puntosInspeccionadosData.map(punto => {
      const maestro = reportData.value.puntosMaestrosData.find(pm => pm.id === punto.punto_maestro_id);
      if (!maestro) return null;
      return {
        ...punto,
        nomenclatura: maestro.nomenclatura,
        absX: mapDimensions.value.x + (punto.coordenada_x * mapDimensions.value.width),
        absY: mapDimensions.value.y + (punto.coordenada_y * mapDimensions.value.height),
        counts: reportData.value.incidenceCounts.get(punto.id) || { verde: 0, ambar: 0, rojo: 0 }
      };
    }).filter(Boolean);

    // Procesamos el layout de forma asíncrona
    const calculatedLabels = calculatePlanoLayout(allPoints, mapDimensions.value);

    // Añadimos las etiquetas una por una con un pequeño retardo para no bloquear el UI
    for (const label of calculatedLabels) {
        labels.value.push(label);
        // Pequeña pausa para que el navegador respire
        await new Promise(resolve => setTimeout(resolve, 0));
    }
  };
  
  img.onerror = () => {
      errorState.value = "No se pudo cargar la imagen del plano. Verifica la URL.";
  }
  
  img.src = reportData.value.planoBase64;
};
// --- FIN DE LA CORRECCIÓN CLAVE ---


const generatePdf = async () => {
    isGenerating.value = true;
    isScalingForPdf.value = true;
    await nextTick();

    const canvas = await html2canvas(planoContainer.value, { 
        scale: 1,
        useCORS: true,
        logging: false,
        backgroundColor: '#ffffff'
    });

    isScalingForPdf.value = false;

    const imgData = canvas.toDataURL('image/jpeg', 0.95);
    const pdf = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();
    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight, undefined, 'FAST');
    const { inspectionData } = reportData.value;
    const fileName = `Plano_Incidencias_${inspectionData.centros.nombre.replace(/ /g, '_')}_${inspectionData.fecha_inspeccion}.pdf`;
    pdf.save(fileName);
    isGenerating.value = false;
};

const onMouseDown = (label, event) => {
  draggedLabel.value = label;
  const rect = event.currentTarget.getBoundingClientRect();
  const containerRect = planoContainer.value.getBoundingClientRect();
  
  const badgeX = rect.left - containerRect.left;
  const badgeY = rect.top - containerRect.top;

  dragOffset.value = {
    x: event.clientX - badgeX,
    y: event.clientY - badgeY
  };
  
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
};

const onMouseMove = (event) => {
  if (!draggedLabel.value) return;
  const containerRect = planoContainer.value.getBoundingClientRect();
  
  const newX = event.clientX - containerRect.left - dragOffset.value.x;
  const newY = event.clientY - containerRect.top - dragOffset.value.y;

  draggedLabel.value.position.x = newX + (draggedLabel.value.size.width / 2);
  draggedLabel.value.position.y = newY + (draggedLabel.value.size.height / 2);
};

const onMouseUp = () => {
  draggedLabel.value = null;
  window.removeEventListener('mousemove', onMouseMove);
  window.removeEventListener('mouseup', onMouseUp);
};
</script>

<template>
  <div class="h-screen w-screen bg-slate-800 flex flex-col">
    <header class="w-full bg-white shadow-md p-3 flex justify-between items-center z-20 flex-shrink-0">
      <div class="text-slate-700">
        <h1 class="font-bold">Editor de Plano</h1>
        <p v-if="reportData" class="text-sm text-slate-500">{{ reportData.inspectionData.centros.nombre }}</p>
      </div>
      <div class="flex items-center gap-4">
        <button @click="$router.go(-1)" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold bg-white border border-slate-300 rounded-md hover:bg-slate-50">
          <ArrowUturnLeftIcon class="h-4 w-4" /> Volver
        </button>
        <button @click="generatePdf" :disabled="isGenerating || errorState" class="flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-slate-400">
          <ArrowDownTrayIcon class="h-4 w-4" />
          {{ isGenerating ? 'Generando...' : 'Generar PDF' }}
        </button>
      </div>
    </header>

    <main class="flex-1 p-4 overflow-hidden">
      <div v-if="loading" class="h-full w-full flex items-center justify-center text-white">Cargando previsualización...</div>
      <div v-else-if="errorState" class="h-full w-full flex items-center justify-center text-red-300 bg-red-900/50 p-4 text-center rounded-md">{{ errorState }}</div>
      <div 
        v-else 
        ref="planoContainer" 
        class="relative h-full w-full bg-white select-none"
        :class="{ 'scaling-for-pdf': isScalingForPdf }"
      >
        <img
          v-if="reportData?.planoBase64"
          :src="reportData.planoBase64"
          class="absolute pointer-events-none"
          :style="{ 
            left: `${mapDimensions.x}px`, top: `${mapDimensions.y}px`,
            width: `${mapDimensions.width}px`, height: `${mapDimensions.height}px`
          }"
        >
        
        <svg class="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
          <g v-for="label in labels" :key="'line-' + label.pointData.id">
            <line
              :x1="label.pointData.absX"
              :y1="label.pointData.absY"
              :x2="label.position.x"
              :y2="label.position.y"
              stroke="#94a3b8"
              stroke-width="0.5"
            />
          </g>
        </svg>
        
        <div 
          v-for="label in labels" 
          :key="'badge-' + label.pointData.id"
          @mousedown.prevent="onMouseDown(label, $event)"
          class="z-20 absolute"
          :style="{ 
            left: `${label.position.x - (label.size.width / 2)}px`,
            top: `${label.position.y - (label.size.height / 2)}px`,
            width: `${label.size.width}px`,
            height: `${label.size.height}px`,
          }"
        >
           <PlanoBadge :pointData="label.pointData" :position="label.position" :size="label.size" />
        </div>
      </div>
    </main>
  </div>
</template>

<style>
#app > div.flex.h-screen {
  display: none;
}
.scaling-for-pdf {
  transform: scale(3);
  transform-origin: top left;
}
</style>
--- FIN DEL ARCHIVO: src\views\PlanoPreviewView.vue ---

--- INICIO DEL ARCHIVO: src\views\SubsanacionView.vue ---
<!-- src/views/SubsanacionView.vue -->
<script setup>
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { supabase } from '../supabase';
import { checklistItems } from '../utils/checklist';
import { ArrowUpTrayIcon, CheckCircleIcon } from '@heroicons/vue/24/solid';

const route = useRoute();
const router = useRouter();
const inspeccionId = Number(route.params.id);

const loading = ref(true);
const inspeccion = ref(null);
const incidencias = ref([]);
const isUploading = ref(null);

onMounted(async () => {
  loading.value = true;
  
  const { data: inspectionData } = await supabase
    .from('inspecciones')
    .select('*, centros(nombre)')
    .eq('id', inspeccionId)
    .single();
  inspeccion.value = inspectionData;
  
  // === INICIO DEL CAMBIO: Filtramos para excluir la incidencia del item 2 ===
  const { data: incidenciasData } = await supabase
    .from('incidencias')
    .select('*')
    .eq('inspeccion_id', inspeccionId)
    .neq('item_checklist', 2) // <-- ¡AQUÍ ESTÁ LA MAGIA! Excluimos el item 2
    .order('item_checklist', { ascending: true });
  // === FIN DEL CAMBIO ===
    
  incidencias.value = incidenciasData || [];
  
  loading.value = false;
});

const getItemText = (itemId) => {
  const item = checklistItems.find(i => i.id === itemId);
  return item ? `${item.id}. ${item.text}` : 'Item desconocido';
};

const handleFileChange = async (event, incidencia) => {
  const file = event.target.files[0];
  if (!file) return;

  isUploading.value = incidencia.id;
  const fileName = `subsanacion_${inspeccionId}/incidencia_${incidencia.id}/${Date.now()}_${file.name}`;
  
  const { error: uploadError } = await supabase.storage.from('incidencias').upload(fileName, file, {
    upsert: true
  });
  if (uploadError) {
    alert("Error al subir la foto: " + uploadError.message);
    isUploading.value = null;
    return;
  }
  
  const { data: { publicUrl } } = supabase.storage.from('incidencias').getPublicUrl(fileName);
  
  const { error: updateError } = await supabase
    .from('incidencias')
    .update({ url_foto_despues: publicUrl })
    .eq('id', incidencia.id);

  if (updateError) {
    alert("Error al guardar la URL: " + updateError.message);
  } else {
    incidencia.url_foto_despues = publicUrl;
  }
  
  isUploading.value = null;
};

const todasSubsanadas = computed(() => {
  if (incidencias.value.length === 0) return true;
  return incidencias.value.every(inc => !!inc.url_foto_despues);
});

const finalizarSubsanacion = async () => {
  if (confirm('¿Estás seguro de que todas las incidencias han sido subsanadas y quieres cerrar la inspección?')) {
    const { error } = await supabase.from('inspecciones').update({ estado: 'cerrada' }).eq('id', inspeccionId);
    if (error) {
      alert('Error al cerrar la inspección: ' + error.message);
    } else {
      router.push(`/centros/${inspeccion.value.centro_id}/historial`);
    }
  }
};
</script>

<template>
  <!-- El div raíz ahora ocupa toda la altura y es un contenedor flex vertical -->
  <div class="h-full flex flex-col">
    <div v-if="loading" class="flex-1 flex items-center justify-center">Cargando datos de subsanación...</div>
    
    <!-- Este div interno es el que crece para ocupar el espacio restante -->
    <div v-else-if="inspeccion" class="flex-1 flex flex-col min-h-0">
      
      <!-- Encabezado Fijo -->
      <header class="flex-shrink-0 px-4 sm:px-8 pt-6 sm:pt-8 pb-4 bg-slate-100/80 backdrop-blur-sm border-b border-slate-200 z-10">
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 class="text-2xl sm:text-3xl font-bold text-slate-800">Gestión de Subsanación</h1>
            <p class="text-lg text-slate-600 mt-1">{{ inspeccion.centros.nombre }}</p>
            <!-- === INICIO DE LA CORRECCIÓN === -->
            <p class="text-sm text-slate-500 mt-1">Inspección del {{ new Date(inspeccion.fecha_inspeccion).toLocaleDateString() }}</p>
            <!-- === FIN DE LA CORRECCIÓN === -->
          </div>
          <div class="flex gap-4 w-full sm:w-auto">
            <button @click="router.go(-1)" class="flex-1 sm:flex-none px-4 py-2 font-semibold text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">Volver</button>
            <button @click="finalizarSubsanacion" :disabled="!todasSubsanadas" class="flex-1 sm:flex-none flex items-center justify-center gap-2 px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
              <CheckCircleIcon class="h-5 w-5" />
              Finalizar y Cerrar
            </button>
          </div>
        </div>
      </header>
      
      <!-- Contenido Principal con Scroll -->
      <main class="flex-1 overflow-y-auto p-4 sm:p-8">
        <div class="space-y-6 max-w-7xl mx-auto">
          <div v-if="incidencias.length === 0" class="bg-white p-8 rounded-lg shadow-sm text-center">
              <h3 class="text-lg font-medium text-slate-700">¡No hay incidencias que subsanar!</h3>
              <p class="text-slate-500">Esta inspección no tiene incidencias que requieran una foto de subsanación. Puedes cerrarla directamente.</p>
          </div>
          
          <!-- Incidencias -->
          <div v-for="incidencia in incidencias" :key="incidencia.id" class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 class="font-bold text-lg text-slate-800 border-b pb-3 mb-4">{{ getItemText(incidencia.item_checklist) }}</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <!-- Columna ANTES -->
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">ANTES (Incidencia Original)</p>
                <div class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden">
                  <img v-if="incidencia.url_foto_antes" :src="incidencia.url_foto_antes" class="w-full h-full object-contain">
                  <p v-else class="text-slate-500 text-sm p-4">No se adjuntó foto de la incidencia.</p>
                </div>
                <div v-if="incidencia.observaciones" class="mt-3 text-sm bg-slate-50 p-3 rounded-md">
                  <strong>Observaciones:</strong> {{ incidencia.observaciones }}
                </div>
              </div>
              <!-- Columna DESPUÉS -->
              <div>
                <p class="text-sm font-semibold text-slate-600 mb-2">DESPUÉS (Evidencia de Subsanación)</p>
                <div class="aspect-video bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden relative group">
                  <img v-if="incidencia.url_foto_despues" :src="incidencia.url_foto_despues" class="w-full h-full object-contain">
                  <div v-else-if="isUploading === incidencia.id" class="text-center text-slate-600">Subiendo foto...</div>
                  <div v-else class="text-center">
                    <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInput-' + incidencia.id" accept="image/*">
                    <label :for="'fileInput-' + incidencia.id" class="cursor-pointer flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                      <ArrowUpTrayIcon class="h-4 w-4" />
                      Subir Foto
                    </label>
                  </div>
                   <div v-if="incidencia.url_foto_despues" class="absolute inset-0 bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                     <input type="file" @change="handleFileChange($event, incidencia)" class="hidden" :id="'fileInputChange-' + incidencia.id" accept="image/*">
                     <label :for="'fileInputChange-' + incidencia.id" class="cursor-pointer text-white font-semibold">Cambiar Foto</label>
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </main>
      
    </div>
  </div>
</template>
--- FIN DEL ARCHIVO: src\views\SubsanacionView.vue ---

--- INICIO DEL ARCHIVO: .env.local ---
VITE_SUPABASE_URL="https://bgltxcklvjumltuktdvv.supabase.co"
VITE_SUPABASE_ANON_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJnbHR4Y2tsdmp1bWx0dWt0ZHZ2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3MjkyMTUsImV4cCI6MjA2OTMwNTIxNX0.TtxL8haxS8ez9DgwMKiAGs4FVRkibg_FkULQjXAUqiA"
--- FIN DEL ARCHIVO: .env.local ---

